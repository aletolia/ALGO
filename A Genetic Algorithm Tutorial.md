## 

## A Genetic Algorithm Tutorial

本教程涵盖了规范遗传算法以及更多实验形式的遗传算法，包括并行岛模型和并行细胞遗传算法。 本教程还说明了通过超平面采样进行遗传搜索。 回顾了遗传算法的理论基础，包括模式定理以及最近开发的规范遗传算法的精确模型

#### 1 Introduction

遗传算法是一系列受进化启发的计算模型。 这些算法在简单的类似染色体的数据结构上对特定问题的潜在解决方案进行编码，并将重组算子应用于这些结构以保留关键信息。 遗传算法通常被视为函数优化器，尽管遗传算法所应用的问题范围相当广泛。

遗传算法的实现始于一群（通常是随机的）染色体。 然后评估这些结构并以这样一种方式分配繁殖机会，即那些代表目标问题的更好解决方案的染色体比那些较差解决方案的染色体有更多的机会“繁殖”。

解决方案的“优”通常是根据当前种群定义的。这种对遗传算法的特殊描述是有意抽象的，因为在某种意义上，遗传算法这个术语有两个含义。 在严格的解释中，遗传算法是指由 John Holland (1975) 和 Holland 的学生 (e.g., DeJong, 1975) 引入和研究的模型。 大多数现有的遗传算法理论仍然是这样，要么单独或主要适用于 Holland 引入的模型，以及本文中将被称为规范遗传算法的变体。 建模遗传算法的最新理论进展也主要适用于规范遗传算法（Vose，1993）。

在该术语的更广泛用法中，遗传算法是任何基于群体的模型，它使用选择和重组算子在搜索空间中生成新的样本点。研究人员从实验的角度引入了许多遗传算法模型。 这些研究人员中有许多是面向应用的，并且通常对作为优化工具的遗传算法感兴趣。

本教程的目标是以这样一种方式介绍遗传算法，使刚接触该领域的学生可以在学习本教程时掌握遗传算法背后的基本概念。 它应该允许更老练的读者相对容易地吸收这些材料。 本教程还涵盖了一些主题，例如反演，这些主题有时会被该领域的新研究人员误解和误用。

本教程首先对优化进行了非常初级的讨论，以介绍优化的基本思想以及与遗传算法相关的基本概念。 在第 2 节中，回顾了典型的遗传算法。 第 3 节探讨了超平面采样的原理，并介绍了一些基本的交叉算子。 在第 4 节中，模式定理的各种版本逐步发展，并讨论了其他交叉算子。 在第 5 节中考虑了二进制字母及其对超平面采样的影响。 在第 6 节中考虑了对模式定理的简要批评，并在第 7 节中开发了遗传算法的精确模型。 本教程的最后三个部分涵盖了遗传算法和进化计算模型的替代形式，包括专门的并行实现

##### 1.1 Encodings and Optimization Problems

大多数遗传算法中通常只有两个与问题相关的主要元素：问题编码和评估函数。

考虑一个参数优化问题，我们必须优化一组变量以最大化某些目标（例如利润的大小），或者最小化成本或某种误差。 我们可能会将此类问题视为一个黑匣子，其中包含一系列代表不同参数的控制旋钮； 黑盒的唯一输出是评估函数返回的值，该值指示特定参数设置组合解决优化问题的效果。 目标是设置各种参数以优化某些输出。 用更传统的术语来说，我们希望最小化（或最大化）某个函数 $F(X_1,X_2,..., X_M)$。

遗传算法的大多数用户通常关注非线性问题。这通常也意味着不可能将每个参数视为可以独立于其他变量求解的独立变量。 为了最大化或最小化黑盒的输出，必须考虑参数的组合效应。 在遗传算法中，变量之间的相互作用有时被称为上位性。

通常做出的第一个假设是表示参数的变量可以由位串**(bit strings)**表示。 这意味着变量以先验方式离散化，并且离散化的范围对应于 2 的某个幂。例如，对于每个具有10 比特位的参数，我们将会获得具有 1024 个离散值的区间。 如果参数实际上是连续的，那么这种离散化就不是一个特别的问题。 当然，这假设离散化提供了足够的分辨率，以便能够以所需的精度水平调整输出。 它还假设离散化在某种意义上代表了底层函数

如果某些参数只能采用一组精确的有限值，那么编码问题就变得更加困难。 例如，如果恰好有 1200 个离散值可以分配给某个变量 $X_i$，该怎么办？ 我们至少需要 11 位来覆盖这个范围，但是这个代码总共有 2048 个离散值。  848 个不必要的位可能会导致没有评估、默认的最坏评估，或者某些参数设置可能会被表示两次，以便所有二进制字符串都产生一组合法的参数值。 解决此类编码问题通常被认为是评估函数设计的一部分。

除了编码问题，评估函数通常作为问题描述的一部分给出。 另一方面，开发评估函数有时可能涉及开发模拟。 在其他情况下，评估可能基于绩效并且可能仅代表近似或部分评估。 例如，考虑一个控制应用程序，其中系统可以处于指数级的大量可能状态中的任何一种。 假设使用遗传算法来优化某种形式的控制策略。 在这种情况下，必须以有限的方式对状态空间进行采样，并且由此产生的控制策略评估是近似且嘈杂的（参见 Fitzpatrick 和 Grefenstette，1988）。

评估函数也必须相对较快。 对于任何优化方法来说，这通常都是正确的，但它可能对遗传算法尤其造成问题。 由于遗传算法适用于潜在解决方案的群体，因此会产生评估该群体的成本。 此外，种群会在代际基础上（全部或部分）被替换。

种群的成员进行繁殖，然后必须评估它们的后代。 如果做一个评估需要1小时，那么做10000次评估需要1年多。 对于只有 200 个字符串的群体，这将是大约 50 代。

##### 1.2 How Hard is Hard?

假设参数之间的相互作用是非线性的，搜索空间的大小与问题编码中使用的比特数有关。 对于长度为 $L$​ 的位串编码； 搜索空间大小为 $2^L$​，形成一个超立方体。 遗传算法对这个 $L$​ 维超立方体的角进行采样。

通常，大多数测试函数的长度至少为 30 位，大多数研究人员可能会同意需要更大的测试函数。 任何小得多的东西都代表一个可以枚举的空间。  （考虑一下 1993 年美国的国债大约为 $2^{42}$​ 美元，$2^{30}$​ 听起来并没有那么大。）当然，表达式 $2^L$​ 相对于 $L$​ 呈指数增长。考虑编码为 400 位的问题。 关联的搜索空间有多大？ 一本关于人工智能的经典介绍性教科书给出了这种大小空间的一个特征。  Winston (1992:102) 指出，$2^{400}$ 是国际象棋中可能的棋盘配置的搜索空间的有效大小的一个很好的近似值。  （这假设每个可能移动的有效分支因子为 16，并且游戏由 100 个移动组成；$16^{100}$​ = $(2^4)^{100} = 2^{400}$）。温斯顿说这是一个大得离谱的数字。 事实上，如果宇宙中的所有原子自大爆炸（如果有的话）以来一直以皮秒的速度计算国际象棋走法，那么分析才刚刚开始。”

关键是，只要问题的“好的解决方案”的数量相对于搜索空间的大小来说是稀疏的，那么随机搜索或通过枚举大的搜索空间进行搜索就不是解决问题的实用形式 .另一方面，除了随机搜索之外的任何搜索都会在如何寻找更好的解决方案以及它在搜索空间中的位置方面施加一些偏差。遗传算法确实在空间中的哪些新点方面引入了特定的偏差 然而，遗传算法属于人工智能社区中被称为“弱方法”的一类方法，因为它对正在解决的问题做出的假设相对较少。

当然，在数学和运筹学中已经开发了许多优化方法。 遗传算法作为优化工具扮演什么角色？ 遗传算法通常被描述为一种不使用梯度信息的全局搜索方法。 因此，不可微函数以及具有多个局部最优值的函数代表可能应用遗传算法的问题类别。

遗传算法作为一种弱方法，鲁棒但非常通用。 如果针对特定问题存在良好的专门优化方法，那么遗传算法可能不是该应用程序的最佳优化工具。 另一方面，一些研究人员使用混合算法，将现有方法与遗传算法相结合。

#### 2 The Canonical Genetic Algorithm

实现任何遗传算法的第一步是生成初始种群。在规范遗传算法中，这个群体的每个成员都是一个长度为 $L$​ 的二进制字符串，对应于问题编码。 每个字符串有时被称为 "genotype" (Holland, 1975) 或 "chromosome" (Schaer, 1987)。 在大多数情况下，初始种群是随机生成的。 创建初始种群后，然后评估每个字符串并分配一个适应度值。

评估和适应度的概念有时可以互换使用。 但是，区分评估函数和遗传算法使用的适应度函数是有用的。 在本教程中，评估函数或目标函数提供了关于一组特定参数的性能度量。适应度函数将这种绩效衡量转化为生殖机会的分配。表示一组参数的字符串的评估独立于任何其他字符串的评估。 然而，该字符串的适应度总是相对于当前种群的其他成员来定义的。

在规范遗传算法中，适应度定义为： $f_i/ f$ 其中 $f_i$ 是与字符串 $i$ 关联的评估，$f$ 是总体中所有字符串的平均评估。也可以根据字符串在总体中的排名（Baker，1985；Whitley，1989）或通过抽样方法，例如锦标赛选择（Goldberg，1990）来分配适应度。

将遗传算法的执行视为两阶段过程是有帮助的。 它从当前的种群开始。**选择**应用于当前种群以创建中间种群。 然后将**重组和突变**应用于中间种群以创建下一个种群。 从当前种群到下一个种群的过程构成了遗传算法执行中的一代。Goldberg (1989) 将此基本实现称为简单遗传算法 (SGA)。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728125203677.png" alt="image-20210728125203677" style="zoom: 80%;" />

我们将首先考虑从当前种群构建中间种群。 在第一代中，当前种群也是初始种群。 对当前种群中的所有字符串计算 $f_i/\bar{f}$ 后，进行选择。 在规范遗传算法中，当前种群中的字符串被复制（即重复）并放置在中间代中，其概率与其适应度成正比。

有多种方法可以进行选择。 我们可以将总体映射到轮盘赌轮上，其中每个人都由一个与其适应度成比例对应的空间表示。 通过反复旋转轮盘赌轮，使用“有替换的随机抽样”来选择个体以填充中间群体。

更接近于预期适应度值的选择过程是 “remainder” 随机抽样。”对于 $f_i/\bar{f}$​ 大于 $1.0$​ 的每个字符串 $i$​，该数字的整数部分表示该字符串的多少副本被直接放入中间群体。所有字符串（包括那些 $f_i/ \bar{f}$​ 小于 $1.0$​ 的字符串）然后在中间群体中放置额外的副本，其概率对应于 $f_i/\bar{ f}$​ 的小数部分。例如，具有 $f_i/\bar{f}=1.36$​ 的String在中间种群中放置 1 个副本，然后获得 $0.36$​ 放置第二个副本的机会。具有 $f_i/\bar{ f} = 0.54$​ 适应度 的字符串有 0.54 在中间种群中放置一个字符串的机会 

''剩余随机抽样”是使用称为随机通用抽样的方法最有效地实现的。假设人口以随机顺序排列，如饼图，其中每个人在饼图上被分配与适应度成比例的空间 . 接下来，在饼周围放置一个带有 N 个等距指针的外轮盘。轮盘的单次旋转现在将同时选择中间种群的所有 N 个成员。结果选择也是无偏的（Baker，1987）。

选择完成后，中间群体的构建完成，可以进行重组。 这可以看作是从中间种群创建下一个种群。 交叉应用于随机配对的字符串，概率表示为 $p_c$​（随机选择过程应该已经充分地调整了总体）选择一对字符串。 以概率 $p_c$​ 重组这些字符串形成两个新的字符串，插入到下一个群体中。

考虑以下二进制字符串：1101001100101101。该字符串将代表某些参数优化问题的可能解决方案。 空间中的新样本点是通过重新组合两个父字符串生成的。 考虑字符串 1101001100101101 和另一个二进制字符串 yxyyxyxxyyyxyxxy，其中值 0 和 1 由 x 和 y 表示。 使用单个随机选择的重组点，1 点交叉发生如下

![image-20210728210228445](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210228445.png)

在两个父对象之间交换片段会产生以下字段

![image-20210728210251303](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210251303.png)

重组后，我们可以应用变异算子。 对于总体中的每一个字段，它们都会以一些低概率 $p_m$ 变异。 通常，突变率的应用概率小于 1%。 在某些情况下，突变被解释为随机生成一个新位（一个随机的1或者0），也就是说，在这种情况下，只有 50% 的突变会实际改变位值。在其他情况下，突变被解释为意味着实际 ping 位。 只要用户/读者意识到差异并理解第一种形式的变异产生位值变化的频率仅为第二种形式的一半，并且变异的一个版本只是另一个的缩放版本。

在选择、重组和突变过程完成后，可以评估下一个种群。 遗传算法在执行过程中，评估、选择、重组和变异的过程形成一代

##### 2.1 Why does it work? Search Spaces as Hypercubes

大多数刚接触遗传算法领域的人此时会问的问题是，为什么这样的过程应该做任何有用的事情。 为什么要相信这会产生一种有效的搜索或优化形式？

最广泛地解释遗传算法的计算行为的答案来自 John Holland 的工作。 在他 1975 年的经典著作《自然和人工系统中的适应》中，Holland 提出了几个论点，旨在解释 “遗传计划”或“遗传算法”如何通过隐式采样搜索空间的超平面分区来实现复杂而稳健的搜索。

也许理解遗传算法如何对超平面分区进行采样的最好方法是考虑一个简单的 3 维空间（见图 2）。 假设我们有一个仅用 3 位编码的问题； 这可以表示为一个简单的立方体，原点是字符串 000。 这个立方体中的角由位串编号，所有相邻的角由位串标记，位串正好相差 1 位。 图 2 顶部给出了一个示例。立方体的前平面包含所有以 0 开头的点。如果"*" 表示"don't care" 或通配符匹配符号，则该平面也可以由特殊字符串0** 表示。 包含 * 的字符串称为模式（**schema**）； 每个模式对应于搜索空间中的一个超平面。 超平面的”阶数“指的是出现在其模式中的实际位值（指的是不可以变动的数）的数量。因此，1** 是 1 阶，而 $1****1**0**$ 是 3 阶 .

![image-20210728210642314](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210642314.png)

如果位串可以通过将适当的位值替换为 "*" 符号从超平面中构造出来（指找到一个“共集”），那么位串与特定架构匹配。通常，与特定架构匹配的所有位串都包含在由该架构表示的超平面分区中。每个二进制编码都是一个“染色体”，它对应于超立方体中的一个角，并且是(指的是所有这些拥有同样编码共性的字段) $2^L-1$  个不同超平面的成员，其中 $L$ 是二进制编码的长度。  （所有 * 符号的字符串对应于空间本身，不计为空间的分区（Holland 1975:72））。 这可以通过取一个位串并查看可以用 "*" 符号替换任何位子集的所有可能方式来显示。换句话说，位串中有 $L$ 个位置，每个位置可以是位 包含在字符串或 \*" 符号中的值。

也相对容易看出，可以在整个搜索空间上定义 $3^L-1$  超平面分区。 对于位串中的每个 $L$ 位置，我们可以使用值 *、1 或 0，从而产生 $3^L$ 种组合。

如果孤立地检查搜索空间中的每个点，则确定每个字符串都是 $2^L- 1$ 超平面分区的成员并不能提供太多信息。 这就是为什么基于群体的搜索的概念对遗传算法至关重要。 一组样本点提供了有关众多超平面的信息； 此外，低阶超平面应该由总体中的许多点进行采样。  （在本文的后续部分中更详细地重新研究了这个问题）遗传算法的内在或隐式并行性的一个关键部分来自这样一个事实，即我们可以在评估一组字符串时对许多超平面进行采样（Holland 1975）； 事实上，可以说采样的超平面数量比总体中包含的字符串数量多得多。 每次评估单个字符串时，都会以隐式并行方式评估不同的超平面（Holland 1975:74）； 但它是评估一组点的累积效应，提供有关任何特定超平面子集的统计信息。隐式并行意味着许多超平面竞争同时并行解决。 该理论表明，通过复制和重组过程，竞争超平面的图式根据位于这些超平面分区中的字符串的相对性来增加或减少它们在总体中的表示。

由于遗传算法对字符串群体进行操作，因此可以通过跟踪代表群体中特定超平面的单个模式的比例表示，来指示当基于适合度的选择与交叉结合时，该超平面所代表的种群中的个体数是否会随着时间的推移增加或减少

(注：Holland 最初在其 1975 年的专著中使用术语内在并行性，然后决定改用隐式并行性以避免与并行计算中的术语混淆。 不幸的是，并行计算社区中的术语隐式并行是指从用没有显式并行构造的函数式语言编写的代码中提取的并行性。 隐式并行并不是指在并行硬件上运行遗传算法的潜力，尽管遗传算法通常被视为高度可并行化的算法)

#### 3 Two Views of Hyperplane Sampling

图 3 显示了另一种查看超平面分区的方法。将单个变量上的函数绘制为一维空间，以函数最大化为目标。

超平面 $0****...**$​ 张得空间的前半部分，而 $1****...**$​ 张出空间的后半部分。 由于 $0****...**$​ 分区中的字符串的适合度好于 $1****...**$​ 分区中的字符串，我们希望搜索按比例偏向该分区。 在第二张图中，与 $**1**...**$​ 对应的空间部分被阴影化，这也突出了 $0****...**$​ 和 $**1**...**$​ 的交集 ，即 $0*1*...**$​。最后，在第三张图中，$0*10**...**$ 突出显示。

图 3 的要点之一是超平面分区的采样并没有真正受到局部最优的影响。 同时，与其他竞争分区相比，提高高于平均水平的分区的采样率并不能保证收敛到全局最优。 例如，全局最优可能是一个相对孤立的峰值。

查看一个运行中的简单遗传算法的示例也是一个有用的练习。在表 1 中，明确给出了每个字符串的前 3 位，而未指定其余位位置。 目标是仅查看在前 3 位位置上定义的那些超平面，以便查看根据 适合度复制字符串时在选择阶段实际发生的情况。 遗传算法背后的理论表明，每个超平面中点的新分布应该根据相应超平面分区中包含的种群中字符串的平均适合度变化。因此，即使遗传算法从未明确评估任何特定的超平面分区，它也应该改变字符串副本的分布，就好像它已经如此规定了一样。

![image-20210731141524844](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731141524844.png)

![image-20210731141533144](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731141533144.png)

![image-20210731142003171](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731142003171.png)

表 1：根据等级将适合度分配给字符串的总体。  Random 是一个随机数，它决定是否为适合度的小数余数授予一个字符串的副本

表 1 中的示例总体仅包含 21 个（部分指定的）字符串。 由于我们并不特别关心这些字符串的精确评估，因此将根据等级分配适合度值。（未详细讨论按等级而不是按比例表示分配适合度的概念，但当前示例涉及由于适合度引起的表示变化，而不是如何分配该适合度。）该表包括有关每个字符串适合度的信息和要放置在中间群体中的副本数。 在此示例中，选择期间生成的副本数通过自动分配整数部分来确定，然后通过生成 0.0 和 1.0 之间的随机值（余数随机采样的一种形式）分配小数部分。 如果随机值大于（1-余数）； 然后将额外的副本授予相应的个人。

当选择作用于群体时，遗传算法似乎并行地隐式处理许多超平面. 表 2 列举了 27 个超平面 ($3^3$)，这些超平面可以定义在群体中字符串的前三位，并明确计算与相应超平面分区相关联的适合度。 超平面分区的真实适合度对应于位于该超平面分区中的所有字符串的平均适合度。

遗传算法使用总体作为样本来估计该超平面划分的适合度。 当然，样本只有在第一代期间是随机的。 在此之后，新字符串的样本应该偏向于先前包含的字符串高于先前种群平均适合度水平的区域。

如果遗传算法如我们所描述的那样工作，则选择后实际落在特定超平面分区中的字符串副本数应近似于应落在该分区中的预期副本数。

![image-20210731143935259](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731143935259.png)

表2：明确计算了在第一个三比特位置上定义的27个超平面的样本的平均适合度（Mean）。显示了预期表示（Expect）和观察表示（Obs）。Count指选择前超平面H中的字符串数。

在表 2 中，可以通过将选择前当前总体中超平面样本的数量乘以落入该分区的总体中字符串的平均适合度来计算选择后对超平面分区进行采样的预期字符串数（在上表中即为 "Mean" $\times$ "Count")，上表还给出了选择后实际得到的可观察副本数。 在大多数情况下，预期采样率和观察到的采样率之间的匹配度相当好：误差是由于总体规模较小而导致的抽样误差

开始将跟踪超平面的潜在采样率 $H$​​ 的想法用数学语言表示是有用的。记 $M(H, t)$​ 是当前代 $t$​ 中某个群体中采样 $H$​ (即超平面 $H$ )中所包含的字符串数量。 记 $(t+intermediate)$​ 为第 $t$ 代在选择后（但在交叉和变异之前）的世代，$f(H,t)$ 是当前种群中分区 $H$ 中字符串样本的平均适应度。 因此根据此前的表述，我们得到这个选择后（但在交叉和变异前的）世代中的个体（字符串）数量为：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731161300393.png" alt="image-20210731161300393" style="zoom: 50%;" />

当然，当字符串仅被复制时，实际上不会发生新的超平面采样，因为没有生成新的样本。 从理论上讲，我们希望有一个具有相同分布的新点样本。 在实践中，这通常是不可能的。然而，重组和变异提供了一种生成新样本点的方法，同时部分地保留了在中间群体中观察到的跨超平面的字符串分布

##### 3.1 Crossover Operators and Schemata

表 2 中观察到的超平面表示对应于选择后但重组前的中间群体中的表示。 重组对观察到的字符串分布有何影响？ 显然，1 阶超平面样本不受重组的影响，因为单个关键位总是由后代之一继承。 然而，观察到的来自 2 阶及更高阶超平面分区的潜在样本分布可能会受到交叉的影响。 此外，相同阶的所有超平面不一定以相同的概率受到影响。 考虑单点杂交。 这个重组算子很好，因为它相对容易量化它对表示超平面的不同模式的影响。 为简单起见，假设我们正在处理一个仅用 12 位编码的字符串。 现在考虑以下两个模式

![image-20210731144526380](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731144526380.png)

第一个模式中的位在单点杂交期间被这两个“基因”（指的是字符串中不变的两个点位）被分离的概率仅为 $1/L- 1$​​，因为通常在长度为 $L$​​ 的字符串中存在 $L- 1$​ 个交叉点；而右边的字符串两个基因被分离的概率则为 $(L-1)(这是两个点位之间的间隔数)/(L-1)(字符串中的总间隔数)=1.0$​ ，因此我们观察到：当使用单点杂交时，模式中基因的位置对于确定这些基因在交叉期间保持在一起的可能性很重要

###### 3.1.1  2-point Crossover

如果使用两点杂交算子会发生什么？ 两点杂交算子使用两个随机选择的交叉点，字符串会交换落在这两个点之间的段。  Ken DeJong 首先观察到 (1975)两点杂交将字符串和模式视为形成一个环，这可以说明如下：

![image-20210731144658012](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731144658012.png)

其中 $b1$​​​​ 到 $b12$​​​ 表示第 $1$​​​ 到 $12$​​ 位。从这种角度来看，单点杂交是两点杂交的一种特殊情况，即对于单点杂交而言，其中一个交叉点总是出现在第一个和最后一个比特之间的环绕位置。 现在，当 2 位位于此环上的互补位置时，会发生 2 阶模式的最大中断。

对于单点和两点杂交，很明显，在字符串编码（或环）上具有靠近在一起的位的模式不太可能被交叉破坏。更准确地说，由具有更紧凑表示的模式表示的超平面应该以更接近于单独选择实现的那些潜在采样分布目标的速率进行采样。 对于当前的目的，关于模式的紧凑表示是最小化交叉期间中断概率的表示。 请注意，此定义依赖于算子，因为在 3.1 节中检查的两个 2 阶模式在 2 点交叉方面具有同等且最大程度的紧凑性，但在 1 点交叉方面存在最大差异。

###### 3.1.2 Linkage and Defining Length

连锁是指一组位作为\coadapted 等位基因"的现象，它们倾向于作为一个集合一起遗传。在这种情况下，等位基因将对应于染色体上特定位置的特定位值。当然， 连锁现象可以看作是关于模式的紧凑表示概念的概括。连锁有时由字符串编码中位的物理相邻性定义；这隐含地假设单点杂交是正在使用的运算符。连锁在两点杂交下是不同的，当被视为一个环时，必须根据染色体上的距离来定义。然而，连锁通常等同于字符串上的物理邻接，通过我们定义的所谓定义长度来衡量。

模式的定义长度基于模式中第一个和最后一个位之间的距离，值为 0 或 1（即，不是 * 符号）。 鉴于模式中的每个位置都可以是 0、1 或 $*$​，我们采用下面的方法来解决这个问题：我们从右至左检查字符串中的值，第一个（换言之，是最右侧的）不是 $*$​ (即，该位的值不是 1 即为 0 ）的位被定义为 $I_x$​ ,而最左侧的符合此标准的位被定义为 $I_y$​ ，定义长度定义为 $I_x-I_y$​ （注意：位数的计算是从左至右递增的，因此这里是为了保证定义长度非负）。因此，$****1**0**10**$​ 的定义长度为 $12- 5 = 7$​​。此处表示超平面 $H$​ 上的模式的定义长度由 $\Delta (H)$ 表示。 定义长度是对有多少可能的交叉点落在图式的重要部分内的直接度量。 如果使用单点杂交，则 $\Delta(H)/L -1$ 也是交叉在交叉期间落入图式的重要部分的可能性的直接度量。

###### 3.1.3 Linkage and Inversion

与变异和交叉一起，倒位通常被认为是基本的遗传算子。倒位可以改变染色体上位之间的等位关系，使得具有更大非线性相互作用的位可能在染色体上更靠近地移动。通常，倒位是通过倒位染色体的随机片段来实现的，但是，在开始移动染色体上的位以改善等位基因之前，这些位必须具有与位置无关的解码。 一些研究人员在第一次实施倒位时犯的一个常见错误是直接倒位编码染色体的位段。 但是，如果从位到参数的映射是位置相关的，那么仅仅倒位一些随机的位段只不过是大规模的变异。

位置无关编码要求以某种方式标记每个位。 例如，考虑以下由对组成的编码，其中第一个数字是一个位标记，它为位索引，第二个数字表示位值。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801151526484.png" alt="image-20210801151526484" style="zoom:67%;" />

现在可以通过在标签位对周围移动来改变链接，但解码时字符串保持不变：010010110。现在还必须考虑如何实现重组。  Goldberg 和 Bridges (1990)、Whitley (1991) 以及 Holland (1975) 讨论了利用链接和标记表示重组的问题

#### 4 The Schema Theorem（图式定理）

现在已经为发展遗传算法的基本定理奠定了基础。模式定理 (Holland, 1975) 为单个超平面从第 $t$​ 代到第 $t + 1$ 代的采样率变化提供了下限。

再次考虑当只发生选择时特定超平面 $H$ 会发生什么

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801151822055.png" alt="image-20210801151822055" style="zoom: 67%;" />

为了计算 $M(H,t+1)$，我们必须考虑交叉的影响，因为下一代是从中间代创建的。 首先，我们考虑将交叉概率应用于一部分总体。 对于没有进行交叉的那部分种群，由于选择而产生的表示不变。 当交叉确实发生时，我们必须计算由于其破坏性影响造成的损失。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801153458175.png" alt="image-20210801153458175" style="zoom: 67%;" />

在推导模式定理时，在这一点上做出了一个保守的假设：假设在模式定义长度内的交叉总是会破坏表示 $H$​​ 的模式。事实上，这不是真的，交叉影响的精确计算将在本文后面介绍。 例如，假设我们对模式 $11*****$​​ 感兴趣。 如果将诸如 1110101 之类的字符串与诸如 1000000 或 0100000 之类的字符串在前两位处进行交叉互换，则超平面 $11*****$​​ 中不会发生中断，因为其中会有一个后代仍将驻留在该分区中。 此外，如果 1000000 和 0100000 恰好在第一个和第二个位之间发生交叉互换，则新的独立后代将同样拥有 $11*****$​ 的形式​； 这就是上述计算中提到的收益来源。 为简化起见，忽略了收益，并做出了保守假设，即落在模式重要部分的交叉总是会导致中断。 因此，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801154243843.png" alt="image-20210801154243843" style="zoom: 67%;" />

中断高估了损失。 我们可能希望考虑一种例外情况：如果两个包含在样本 $H$​​ 内的两个字符串之间发生交叉互换，则不会发生中断。 令 $P(H, t)$​ 表示在 $H$ 在总体中的占比大小，其值通过将 $M(H,t)$ 除以种群大小来得到。换言之，随机选择情况下，样本 $H$ 内部出现配对的概率为 $P(H,t)$。 回想一下，$\Delta(H)$ 是与单点杂交相关的定义长度。 因此，中断的数目由下式给出：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801154557633.png" alt="image-20210801154557633" style="zoom:67%;" />

此时，可以简化不等式。 两边都可以除以种群大小，将其转换为 $P(H, t + 1)$​ 的表达式，即 $H$​ 在 $t +1$​ 代的比例表示： 此外，该表达式可以相对于 $p_c$ 重新排列。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801155217128.png" alt="image-20210801155217128" style="zoom:67%;" />

我们现在有了模式定理的一个有用版本（尽管它还没有考虑变异）； 但这并不是文献中的唯一版本。 例如，父本和母本其中一方（或双方）通常都具有一定的适合度要求，这可以通过从中间群体中选择替代亲本来添加到模式定理中：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801155416175.png" alt="image-20210801155416175" style="zoom:67%;" />

最后，我们将突变包括其中。 令 $o(H)$ 是一个返回超平面 $H$ 阶数的函数。$H$ 的阶数恰好对应于表示 $H$ 的模式中具有值 $0$ 或 $1$ 的位数的计数。设变异概率为 $p_m$​，其中突变总是将突变位点的基因进行倒位。 因此，突变影响表示 $H$ 的模式的概率是 $(1-p_m)^{o(H)}$，因此修正表达式如下：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801155832820.png" alt="image-20210801155832820" style="zoom:67%;" />

##### 4.1 Crossover, Mutation and Premature Convergence

显然，模式定理最强调交叉和超平面采样在遗传搜索中的作用。 为了最大限度地保留选择后的超平面样本，应该最大限度地减少交叉和突变的破坏性影响。 这表明可能根本不应该使用突变，或者至少应该以非常低的水平使用。因此，使用突变的动机是为了防止任何特定位或等位基因的永久丢失。 几代之后，选择可能会将某个位置的所有位变为单个值：0 或 1。如果发生这种情况，遗传算法没有收敛到令人满意的解决方案，则算法过早收敛。

如果种群大小过小，这可能尤其成问题。 如果没有变异算子，就不可能重新引入丢失的位值。 此外，如果目标函数是非平稳的，并且适应度函数随时间变化（在真实的生物系统中肯定是这种情况），那么需要有一些持续遗传多样性的来源。 因此，突变充当背景算子，偶尔会改变位值并允许重新测试替代等位基因（和超平面分区）。

这种对突变的特殊解释忽略了它作为爬山机制的潜力：从模式定理突变强加的严格超平面采样的角度来看，它是一种必要之恶。 但这也许是一种有限的观点，有几位实验研究人员指出，使用突变和无交叉的遗传搜索通常会产生相当稳健的搜索，并且几乎没有理论可以解决超平面采样和爬山在遗传搜索中的相互作用。

另一个与过早收敛相关的问题是需要缩放总体适合度。 随着总体中字符串的平均适合度增加，总体中适合度的方差减小。 几代后，种群中最好和最差的个体可能差别不大，基于适合度的选择压力也相应降低。 这个问题可以通过使用某种形式的适合度标度来部分解决（Grefenstette，1986；Goldberg，1989）。 在最简单的情况下，可以从总体中所有字符串的适合度中减去总体中最差字符串的是和渎职。 现在可以使用这种调整后的评估来计算平均字符串评估以及适合度 值，这将增加产生的选择压力。 或者，可以使用基于rank的选择形式。

##### 4.2 How Recombination Moves Through a Hypercube

单点杂交的好处在于它易于分析建模。 但也很容易通过分析表明，如果人们对最小化模式中断感兴趣，那么两点杂交会更好。 但是应该避免使用许多交叉点的算子，因为它会严重破坏模式。 这又是对模式定理的严格解释所强加的观点。 另一方面，中断可能不是影响遗传算法性能的唯一因素。

###### 4.2.1 Uniform Crossover

近年来最受关注的算子是匀速交叉。Ackley (1987) 详细研究了均匀交叉，Syswerda (1989) 将其推广。 均匀交叉的工作原理如下：对于每个位位置 $1$​ 到 $L$​，从两个父字符串中的任何一个中随机选取每个位。 这意味着每个位都是独立于任何其他位继承的，实际上，位之间没有等位关系。 这也意味着均匀交叉在定义长度方面是无偏的。 一般而言，中断的概率为 1 (1=2)o(H)1，其中 o(H) 是我们感兴趣的模式的顺序（哪个后代继承第一个关键位并不重要，但所有其他位都必须由同一个后代继承。这也是最坏情况下的中断概率，假设在感兴趣的模式中没有发现等位基因被共享 ) 因此，对于任何 3 阶模式，将关键位分开的均匀交叉概率总是 1 􀀀 (1=2)2 = 0:75。 考虑一下 9 位的字符串。 模式的定义长度必须等于 6，然后 1 点交叉的破坏概率与均匀交叉相关的概率匹配 (6/8 = .75)。 我们可以在任何特定的 9 位字符串（即 9 选择 3）上定义 84 个不同的 3 阶模式。 在这些模式中，84 个二阶模式中只有 19 个在 1 点交叉下的中断率高于 0.75。 另外 15 个具有完全相同的中断率，84 个 2 阶模式中的 50 个具有较低的中断率。 相对容易证明，虽然均匀交叉在定义长度方面是无偏的，但它通常也比 1 点交叉更具破坏性。  Spears 和 DeJong (1991) 已经表明，对于所有定义长度的 3 阶模式，均匀交叉在任何情况下都比 2 点交叉更具破坏性。

![image-20210801160909426](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801160909426.png)

尽管有这些分析结果，但一些研究人员认为均匀交叉有时是更好的重组算子。 可以指出它在模式破坏方面缺乏代表性偏见作为一种可能的解释，但这不太可能，因为均匀交叉比 2 点交叉更差。  Spears 和 DeJong (1991:314) 推测，\对于小群体，更多破坏性的交叉算子，如一致或 n 点 (n 2) 可能会产生更好的结果，因为它们有助于克服小群体的有限信息容量和趋势 为了更均匀。” Eshelman (1991) 提出了类似的论点，概述了破坏性运营商的优势。
   还有另一种意义上的均匀交叉是无偏的。 假设我们希望重新组合位串 0000 和 1111。我们可以方便地布置 4 维超立方体，如图 4 所示。我们也可以将这些串视为通过一组通过超立方体的最小路径连接； 选择一个父字符串作为起点，另一个作为目的地。 现在更改与原点相对应的二进制表示中的单个位。 任何这样的移动都会到达离目的地更近一步的点。
   在图 4 中，很容易看出更改单个位是图形中的向上或向下移动。
   0000 和 1111 之间的所有点都可以通过某种统一交叉的单一应用来达到。 然而，1 点交叉仅生成沿着通过这个 4 维超立方体的两条互补路径（图中最左边和最右边的路径）的字符串。 通常，均匀交叉将从位于两个父级之间的超立方体中任何互补最小路径上的所有点以相等的概率绘制一对互补的样本点，而 1 点交叉仅从两个特定的互补最小路径之间的两个特定互补最小路径中抽取样本点。 两个父字符串。 也很容易看出 2 点交叉比 1 点交叉限制更少。 注意，两个串之间不同的比特数就是汉明距离H。不包括原始父串，均匀交叉可以产生2H 2个不同的串，而1点交叉可以产生2（H 􀀀  1) 不同的弦，因为有 H 交叉点产生唯一的 o 弹簧（见下一节的讨论），每个交叉点产生 2 o 弹簧。  2 点交叉算子可以生成 2 H 2 = H 2 􀀀H 不同的 18 o spring，因为有 H 选择 2 个不同的交叉点，这将导致 o spring 不是父母的副本，并且每对 交叉点生成 2 个字符串。

##### 4.3 Reduced Surrogates

考虑将以下两个字符串和相同字符串的 \reduced" 版本交叉，其中字符串共享的位已被删除

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801212254804.png" alt="image-20210801212254804" style="zoom:67%;" />

两个字符串都位于超平面 0001**101*01001* 中。 此观察的 ip 方面是交叉实际上仅限于在不同位位置上定义的子立方体。 我们可以通过删除两个父结构中所有等效的位来隔离这个子多维数据集。  Booker (1987) 将 ----11---1-----1 和 ----00---0-----0 等字符串称为原始父代的\reduced surrogates 染色体。
   以这种方式查看时，很明显这些特定字符串的重组发生在 4 维子立方体中，或多或少与前一个示例中检查的相同。
   均匀交叉相对于该子立方体是无偏的，因为均匀交叉仍将以无偏、均匀的方式从位于两个原始父字符串之间定义的子立方体中的互补最小路径上的所有点对中采样。 另一方面，简单的 1 点或 2 点交叉不会。 为了帮助说明这个想法，我们重新组合了原始字符串，但检查了 \reduced" 形式的 o spring。例如，简单的 1 点交叉将生成 o spring ----11---1-----  0 和 ----00---0-----1 的概率为 6/15，因为在缩减子多维数据集中的第三和第四位之间的原始父字符串中有 6 个交叉点，L-1 =  15. 另一方面，----10---0-----0 和----01---1-----1 被采样的概率只有 1/15，因为那里 只是原始父结构中位于定义子立方体的第一个和第二个位之间的单个交叉点。
   然而，人们可以消除这种特殊的偏见。 我们在减少的代理上应用交叉。
   交叉现在可以利用这样一个事实，即以简化代理形式出现的任何显着位之间实际上只有 1 个交叉点。 还有另一个好处。
   如果在减少的代理中的第一个和最后一个显着位之间至少有 1 个交叉点，则保证 o spring 不是父代的重复。  （这假设父母至少相差两位）。 因此，产生了超空间中的新样本点。
   关于统一交叉和算子（例如 2 点减少代理交叉）的优点的辩论并不是一个封闭的问题。 为了充分理解超平面采样、种群大小、早熟收敛、交叉算子、遗传多样性和变异爬山的作用之间的相互作用，需要更好的分析方法。

#### 5 The Case for Binary Alphabets

使用最小二进制字母表背后的动机是基于相对简单的计数参数。 最小字母表最大化了编码模式处理中直接可用的超平面分区的数量。 这些低阶超平面分区的采样率也高于基数较高的字母表的采样率。
   任何 1 阶模式集（例如 1*** 和 0***）都会将搜索空间减少一半。 显然，有 L 对 1 阶模式。 对于 2 阶模式，有 L 2 种方法来选择放置 2 个关键位位置的位置，并且有 22 种可能的方法来为这些位赋值。 一般而言，如果我们希望计算在某个阶 i 处存在多少表示超平面的模式，则该值由 2i Li i 给出，其中 Li 计算选择具有重要位值的 i 个位置的方法的数量 在长度为 L 和 2i 的字符串中，为这些位置赋值的方法数。 对于 1 阶和 2 阶模式可以说明这种理想情况，如下所示：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801212401577.png" alt="image-20210801212401577" style="zoom:67%;" />

这些计数论证自然会导致关于种群规模与遗传算法采样的超平面数量之间关系的问题。
   人们可以非常简单地看待这个问题，并询问有多少阶 1 的模式被采样，以及它们在大小为 N 的总体中的表示情况如何。这些数字基于这样一个假设，即我们对与 初始随机种群，因为选择会随时间改变分布。 在大小为 N 的总体中，每个 2L 阶 1 超平面分区应该有 N/2 个样本。 因此，50% 的人口属于任何特定的 1 阶分区。 每个 2 阶分区由 25% 的总体抽样。 通常，每个 i 阶超平面由总体的 (1=2)i 采样。

##### 5.1 The N3 Argumentry Alphabets

这些计数论证为当种群规模为 N 时遗传算法按 N3 个超平面的顺序进行处理的主张奠定了基础。这里使用的推导基于 Fitzpatrick 和 Grefenstette (1988) 的附录中的工作。
  让 是在大小为 N 的群体中至少由副本表示的超平面的最高阶； 由 log(N= ) 给出。 在声称我们正在对该超平面进行统计采样之前，我们希望至少有一个超平面的样本。
  回想一下，有序的不同超平面分区的数量由 2 L 给出，这只是选择不同位置并将所有可能的二进制值分配给每个子集的不同方法的数量 职位。 因此，我们现在需要展示 

![image-20210801223503555](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223503555.png)

因为 = log(N= ) 和 N = 2 。  Fitzpatrick 和 Grefenstette 现在提出以下论点。 假设L 64 和26 N 220。Pick = 8，这意味着3 17：通过检查，处理的模式数大于N3。
   对于任何大小为 N 的群体，这个论点通常不成立。给定长度为 L 的字符串，空间中的超平面数是有限的。 然而，人口规模可以任意选择。 与长度为 L 的字符串相关联的模式总数为 3L。 因此，如果我们选择 N = 3L 的人口规模，那么最多可以处理 N 个超平面（Michael Vose，个人通信）。 因此，必须相对于 L 选择 N 以使 N3 参数合理。 同时，值范围 26 N 220 确实代表了广泛的实际人口规模。
   尽管如此，N3 超平面被有效处理的论点假设所有这些超平面都以某种程度的独立性进行处理。 请注意，当前的推导只计算那些完全符合 - 的模式。 应该在随机初始总体中很好地表示的从 order-1 到 order- 的所有模式的总和由下式给出：P x=1 2x L x 。 通过只计算完全有序的模式——我们可能希望避免关于与低级模式交互的争论。 然而，所有 N3 论证真正表明的是，在给定适当的人口规模的情况下，可能有多达 N3 个超平面可以很好地表示。 但是可用于处理的模式数量的简单静态计数未能考虑遗传算法的动态行为。
   正如本教程后面所讨论的，遗传算法的动态模型现在已经存在（Vose 和 Liepins，1991；Whitley、Das 和 Crabb，1992）。 然而，还没有任何真正的尝试使用这些模型来研究大量超平面竞争之间的复杂相互作用。 显然，在某种空洞的意义上，了解初始种群的分布以及这些字符串（以及随后由遗传算法生成的字符串）的度数对于建模遗传算法的动态行为是足够的信息 (Vose 1993)。 这表明我们只需要有关遗传算法采样的那些字符串的信息。 然而，遗传算法的这种微观层面的观点似乎并不能解释其宏观层面的处理能力。

##### 5.2 The Case for Nonbinary Alphabets

有两个反对使用高基数字母表的基本论据。 首先，显式的超平面分区会更少。 其次，与较高基数字母表相关联的字母字符（和相应的超平面分区）在有限种群中不会得到很好的表示。 这要么迫使使用更大的人口规模，要么降低了统计抽样的有效性。
   使用二元字母表的论据假设表示超平面的模式必须通过重组显式和直接操作。  Antonisse (1989) 认为情况并非如此，高阶字母表在超平面样本方面与低阶字母表一样丰富。 例如，使用由 A、B、C、D 四个字符组成的字母表，可以通过定义 (A 和 B)、(C 和 D) 等分区来定义二进制字母表中所有相同的超平面分区。 一般来说，Antonisse 认为人们可以将模式的幂集的所有子集视为也定义超平面。
   以这种方式来看，更高基数的字母表比二进制字母表产生更多的超平面分区 21。 然而，Antonisse 的论点未能表明，对应于该方案中定义的子集的超平面实际上提供了新的独立信息源，可以通过遗传算法以有意义的方式进行处理。
   这并没有反驳 Antonisse 的说法，但确实表明存在与该假设相关的未解决问题。
   非二进制编码还有其他参数。  Davis (1991) 认为非二进制编码的缺点可以通过可应用于问题的更大范围的运算符来设置，并且可以利用编码的更多问题相关方面。  Scher and Eshelman (1992) 以及 Wright (1991) 为实值编码提出了有趣的论点。  Goldberg (1991) 建议促进超平面采样的虚拟最小字母表可以从更高基数的字母表中出现。

#### 6 Criticisms of the Schema Theorem

图式定理有一些明显的局限性，限制了它的实用性。
   首先，这是一种不平等。 通过忽略字符串增益和低估字符串损失，会丢失大量信息。 不等式的不精确性使得如果人们试图使用模式定理来预测特定超平面在多代中的表示，结果预测在许多情况下将是无用的或具有误导性（例如 Grefenstette 1993；Vose，个人通信 , 1993)。 其次，随着总体将其新样本集中在更专业的超空间子分区中，在时间 t 观察到的超平面 H 的 tness 会发生显着变化。 因此，查看特定超平面中所有字符串的平均 tness（或使用随机样本来估计该 tness）仅与第一代或第二代相关（Grefenstette 和 Baker，1989）。
   在此之后，字符串的采样是有偏差的，模式定理的不准确使得无法预测计算行为。
   一般而言，模式定理提供了一个下界，该下界仅适用于未来一代。 因此，如果不考虑遗传算法正在处理的其他超平面同时发生的情况，就无法预测多代超平面 H 的表示。
   这些批评意味着本教程第 3 节中提出的超平面采样的观点可能是解释超平面采样的很好的修辞工具，但它们未能捕捉到遗传算法的全部复杂性。 这部分是因为第 3 节中的讨论侧重于选择的影响，而没有考虑交叉的破坏性和生成性影响。 图式定理没有提供遗传算法行为的准确图片，也无法预测特定超平面是如何随时间处理的。 在下一节中，将介绍模式定理的精确版本。

#### 7 An Executable Model of the Genetic Algorithm

在删除增益项和简化损失计算之前考虑模式定理的完整版本

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223643653.png" alt="image-20210801223643653" style="zoom:67%;" />

在当前的公式中，Z 将指代一个字符串。 假设我们将此等式应用于搜索空间中的每个字符串。 结果是遗传算法的计算行为的精确模型。 由于建模字符串对最高阶模式进行建模，因此该模型隐含地包括所有低阶模式。 此外，在使用 tness 比例再现的规范遗传算法中，字符串的 tness 是常数，人们不必担心观察到的由当前种群表示的超平面的 tness 的变化。 给定 Z 的规格，人们可以准确地计算损失和收益。 当一根弦与另一根弦交叉并且由此产生的 o 弹簧无法保留原始弦时，就会发生损失。 当两个不同的字符串交叉并独立创建某个字符串的新副本时，就会产生增益。 例如，如果 Z = 000，那么重新组合 100 和 001 将始终产生 000 的新副本。假设使用 1 点交叉作为运算符，则计算字符串 Z = 000 的 \losses" 和 \gains" 概率 如下：

![image-20210801223747482](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223747482.png)

在前面的等式中使用 PI0 表示在相应字符串或字符串对上的任何位置交叉的概率。 由于 Z 是一个字符串，因此 PI0 = 1.0 和相关情况下的交叉将始终产生损失或收益（取决于该术语出现的表达式）。 一个点交叉落在第一个和第二个比特之间的概率将用 PI1 表示。 在这种情况下，交叉点必须恰好落在相对于相应字符串的这个位置才能导致损失或收益。 同样，PI2 将表示一点交叉落在第二位和第三位之间的概率，并且在计算中使用 PI2 意味着对于特定的字符串或字符串对，交叉必须落在这个位置才能影响损失的计算 或收益。 在上图中，PI1 = PI2 = 0:5。
   方程可以推广到覆盖空间中剩余的 7 个字符串。 这种转换是使用按位加法模 2 完成的（即按位异或表示为 。参见图 4 和第 6.4 节）。 函数 (Si Z) 应用于包含在本节中给出的等式中的每个位串 Si，以生成适当的对应串，以生成用于计算 P(Z,t+1) 形式的所有项的表达式。

##### 7.1 A Generalized Form Based on Equation Generators

3 位方程类似于 Goldberg (1987) 开发的 2 位方程。 这些方程的一般形式的发展通过以系统方式生成损失和增益项来说明（Whitley，Das 和 Crabb，1992）。 由于方程中的项数大于搜索空间中的字符串数，因此开发用于大约 15 位编码的方程是可行的。 方程只需为空间中的一个字符串定义一次； 方程的标准形式总是为由全零位组成的字符串定义的。 令 S 表示长度为 L 的二进制字符串集，由 i 索引。 通常，由所有零位组成的字符串表示为 S0。

##### 7.2 Generating String Losses for 1-point crossovers

考虑两个字符串 00000000000 和 00010000100。使用 1 点交叉，如果交叉发生在第一个 \1" 位之前或最后一个 \1" 位之后，则不会发生中断。 然而，1 位之间的任何交叉都会产生中断：双亲都不会在交叉中幸存下来。
   另请注意，将 00000000000 与任何形式为 0001####100 的字符串重新组合将产生相同的中断模式。 我们将这个字符串称为生成器：它就像一个模式，但使用 # 代替 * 以更好地区分生成器和相应的超平面。  Bridges 和 Goldberg (1987) 将生成器的概念形式化如下。 考虑字符串 B 和 B0，其中第一个 x 位相等，中间 (+1) 位具有 b##:::#b 的模式 B 和 b ##:::# b 的模式 B0。 鉴于字符串的长度为 L，最后的 (L x 1) 位是等效的。  b 位被称为 \sentry 位”，它们用于定义中断的概率。在标准形式中，B = S0 并且哨兵位必须为 1。以下有向无环图说明了 \string 的所有生成器 损失”用于 S0 的 5 位方程的标准形式。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223840800.png" alt="image-20210801223840800" style="zoom:67%;" />

图结构允许将所有生成器的字符串损失集可视化。 一般来说，这个图的根由一个字符串定义，在第一个和最后一个位位置有一个哨兵位，在所有其他中间位置有一个生成器标记 \#"。在图中向下和向左移动会导致 最左边的哨兵位向右移动；向下和向右移动会导致最右边的哨兵位向左移动。哨兵位置之外的所有位都是 \0" 位。 对图表进行总结，可以看出，作为串损耗的潜在来源，产生的 PLƀ1 j=1 j 2Lƀj1 或 (2L L 1) 串

对于由上述图形结构中的 \middle" 生成器之一产生的每个字符串 Si，将以下形式的项添加到损失方程中：

![image-20210801223934362](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223934362.png)

其中 (Si) 是一个函数，用于计算字符串 Si 中哨兵位之间的交叉点数。

##### 7.3 Generating String Gains for 1-point crossover

Bridges 和 Goldberg (1987) 指出，弦 B 的弦增益由两个弦 Q 和 R 产生，这两个弦与 B 具有以下关系。





































































































































































































































































































































































































