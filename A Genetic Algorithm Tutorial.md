## 

## A Genetic Algorithm Tutorial

本教程涵盖了规范遗传算法以及更多实验形式的遗传算法，包括并行岛模型和并行细胞遗传算法。 本教程还说明了通过超平面采样进行遗传搜索。 回顾了遗传算法的理论基础，包括模式定理以及最近开发的规范遗传算法的精确模型

#### 1 Introduction

遗传算法是一系列受进化启发的计算模型。 这些算法在简单的类似染色体的数据结构上对特定问题的潜在解决方案进行编码，并将重组算子应用于这些结构以保留关键信息。 遗传算法通常被视为函数优化器，尽管遗传算法所应用的问题范围相当广泛。

遗传算法的实现始于一群（通常是随机的）染色体。 然后评估这些结构并以这样一种方式分配繁殖机会，即那些代表目标问题的更好解决方案的染色体比那些较差解决方案的染色体有更多的机会“繁殖”。

解决方案的“优”通常是根据当前种群定义的。这种对遗传算法的特殊描述是有意抽象的，因为在某种意义上，遗传算法这个术语有两个含义。 在严格的解释中，遗传算法是指由 John Holland (1975) 和 Holland 的学生 (e.g., DeJong, 1975) 引入和研究的模型。 大多数现有的遗传算法理论仍然是这样，要么单独或主要适用于 Holland 引入的模型，以及本文中将被称为规范遗传算法的变体。 建模遗传算法的最新理论进展也主要适用于规范遗传算法（Vose，1993）。

在该术语的更广泛用法中，遗传算法是任何基于群体的模型，它使用选择和重组算子在搜索空间中生成新的样本点。研究人员从实验的角度引入了许多遗传算法模型。 这些研究人员中有许多是面向应用的，并且通常对作为优化工具的遗传算法感兴趣。

本教程的目标是以这样一种方式介绍遗传算法，使刚接触该领域的学生可以在学习本教程时掌握遗传算法背后的基本概念。 它应该允许更老练的读者相对容易地吸收这些材料。 本教程还涵盖了一些主题，例如反演，这些主题有时会被该领域的新研究人员误解和误用。

本教程首先对优化进行了非常初级的讨论，以介绍优化的基本思想以及与遗传算法相关的基本概念。 在第 2 节中，回顾了典型的遗传算法。 第 3 节探讨了超平面采样的原理，并介绍了一些基本的交叉算子。 在第 4 节中，模式定理的各种版本逐步发展，并讨论了其他交叉算子。 在第 5 节中考虑了二进制字母及其对超平面采样的影响。 在第 6 节中考虑了对模式定理的简要批评，并在第 7 节中开发了遗传算法的精确模型。 本教程的最后三个部分涵盖了遗传算法和进化计算模型的替代形式，包括专门的并行实现

##### 1.1 Encodings and Optimization Problems

大多数遗传算法中通常只有两个与问题相关的主要元素：问题编码和评估函数。

考虑一个参数优化问题，我们必须优化一组变量以最大化某些目标（例如利润的大小），或者最小化成本或某种误差。 我们可能会将此类问题视为一个黑匣子，其中包含一系列代表不同参数的控制旋钮； 黑盒的唯一输出是评估函数返回的值，该值指示特定参数设置组合解决优化问题的效果。 目标是设置各种参数以优化某些输出。 用更传统的术语来说，我们希望最小化（或最大化）某个函数 $F(X_1,X_2,..., X_M)$。

遗传算法的大多数用户通常关注非线性问题。这通常也意味着不可能将每个参数视为可以独立于其他变量求解的独立变量。 为了最大化或最小化黑盒的输出，必须考虑参数的组合效应。 在遗传算法中，变量之间的相互作用有时被称为上位性。

通常做出的第一个假设是表示参数的变量可以由位串**(bit strings)**表示。 这意味着变量以先验方式离散化，并且离散化的范围对应于 2 的某个幂。例如，对于每个具有10 比特位的参数，我们将会获得具有 1024 个离散值的区间。 如果参数实际上是连续的，那么这种离散化就不是一个特别的问题。 当然，这假设离散化提供了足够的分辨率，以便能够以所需的精度水平调整输出。 它还假设离散化在某种意义上代表了底层函数

如果某些参数只能采用一组精确的有限值，那么编码问题就变得更加困难。 例如，如果恰好有 1200 个离散值可以分配给某个变量 $X_i$，该怎么办？ 我们至少需要 11 位来覆盖这个范围，但是这个代码总共有 2048 个离散值。  848 个不必要的位可能会导致没有评估、默认的最坏评估，或者某些参数设置可能会被表示两次，以便所有二进制字符串都产生一组合法的参数值。 解决此类编码问题通常被认为是评估函数设计的一部分。

除了编码问题，评估函数通常作为问题描述的一部分给出。 另一方面，开发评估函数有时可能涉及开发模拟。 在其他情况下，评估可能基于绩效并且可能仅代表近似或部分评估。 例如，考虑一个控制应用程序，其中系统可以处于指数级的大量可能状态中的任何一种。 假设使用遗传算法来优化某种形式的控制策略。 在这种情况下，必须以有限的方式对状态空间进行采样，并且由此产生的控制策略评估是近似且嘈杂的（参见 Fitzpatrick 和 Grefenstette，1988）。

评估函数也必须相对较快。 对于任何优化方法来说，这通常都是正确的，但它可能对遗传算法尤其造成问题。 由于遗传算法适用于潜在解决方案的群体，因此会产生评估该群体的成本。 此外，种群会在代际基础上（全部或部分）被替换。

种群的成员进行繁殖，然后必须评估它们的后代。 如果做一个评估需要1小时，那么做10000次评估需要1年多。 对于只有 200 个字符串的群体，这将是大约 50 代。

##### 1.2 How Hard is Hard?

假设参数之间的相互作用是非线性的，搜索空间的大小与问题编码中使用的比特数有关。 对于长度为 $L$​ 的位串编码； 搜索空间大小为 $2^L$​，形成一个超立方体。 遗传算法对这个 $L$​ 维超立方体的角进行采样。

通常，大多数测试函数的长度至少为 30 位，大多数研究人员可能会同意需要更大的测试函数。 任何小得多的东西都代表一个可以枚举的空间。  （考虑一下 1993 年美国的国债大约为 $2^{42}$​ 美元，$2^{30}$​ 听起来并没有那么大。）当然，表达式 $2^L$​ 相对于 $L$​ 呈指数增长。考虑编码为 400 位的问题。 关联的搜索空间有多大？ 一本关于人工智能的经典介绍性教科书给出了这种大小空间的一个特征。  Winston (1992:102) 指出，$2^{400}$ 是国际象棋中可能的棋盘配置的搜索空间的有效大小的一个很好的近似值。  （这假设每个可能移动的有效分支因子为 16，并且游戏由 100 个移动组成；$16^{100}$​ = $(2^4)^{100} = 2^{400}$）。温斯顿说这是一个大得离谱的数字。 事实上，如果宇宙中的所有原子自大爆炸（如果有的话）以来一直以皮秒的速度计算国际象棋走法，那么分析才刚刚开始。”

关键是，只要问题的“好的解决方案”的数量相对于搜索空间的大小来说是稀疏的，那么随机搜索或通过枚举大的搜索空间进行搜索就不是解决问题的实用形式 .另一方面，除了随机搜索之外的任何搜索都会在如何寻找更好的解决方案以及它在搜索空间中的位置方面施加一些偏差。遗传算法确实在空间中的哪些新点方面引入了特定的偏差 然而，遗传算法属于人工智能社区中被称为“弱方法”的一类方法，因为它对正在解决的问题做出的假设相对较少。

当然，在数学和运筹学中已经开发了许多优化方法。 遗传算法作为优化工具扮演什么角色？ 遗传算法通常被描述为一种不使用梯度信息的全局搜索方法。 因此，不可微函数以及具有多个局部最优值的函数代表可能应用遗传算法的问题类别。

遗传算法作为一种弱方法，鲁棒但非常通用。 如果针对特定问题存在良好的专门优化方法，那么遗传算法可能不是该应用程序的最佳优化工具。 另一方面，一些研究人员使用混合算法，将现有方法与遗传算法相结合。

#### 2 The Canonical Genetic Algorithm

实现任何遗传算法的第一步是生成初始种群。在规范遗传算法中，这个群体的每个成员都是一个长度为 $L$​ 的二进制字符串，对应于问题编码。 每个字符串有时被称为 "genotype" (Holland, 1975) 或 "chromosome" (Schaer, 1987)。 在大多数情况下，初始种群是随机生成的。 创建初始种群后，然后评估每个字符串并分配一个适应度值。

评估和适应度的概念有时可以互换使用。 但是，区分评估函数和遗传算法使用的适应度函数是有用的。 在本教程中，评估函数或目标函数提供了关于一组特定参数的性能度量。适应度函数将这种绩效衡量转化为生殖机会的分配。表示一组参数的字符串的评估独立于任何其他字符串的评估。 然而，该字符串的适应度总是相对于当前种群的其他成员来定义的。

在规范遗传算法中，适应度定义为： $f_i/ f$ 其中 $f_i$ 是与字符串 $i$ 关联的评估，$f$ 是总体中所有字符串的平均评估。也可以根据字符串在总体中的排名（Baker，1985；Whitley，1989）或通过抽样方法，例如锦标赛选择（Goldberg，1990）来分配适应度。

将遗传算法的执行视为两阶段过程是有帮助的。 它从当前的种群开始。**选择**应用于当前种群以创建中间种群。 然后将**重组和突变**应用于中间种群以创建下一个种群。 从当前种群到下一个种群的过程构成了遗传算法执行中的一代。Goldberg (1989) 将此基本实现称为简单遗传算法 (SGA)。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728125203677.png" alt="image-20210728125203677" style="zoom: 80%;" />

我们将首先考虑从当前种群构建中间种群。 在第一代中，当前种群也是初始种群。 对当前种群中的所有字符串计算 $f_i/\bar{f}$ 后，进行选择。 在规范遗传算法中，当前种群中的字符串被复制（即重复）并放置在中间代中，其概率与其适应度成正比。

有多种方法可以进行选择。 我们可以将总体映射到轮盘赌轮上，其中每个人都由一个与其适应度成比例对应的空间表示。 通过反复旋转轮盘赌轮，使用“有替换的随机抽样”来选择个体以填充中间群体。

更接近于预期适应度值的选择过程是 “remainder” 随机抽样。”对于 $f_i/\bar{f}$​ 大于 $1.0$​ 的每个字符串 $i$​，该数字的整数部分表示该字符串的多少副本被直接放入中间群体。所有字符串（包括那些 $f_i/ \bar{f}$​ 小于 $1.0$​ 的字符串）然后在中间群体中放置额外的副本，其概率对应于 $f_i/\bar{ f}$​ 的小数部分。例如，具有 $f_i/\bar{f}=1.36$​ 的String在中间种群中放置 1 个副本，然后获得 $0.36$​ 放置第二个副本的机会。具有 $f_i/\bar{ f} = 0.54$​ 适应度 的字符串有 0.54 在中间种群中放置一个字符串的机会 

''剩余随机抽样”是使用称为随机通用抽样的方法最有效地实现的。假设人口以随机顺序排列，如饼图，其中每个人在饼图上被分配与适应度成比例的空间 . 接下来，在饼周围放置一个带有 N 个等距指针的外轮盘。轮盘的单次旋转现在将同时选择中间种群的所有 N 个成员。结果选择也是无偏的（Baker，1987）。

选择完成后，中间群体的构建完成，可以进行重组。 这可以看作是从中间种群创建下一个种群。 交叉应用于随机配对的字符串，概率表示为 $p_c$​（随机选择过程应该已经充分地调整了总体）选择一对字符串。 以概率 $p_c$​ 重组这些字符串形成两个新的字符串，插入到下一个群体中。

考虑以下二进制字符串：1101001100101101。该字符串将代表某些参数优化问题的可能解决方案。 空间中的新样本点是通过重新组合两个父字符串生成的。 考虑字符串 1101001100101101 和另一个二进制字符串 yxyyxyxxyyyxyxxy，其中值 0 和 1 由 x 和 y 表示。 使用单个随机选择的重组点，单点杂交发生如下

![image-20210728210228445](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210228445.png)

在两个父对象之间交换片段会产生以下字段

![image-20210728210251303](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210251303.png)

重组后，我们可以应用变异算子。 对于总体中的每一个字段，它们都会以一些低概率 $p_m$ 变异。 通常，突变率的应用概率小于 1%。 在某些情况下，突变被解释为随机生成一个新位（一个随机的1或者0），也就是说，在这种情况下，只有 50% 的突变会实际改变位值。在其他情况下，突变被解释为意味着实际 ping 位。 只要用户/读者意识到差异并理解第一种形式的变异产生位值变化的频率仅为第二种形式的一半，并且变异的一个版本只是另一个的缩放版本。

在选择、重组和突变过程完成后，可以评估下一个种群。 遗传算法在执行过程中，评估、选择、重组和变异的过程形成一代

##### 2.1 Why does it work? Search Spaces as Hypercubes

大多数刚接触遗传算法领域的人此时会问的问题是，为什么这样的过程应该做任何有用的事情。 为什么要相信这会产生一种有效的搜索或优化形式？

最广泛地解释遗传算法的计算行为的答案来自 John Holland 的工作。 在他 1975 年的经典著作《自然和人工系统中的适应》中，Holland 提出了几个论点，旨在解释 “遗传计划”或“遗传算法”如何通过隐式采样搜索空间的超平面分区来实现复杂而稳健的搜索。

也许理解遗传算法如何对超平面分区进行采样的最好方法是考虑一个简单的 3 维空间（见图 2）。 假设我们有一个仅用 3 位编码的问题； 这可以表示为一个简单的立方体，原点是字符串 000。 这个立方体中的角由位串编号，所有相邻的角由位串标记，位串正好相差 1 位。 图 2 顶部给出了一个示例。立方体的前平面包含所有以 0 开头的点。如果"*" 表示"don't care" 或通配符匹配符号，则该平面也可以由特殊字符串0** 表示。 包含 * 的字符串称为模式（**schema**）； 每个模式对应于搜索空间中的一个超平面。 超平面的”阶数“指的是出现在其模式中的实际位值（指的是不可以变动的数）的数量。因此，1** 是 1 阶，而 $1****1**0**$ 是 3 阶 .

![image-20210728210642314](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210642314.png)

如果位串可以通过将适当的位值替换为 "*" 符号从超平面中构造出来（指找到一个“共集”），那么位串与特定架构匹配。通常，与特定架构匹配的所有位串都包含在由该架构表示的超平面分区中。每个二进制编码都是一个“染色体”，它对应于超立方体中的一个角，并且是(指的是所有这些拥有同样编码共性的字段) $2^L-1$  个不同超平面的成员，其中 $L$ 是二进制编码的长度。  （所有 * 符号的字符串对应于空间本身，不计为空间的分区（Holland 1975:72））。 这可以通过取一个位串并查看可以用 "*" 符号替换任何位子集的所有可能方式来显示。换句话说，位串中有 $L$ 个位置，每个位置可以是位 包含在字符串或 \*" 符号中的值。

也相对容易看出，可以在整个搜索空间上定义 $3^L-1$  超平面分区。 对于位串中的每个 $L$ 位置，我们可以使用值 *、1 或 0，从而产生 $3^L$ 种组合。

如果孤立地检查搜索空间中的每个点，则确定每个字符串都是 $2^L- 1$ 超平面分区的成员并不能提供太多信息。 这就是为什么基于群体的搜索的概念对遗传算法至关重要。 一组样本点提供了有关众多超平面的信息； 此外，低阶超平面应该由总体中的许多点进行采样。  （在本文的后续部分中更详细地重新研究了这个问题）遗传算法的内在或隐式并行性的一个关键部分来自这样一个事实，即我们可以在评估一组字符串时对许多超平面进行采样（Holland 1975）； 事实上，可以说采样的超平面数量比总体中包含的字符串数量多得多。 每次评估单个字符串时，都会以隐式并行方式评估不同的超平面（Holland 1975:74）； 但它是评估一组点的累积效应，提供有关任何特定超平面子集的统计信息。隐式并行意味着许多超平面竞争同时并行解决。 该理论表明，通过复制和重组过程，竞争超平面的图式根据位于这些超平面分区中的字符串的相对性来增加或减少它们在总体中的表示。

由于遗传算法对字符串群体进行操作，因此可以通过跟踪代表群体中特定超平面的单个模式的比例表示，来指示当基于适合度的选择与交叉结合时，该超平面所代表的种群中的个体数是否会随着时间的推移增加或减少

(注：Holland 最初在其 1975 年的专著中使用术语内在并行性，然后决定改用隐式并行性以避免与并行计算中的术语混淆。 不幸的是，并行计算社区中的术语隐式并行是指从用没有显式并行构造的函数式语言编写的代码中提取的并行性。 隐式并行并不是指在并行硬件上运行遗传算法的潜力，尽管遗传算法通常被视为高度可并行化的算法)

#### 3 Two Views of Hyperplane Sampling

图 3 显示了另一种查看超平面分区的方法。将单个变量上的函数绘制为一维空间，以函数最大化为目标。

超平面 $0****...**$​ 张得空间的前半部分，而 $1****...**$​ 张出空间的后半部分。 由于 $0****...**$​ 分区中的字符串的适合度好于 $1****...**$​ 分区中的字符串，我们希望搜索按比例偏向该分区。 在第二张图中，与 $**1**...**$​ 对应的空间部分被阴影化，这也突出了 $0****...**$​ 和 $**1**...**$​ 的交集 ，即 $0*1*...**$​。最后，在第三张图中，$0*10**...**$ 突出显示。

图 3 的要点之一是超平面分区的采样并没有真正受到局部最优的影响。 同时，与其他竞争分区相比，提高高于平均水平的分区的采样率并不能保证收敛到全局最优。 例如，全局最优可能是一个相对孤立的峰值。

查看一个运行中的简单遗传算法的示例也是一个有用的练习。在表 1 中，明确给出了每个字符串的前 3 位，而未指定其余位位置。 目标是仅查看在前 3 位位置上定义的那些超平面，以便查看根据 适合度复制字符串时在选择阶段实际发生的情况。 遗传算法背后的理论表明，每个超平面中点的新分布应该根据相应超平面分区中包含的种群中字符串的平均适合度变化。因此，即使遗传算法从未明确评估任何特定的超平面分区，它也应该改变字符串副本的分布，就好像它已经如此规定了一样。

![image-20210731141524844](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731141524844.png)

![image-20210731141533144](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731141533144.png)

![image-20210731142003171](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731142003171.png)

表 1：根据等级将适合度分配给字符串的总体。  Random 是一个随机数，它决定是否为适合度的小数余数授予一个字符串的副本

表 1 中的示例总体仅包含 21 个（部分指定的）字符串。 由于我们并不特别关心这些字符串的精确评估，因此将根据等级分配适合度值。（未详细讨论按等级而不是按比例表示分配适合度的概念，但当前示例涉及由于适合度引起的表示变化，而不是如何分配该适合度。）该表包括有关每个字符串适合度的信息和要放置在中间群体中的副本数。 在此示例中，选择期间生成的副本数通过自动分配整数部分来确定，然后通过生成 0.0 和 1.0 之间的随机值（余数随机采样的一种形式）分配小数部分。 如果随机值大于（1-余数）； 然后将额外的副本授予相应的个人。

当选择作用于群体时，遗传算法似乎并行地隐式处理许多超平面. 表 2 列举了 27 个超平面 ($3^3$)，这些超平面可以定义在群体中字符串的前三位，并明确计算与相应超平面分区相关联的适合度。 超平面分区的真实适合度对应于位于该超平面分区中的所有字符串的平均适合度。

遗传算法使用总体作为样本来估计该超平面划分的适合度。 当然，样本只有在第一代期间是随机的。 在此之后，新字符串的样本应该偏向于先前包含的字符串高于先前种群平均适合度水平的区域。

如果遗传算法如我们所描述的那样工作，则选择后实际落在特定超平面分区中的字符串副本数应近似于应落在该分区中的预期副本数。

![image-20210731143935259](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731143935259.png)

表2：明确计算了在第一个三比特位置上定义的27个超平面的样本的平均适合度（Mean）。显示了预期表示（Expect）和观察表示（Obs）。Count指选择前超平面H中的字符串数。

在表 2 中，可以通过将选择前当前总体中超平面样本的数量乘以落入该分区的总体中字符串的平均适合度来计算选择后对超平面分区进行采样的预期字符串数（在上表中即为 "Mean" $\times$ "Count")，上表还给出了选择后实际得到的可观察副本数。 在大多数情况下，预期采样率和观察到的采样率之间的匹配度相当好：误差是由于总体规模较小而导致的抽样误差

开始将跟踪超平面的潜在采样率 $H$​​ 的想法用数学语言表示是有用的。记 $M(H, t)$​ 是当前代 $t$​ 中某个群体中采样 $H$​ (即超平面 $H$ )中所包含的字符串数量。 记 $(t+intermediate)$​ 为第 $t$ 代在选择后（但在交叉和变异之前）的世代，$f(H,t)$ 是当前种群中分区 $H$ 中字符串样本的平均适应度。 因此根据此前的表述，我们得到这个选择后（但在交叉和变异前的）世代中的个体（字符串）数量为：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731161300393.png" alt="image-20210731161300393" style="zoom: 50%;" />

当然，当字符串仅被复制时，实际上不会发生新的超平面采样，因为没有生成新的样本。 从理论上讲，我们希望有一个具有相同分布的新点样本。 在实践中，这通常是不可能的。然而，重组和变异提供了一种生成新样本点的方法，同时部分地保留了在中间群体中观察到的跨超平面的字符串分布

##### 3.1 Crossover Operators and Schemata

表 2 中观察到的超平面表示对应于选择后但重组前的中间群体中的表示。 重组对观察到的字符串分布有何影响？ 显然，1 阶超平面样本不受重组的影响，因为单个关键位总是由后代之一继承。 然而，观察到的来自 2 阶及更高阶超平面分区的潜在样本分布可能会受到交叉的影响。 此外，相同阶的所有超平面不一定以相同的概率受到影响。 考虑单点杂交。 这个重组算子很好，因为它相对容易量化它对表示超平面的不同模式的影响。 为简单起见，假设我们正在处理一个仅用 12 位编码的字符串。 现在考虑以下两个模式

![image-20210731144526380](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731144526380.png)

第一个模式中的位在单点杂交期间被这两个“基因”（指的是字符串中不变的两个点位）被分离的概率仅为 $1/L- 1$​​，因为通常在长度为 $L$​​ 的字符串中存在 $L- 1$​ 个交叉点；而右边的字符串两个基因被分离的概率则为 $(L-1)(这是两个点位之间的间隔数)/(L-1)(字符串中的总间隔数)=1.0$​ ，因此我们观察到：当使用单点杂交时，模式中基因的位置对于确定这些基因在交叉期间保持在一起的可能性很重要

###### 3.1.1  2-point Crossover

如果使用两点杂交算子会发生什么？ 两点杂交算子使用两个随机选择的交叉点，字符串会交换落在这两个点之间的段。  Ken DeJong 首先观察到 (1975)两点杂交将字符串和模式视为形成一个环，这可以说明如下：

![image-20210731144658012](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731144658012.png)

其中 $b1$​​​​ 到 $b12$​​​ 表示第 $1$​​​ 到 $12$​​ 位。从这种角度来看，单点杂交是两点杂交的一种特殊情况，即对于单点杂交而言，其中一个交叉点总是出现在第一个和最后一个比特之间的环绕位置。 现在，当 2 位位于此环上的互补位置时，会发生 2 阶模式的最大中断。

对于单点和两点杂交，很明显，在字符串编码（或环）上具有靠近在一起的位的模式不太可能被交叉破坏。更准确地说，由具有更紧凑表示的模式表示的超平面应该以更接近于单独选择实现的那些潜在采样分布目标的速率进行采样。 对于当前的目的，关于模式的紧凑表示是最小化交叉期间中断概率的表示。 请注意，此定义依赖于算子，因为在 3.1 节中检查的两个 2 阶模式在两点杂交方面具有同等且最大程度的紧凑性，但在单点杂交方面存在最大差异。

###### 3.1.2 Linkage and Defining Length

连锁是指一组位作为\coadapted 等位基因"的现象，它们倾向于作为一个集合一起遗传。在这种情况下，等位基因将对应于染色体上特定位置的特定位值。当然， 连锁现象可以看作是关于模式的紧凑表示概念的概括。连锁有时由字符串编码中位的物理相邻性定义；这隐含地假设单点杂交是正在使用的运算符。连锁在两点杂交下是不同的，当被视为一个环时，必须根据染色体上的距离来定义。然而，连锁通常等同于字符串上的物理邻接，通过我们定义的所谓定义长度来衡量。

模式的定义长度基于模式中第一个和最后一个位之间的距离，值为 0 或 1（即，不是 * 符号）。 鉴于模式中的每个位置都可以是 0、1 或 $*$​，我们采用下面的方法来解决这个问题：我们从右至左检查字符串中的值，第一个（换言之，是最右侧的）不是 $*$​ (即，该位的值不是 1 即为 0 ）的位被定义为 $I_x$​ ,而最左侧的符合此标准的位被定义为 $I_y$​ ，定义长度定义为 $I_x-I_y$​ （注意：位数的计算是从左至右递增的，因此这里是为了保证定义长度非负）。因此，$****1**0**10**$​ 的定义长度为 $12- 5 = 7$​​。此处表示超平面 $H$​ 上的模式的定义长度由 $\Delta (H)$ 表示。 定义长度是对有多少可能的交叉点落在图式的重要部分内的直接度量。 如果使用单点杂交，则 $\Delta(H)/L -1$ 也是交叉在交叉期间落入图式的重要部分的可能性的直接度量。

###### 3.1.3 Linkage and Inversion

与变异和交叉一起，倒位通常被认为是基本的遗传算子。倒位可以改变染色体上位之间的等位关系，使得具有更大非线性相互作用的位可能在染色体上更靠近地移动。通常，倒位是通过倒位染色体的随机片段来实现的，但是，在开始移动染色体上的位以改善等位基因之前，这些位必须具有与位置无关的解码。 一些研究人员在第一次实施倒位时犯的一个常见错误是直接倒位编码染色体的位段。 但是，如果从位到参数的映射是位置相关的，那么仅仅倒位一些随机的位段只不过是大规模的变异。

位置无关编码要求以某种方式标记每个位。 例如，考虑以下由对组成的编码，其中第一个数字是一个位标记，它为位索引，第二个数字表示位值。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801151526484.png" alt="image-20210801151526484" style="zoom:67%;" />

现在可以通过在标签位对周围移动来改变链接，但解码时字符串保持不变：010010110。现在还必须考虑如何实现重组。  Goldberg 和 Bridges (1990)、Whitley (1991) 以及 Holland (1975) 讨论了利用链接和标记表示重组的问题

#### 4 The Schema Theorem（图式定理）

现在已经为发展遗传算法的基本定理奠定了基础。模式定理 (Holland, 1975) 为单个超平面从第 $t$​ 代到第 $t + 1$ 代的采样率变化提供了下限。

再次考虑当只发生选择时特定超平面 $H$ 会发生什么

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801151822055.png" alt="image-20210801151822055" style="zoom: 67%;" />

为了计算 $M(H,t+1)$，我们必须考虑交叉的影响，因为下一代是从中间代创建的。 首先，我们考虑将交叉概率应用于一部分总体。 对于没有进行交叉的那部分种群，由于选择而产生的表示不变。 当交叉确实发生时，我们必须计算由于其破坏性影响造成的损失。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801153458175.png" alt="image-20210801153458175" style="zoom: 67%;" />

在推导模式定理时，在这一点上做出了一个保守的假设：假设在模式定义长度内的交叉总是会破坏表示 $H$​​ 的模式。事实上，这不是真的，交叉影响的精确计算将在本文后面介绍。 例如，假设我们对模式 $11*****$​​ 感兴趣。 如果将诸如 1110101 之类的字符串与诸如 1000000 或 0100000 之类的字符串在前两位处进行交叉互换，则超平面 $11*****$​​ 中不会发生中断，因为其中会有一个后代仍将驻留在该分区中。 此外，如果 1000000 和 0100000 恰好在第一个和第二个位之间发生交叉互换，则新的独立后代将同样拥有 $11*****$​ 的形式​； 这就是上述计算中提到的收益来源。 为简化起见，忽略了收益，并做出了保守假设，即落在模式重要部分的交叉总是会导致中断。 因此，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801154243843.png" alt="image-20210801154243843" style="zoom: 67%;" />

中断高估了损失。 我们可能希望考虑一种例外情况：如果两个包含在样本 $H$​​ 内的两个字符串之间发生交叉互换，则不会发生中断。 令 $P(H, t)$​ 表示在 $H$ 在总体中的占比大小，其值通过将 $M(H,t)$ 除以种群大小来得到。换言之，随机选择情况下，样本 $H$ 内部出现配对的概率为 $P(H,t)$。 回想一下，$\Delta(H)$ 是与单点杂交相关的定义长度。 因此，中断的数目由下式给出：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801154557633.png" alt="image-20210801154557633" style="zoom:67%;" />

此时，可以简化不等式。 两边都可以除以种群大小，将其转换为 $P(H, t + 1)$​ 的表达式，即 $H$​ 在 $t +1$​ 代的比例表示： 此外，该表达式可以相对于 $p_c$ 重新排列。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801155217128.png" alt="image-20210801155217128" style="zoom:67%;" />

我们现在有了模式定理的一个有用版本（尽管它还没有考虑变异）； 但这并不是文献中的唯一版本。 例如，父本和母本其中一方（或双方）通常都具有一定的适合度要求，这可以通过从中间群体中选择替代亲本来添加到模式定理中：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801155416175.png" alt="image-20210801155416175" style="zoom:67%;" />

最后，我们将突变包括其中。 令 $o(H)$ 是一个返回超平面 $H$ 阶数的函数。$H$ 的阶数恰好对应于表示 $H$ 的模式中具有值 $0$ 或 $1$ 的位数的计数。设变异概率为 $p_m$​，其中突变总是将突变位点的基因进行倒位。 因此，突变影响表示 $H$ 的模式的概率是 $(1-p_m)^{o(H)}$，因此修正表达式如下：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801155832820.png" alt="image-20210801155832820" style="zoom:67%;" />

##### 4.1 Crossover, Mutation and Premature Convergence

显然，模式定理最强调交叉和超平面采样在遗传搜索中的作用。 为了最大限度地保留选择后的超平面样本，应该最大限度地减少交叉和突变的破坏性影响。 这表明可能根本不应该使用突变，或者至少应该以非常低的水平使用。因此，使用突变的动机是为了防止任何特定位或等位基因的永久丢失。 几代之后，选择可能会将某个位置的所有位变为单个值：0 或 1。如果发生这种情况，遗传算法没有收敛到令人满意的解决方案，则算法过早收敛。

如果种群大小过小，这可能尤其成问题。 如果没有变异算子，就不可能重新引入丢失的位值。 此外，如果目标函数是非平稳的，并且适应度函数随时间变化（在真实的生物系统中肯定是这种情况），那么需要有一些持续遗传多样性的来源。 因此，突变充当背景算子，偶尔会改变位值并允许重新测试替代等位基因（和超平面分区）。

这种对突变的特殊解释忽略了它作为爬山机制的潜力：从模式定理突变强加的严格超平面采样的角度来看，它是一种必要之恶。 但这也许是一种有限的观点，有几位实验研究人员指出，使用突变和无交叉的遗传搜索通常会产生相当稳健的搜索，并且几乎没有理论可以解决超平面采样和爬山在遗传搜索中的相互作用。

另一个与过早收敛相关的问题是需要缩放总体适合度。 随着总体中字符串的平均适合度增加，总体中适合度的方差减小。 几代后，种群中最好和最差的个体可能差别不大，基于适合度的选择压力也相应降低。 这个问题可以通过使用某种形式的适合度标度来部分解决（Grefenstette，1986；Goldberg，1989）。 在最简单的情况下，可以从总体中所有字符串的适合度中减去总体中最差字符串的是和渎职。 现在可以使用这种调整后的评估来计算平均字符串评估以及适合度 值，这将增加产生的选择压力。 或者，可以使用基于rank的选择形式。

##### 4.2 How Recombination Moves Through a Hypercube

单点杂交的好处在于它易于分析建模。 但也很容易通过分析表明，如果人们对最小化模式中断感兴趣，那么两点杂交会更好。 但是应该避免使用许多交叉点的算子，因为它会严重破坏模式。 这又是对模式定理的严格解释所强加的观点。 另一方面，中断可能不是影响遗传算法性能的唯一因素。

###### 4.2.1 Uniform Crossover

近年来最受关注的算子是均匀交叉。Ackley (1987) 详细研究了均匀交叉，Syswerda (1989) 将其推广。 均匀交叉的工作原理如下：在从 $1$​​​ 到 $L$​​​ 的每个位置上，从亲本字符串中分别随机选取一个位。 随机选择的基因意味着这两个基因之间的关系在遗传上是独立的，换言之，不是连锁的；这也意味着均匀交叉在定义长度方面是无偏的。 一般而言，中断的概率为 $1-(1/2)^{o(H)-1}$​，其中 $o(H)$ 是我们感兴趣的模式的阶数（哪个后代继承第一个关键位并不重要，但所有其他位都必须由同一个后代继承。这也是最坏情况下的中断概率，假设在感兴趣的模式中没有发现等位基因被共享 ) 因此，对于任何 3 阶模式，将关键位分开的均匀交叉概率总是 $1 - (1/2)^2 = 0.75$。 考虑一个 9 位的字符串。 模式的定义长度必须等于 6，可以发现，单点杂交的破坏概率与均匀交叉相关的概率匹配 $(6/8 = .75)$。 我们可以在任何特定的 9 位字符串（即在 9 位中随机选择 3 位特定位）上定义 84 个不同的 3 阶模式。 在这些模式中，84 个二阶模式中只有 19 个在单点杂交下的中断率高于 0.75。 另外 15 个具有完全相同的中断率，84 个 2 阶模式中的 50 个具有较低的中断率。 相对容易证明，虽然均匀交叉在定义长度方面是无偏的，但它通常也比单点杂交更具破坏性。  Spears 和 DeJong (1991) 已经表明，对于所有定义长度的 3 阶模式，均匀交叉在任何情况下都比两点杂交更具破坏性。

![image-20210801160909426](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801160909426.png)

尽管有这些分析结果，但一些研究人员认为均匀交叉有时是更好的重组算子。 可以指出它在模式破坏方面缺乏代表性偏见作为一种可能的解释，但这不太可能，因为均匀交叉比两点杂交更差。  Spears 和 DeJong (1991:314) 推测：“对于种群含量很小的样本而言，均匀交叉或 $n$ 点交叉 ($n\ge 2$）可能会有更好的效果，这在于它们所对种群本身基因构成更具有破坏性，因此有助于克服个体数量过少而导致的信息量携带限制和遗传同质性趋势 ” Eshelman (1991) 提出了类似的论点，概述了破坏性交叉算子的优势。

还有另一种意义上的均匀交叉是无偏的。 假设我们希望重新组合位串 0000 和 1111。我们可以方便地布置 4 维超立方体，如图 4 所示。我们也可以将这些串视为通过一组通过超立方体的最小路径连接； 选择一个父字符串作为起点，另一个作为目的地。 现在更改与原点相对应的二进制表示中的单个位。 任何这样的移动都会到达离目的地更近一步的点。在图 4 中，很容易看出更改单个位是图形中的向上或向下移动。

0000 和 1111 之间的所有点都可以通过某种均匀交叉的单一使用得到。 然而，单点杂交仅生成沿着通过这个 4 维超立方体的两条互补路径（图中最左边和最右边的路径）的字符串。通常而言，使用均匀交叉会等概率的画出位于两个亲本（位于超立方体上）之间的所有互补（指互相可以到达对侧的路径）路线上的所有互补对，而单点杂交仅会从两个特定的互补最小路径之间的（两者是子集关系）两个特定互补最小路径中抽取样本点。也很容易看出两点杂交比单点杂交限制更少。 注意，两个串之间不同的比特数就是汉明距离 $\mathcal{H}$​。不包括原始父串，均匀交叉可以产生 $2^{\mathcal{H}}- 2$​​ 个不同的串，而单点杂交可以产生 $2(\mathcal{H} -  1)$​ 个不同的字符串，因为有会有 $\mathcal{H}$​ 个交叉点可以产生不同的后代（见下一节的讨论），每个交叉点产生 2 个后代。 两点杂交算子可以生成 $2\begin{pmatrix}\mathcal{H}\\2\end{pmatrix} = \mathcal{H}^ 2 -H$ 不同的后代，因为有 H 选择 2 个不同的交叉点，这将导致后代不是父母的副本，并且每对 交叉点生成 2 个字符串。

##### 4.3 Reduced Surrogates

考虑将以下两个字符串和相同字符串的删减版本交叉，其中字符串共享的位已被删除

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801212254804.png" alt="image-20210801212254804" style="zoom:67%;" />

两个字符串都位于超平面 $0001**101*01001*$ 中。 此观察的 ip 方面是交叉实际上仅限于在不同位位置上定义的子立方体。 我们可以通过删除两个父结构中所有等效的位来隔离这个子多维数据集。  Booker (1987) 将 ----11---1-----1 和 ----00---0-----0 等字符串称为原始父代的\reduced surrogates 染色体。

以这种方式查看时，很明显这些特定字符串的重组发生在 4 维子立方体中，或多或少与前一个示例中检查的相同。均匀交叉相对于该子立方体是无偏的，因为均匀交叉仍将以无偏、均匀的方式从位于两个原始父字符串之间定义的子立方体中的互补最小路径上的所有点对中采样。 另一方面，简单的单点或两点杂交不会。 为了帮助说明这个想法，我们重新组合了原始字符串，但检查了 \reduced" 形式的后代。例如，简单的单点杂交生成后代 $----11---1-----  0$​ 和 $----00---0-----1$​ 的概率为 6/15，因为在缩减子多维数据集中的第三和第四位之间的原始父字符串中有 6 个交叉点，L-1 =  15. 另一方面，----10---0-----0 和----01---1-----1 被采样的概率只有 1/15，因为那里 只是原始父结构中位于定义子立方体的第一个和第二个位之间的单个交叉点。
   然而，人们可以消除这种特殊的偏见。 我们在减少的代理上应用交叉。
   交叉现在可以利用这样一个事实，即以简化代理形式出现的任何显着位之间实际上只有 1 个交叉点。 还有另一个好处。
   如果在减少的代理中的第一个和最后一个显着位之间至少有 1 个交叉点，则保证后代 不是父代的重复。  （这假设父母至少相差两位）。 因此，产生了超空间中的新样本点。

关于统一交叉和算子（例如 2 点减少代理交叉）的优点的辩论并不是一个封闭的问题。 为了充分理解超平面采样、种群大小、早熟收敛、交叉算子、遗传多样性和变异爬山的作用之间的相互作用，需要更好的分析方法。

#### 5 The Case for Binary Alphabets

使用最小二进制字母表背后的动机是基于相对简单的计数参数。 最小字母表最大化了编码模式处理中直接可用的超平面分区的数量。 这些低阶超平面分区的采样率也高于基数较高的字母表的采样率。

任何 1 阶模式集（例如 $1***$ 和 $0***$）都会将搜索空间减少一半，显然，有在超平面上只会存在 $L$ 对 1 阶模式。 对于 2 阶模式，有 $\begin{pmatrix}L\\2\end{pmatrix}$ 种方法来选择放置 2 个关键位位置的位置，并且有 $2^2$ 种可能的方法来为这些位赋值。 一般而言，如果我们希望计算在某个阶 $i$ 处存在多少表示超平面的模式，则该值由 $2^i\begin{pmatrix}L\\i\end{pmatrix}$ 给出，其中 $\begin{pmatrix}L\\i\end{pmatrix}$ 计算在长度为 $L$ 的字符串中选取 $i$ 个位置用于放置重要值的方法数；而 $2^i$ 则是用于计数在这些位置中可以有多少种不同的选择（0或1）。 对于 1 阶和 2 阶模式可以说明这种理想情况，如下所示：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801212401577.png" alt="image-20210801212401577" style="zoom:67%;" />

这些计数论证自然会导致关于种群规模与遗传算法采样的超平面数量之间关系的问题。

人们可以非常简单地看待这个问题，并询问有多少阶 1 的模式被采样，以及它们在大小为 N 的总体中的表示情况如何。这些数字基于这样一个假设，即我们对与 初始随机种群，选择会随时间改变分布。 在大小为 $N$ 的种群中，应当有 $N/2$ 个样本数分布在 $2L$ 个一阶超平面上。 因此，50% 的人口属于任何特定的 1 阶分区。 每个 2 阶分区由 25% 的总体抽样。 通常，每个 $i$ 阶超平面由总体的 (1=2)i 采样。

##### 5.1 The N3 Argumentry Alphabets

这些计数论证为当种群规模为 N 时遗传算法按 N3 个超平面的顺序进行处理的主张奠定了基础。这里使用的推导基于 Fitzpatrick 和 Grefenstette (1988) 的附录中的工作。
  让 是在大小为 N 的群体中至少由副本表示的超平面的最高阶； 由 log(N= ) 给出。 在声称我们正在对该超平面进行统计采样之前，我们希望至少有一个超平面的样本。
  回想一下，有序的不同超平面分区的数量由 2 L 给出，这只是选择不同位置并将所有可能的二进制值分配给每个子集的不同方法的数量 职位。 因此，我们现在需要展示 

![image-20210801223503555](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223503555.png)

因为 = log(N= ) 和 N = 2 。  Fitzpatrick 和 Grefenstette 现在提出以下论点。 假设L 64 和26 N 220。Pick = 8，这意味着3 17：通过检查，处理的模式数大于N3。
   对于任何大小为 N 的群体，这个论点通常不成立。给定长度为 L 的字符串，空间中的超平面数是有限的。 然而，人口规模可以任意选择。 与长度为 L 的字符串相关联的模式总数为 3L。 因此，如果我们选择 N = 3L 的人口规模，那么最多可以处理 N 个超平面（Michael Vose，个人通信）。 因此，必须相对于 L 选择 N 以使 N3 参数合理。 同时，值范围 26 N 220 确实代表了广泛的实际人口规模。
   尽管如此，N3 超平面被有效处理的论点假设所有这些超平面都以某种程度的独立性进行处理。 请注意，当前的推导只计算那些完全符合 - 的模式。 应该在随机初始总体中很好地表示的从 order-1 到 order- 的所有模式的总和由下式给出：P x=1 2x L x 。 通过只计算完全有序的模式——我们可能希望避免关于与低级模式交互的争论。 然而，所有 N3 论证真正表明的是，在给定适当的人口规模的情况下，可能有多达 N3 个超平面可以很好地表示。 但是可用于处理的模式数量的简单静态计数未能考虑遗传算法的动态行为。
   正如本教程后面所讨论的，遗传算法的动态模型现在已经存在（Vose 和 Liepins，1991；Whitley、Das 和 Crabb，1992）。 然而，还没有任何真正的尝试使用这些模型来研究大量超平面竞争之间的复杂相互作用。 显然，在某种空洞的意义上，了解初始种群的分布以及这些字符串（以及随后由遗传算法生成的字符串）的度数对于建模遗传算法的动态行为是足够的信息 (Vose 1993)。 这表明我们只需要有关遗传算法采样的那些字符串的信息。 然而，遗传算法的这种微观层面的观点似乎并不能解释其宏观层面的处理能力。

##### 5.2 The Case for Nonbinary Alphabets

有两个反对使用高基数字母表的基本论据。 首先，显式的超平面分区会更少。 其次，与较高基数字母表相关联的字母字符（和相应的超平面分区）在有限种群中不会得到很好的表示。 这要么迫使使用更大的人口规模，要么降低了统计抽样的有效性。
   使用二元字母表的论据假设表示超平面的模式必须通过重组显式和直接操作。  Antonisse (1989) 认为情况并非如此，高阶字母表在超平面样本方面与低阶字母表一样丰富。 例如，使用由 A、B、C、D 四个字符组成的字母表，可以通过定义 (A 和 B)、(C 和 D) 等分区来定义二进制字母表中所有相同的超平面分区。 一般来说，Antonisse 认为人们可以将模式的幂集的所有子集视为也定义超平面。
   以这种方式来看，更高基数的字母表比二进制字母表产生更多的超平面分区 21。 然而，Antonisse 的论点未能表明，对应于该方案中定义的子集的超平面实际上提供了新的独立信息源，可以通过遗传算法以有意义的方式进行处理。
   这并没有反驳 Antonisse 的说法，但确实表明存在与该假设相关的未解决问题。
   非二进制编码还有其他参数。  Davis (1991) 认为非二进制编码的缺点可以通过可应用于问题的更大范围的运算符来设置，并且可以利用编码的更多问题相关方面。  Scher and Eshelman (1992) 以及 Wright (1991) 为实值编码提出了有趣的论点。  Goldberg (1991) 建议促进超平面采样的虚拟最小字母表可以从更高基数的字母表中出现。

#### 6 Criticisms of the Schema Theorem

图式定理有一些明显的局限性，限制了它的实用性。
   首先，这是一种不平等。 通过忽略字符串增益和低估字符串损失，会丢失大量信息。 不等式的不精确性使得如果人们试图使用模式定理来预测特定超平面在多代中的表示，结果预测在许多情况下将是无用的或具有误导性（例如 Grefenstette 1993；Vose，个人通信 , 1993)。 其次，随着总体将其新样本集中在更专业的超空间子分区中，在时间 t 观察到的超平面 H 的 tness 会发生显着变化。 因此，查看特定超平面中所有字符串的平均 tness（或使用随机样本来估计该 tness）仅与第一代或第二代相关（Grefenstette 和 Baker，1989）。
   在此之后，字符串的采样是有偏差的，模式定理的不准确使得无法预测计算行为。
   一般而言，模式定理提供了一个下界，该下界仅适用于未来一代。 因此，如果不考虑遗传算法正在处理的其他超平面同时发生的情况，就无法预测多代超平面 H 的表示。
   这些批评意味着本教程第 3 节中提出的超平面采样的观点可能是解释超平面采样的很好的修辞工具，但它们未能捕捉到遗传算法的全部复杂性。 这部分是因为第 3 节中的讨论侧重于选择的影响，而没有考虑交叉的破坏性和生成性影响。 图式定理没有提供遗传算法行为的准确图片，也无法预测特定超平面是如何随时间处理的。 在下一节中，将介绍模式定理的精确版本。

#### 7 An Executable Model of the Genetic Algorithm

在删除增益项和简化损失计算之前考虑模式定理的完整版本

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223643653.png" alt="image-20210801223643653" style="zoom:67%;" />

在当前的公式中，Z 将指代一个字符串。 假设我们将此等式应用于搜索空间中的每个字符串。 结果是遗传算法的计算行为的精确模型。 由于建模字符串对最高阶模式进行建模，因此该模型隐含地包括所有低阶模式。 此外，在使用 tness 比例再现的规范遗传算法中，字符串的 tness 是常数，人们不必担心观察到的由当前种群表示的超平面的 tness 的变化。 给定 Z 的规格，人们可以准确地计算损失和收益。 当一根弦与另一根弦交叉并且由此产生的 o 弹簧无法保留原始弦时，就会发生损失。 当两个不同的字符串交叉并独立创建某个字符串的新副本时，就会产生增益。 例如，如果 Z = 000，那么重新组合 100 和 001 将始终产生 000 的新副本。假设使用单点杂交作为运算符，则计算字符串 Z = 000 的 \losses" 和 \gains" 概率 如下：

![image-20210801223747482](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223747482.png)

在前面的等式中使用 PI0 表示在相应字符串或字符串对上的任何位置交叉的概率。 由于 Z 是一个字符串，因此 PI0 = 1.0 和相关情况下的交叉将始终产生损失或收益（取决于该术语出现的表达式）。 一个点交叉落在第一个和第二个比特之间的概率将用 PI1 表示。 在这种情况下，交叉点必须恰好落在相对于相应字符串的这个位置才能导致损失或收益。 同样，PI2 将表示一点交叉落在第二位和第三位之间的概率，并且在计算中使用 PI2 意味着对于特定的字符串或字符串对，交叉必须落在这个位置才能影响损失的计算 或收益。 在上图中，PI1 = PI2 = 0:5。
   方程可以推广到覆盖空间中剩余的 7 个字符串。 这种转换是使用按位加法模 2 完成的（即按位异或表示为 。参见图 4 和第 6.4 节）。 函数 (Si Z) 应用于包含在本节中给出的等式中的每个位串 Si，以生成适当的对应串，以生成用于计算 P(Z,t+1) 形式的所有项的表达式。

##### 7.1 A Generalized Form Based on Equation Generators

3 位方程类似于 Goldberg (1987) 开发的 2 位方程。 这些方程的一般形式的发展通过以系统方式生成损失和增益项来说明（Whitley，Das 和 Crabb，1992）。 由于方程中的项数大于搜索空间中的字符串数，因此开发用于大约 15 位编码的方程是可行的。 方程只需为空间中的一个字符串定义一次； 方程的标准形式总是为由全零位组成的字符串定义的。 令 S 表示长度为 L 的二进制字符串集，由 i 索引。 通常，由所有零位组成的字符串表示为 S0。

##### 7.2 Generating String Losses for 1-point crossovers

考虑两个字符串 00000000000 和 00010000100。使用单点杂交，如果交叉发生在第一个 \1" 位之前或最后一个 \1" 位之后，则不会发生中断。 然而，1 位之间的任何交叉都会产生中断：双亲都不会在交叉中幸存下来。
   另请注意，将 00000000000 与任何形式为 0001####100 的字符串重新组合将产生相同的中断模式。 我们将这个字符串称为生成器：它就像一个模式，但使用 # 代替 * 以更好地区分生成器和相应的超平面。  Bridges 和 Goldberg (1987) 将生成器的概念形式化如下。 考虑字符串 B 和 B0，其中第一个 x 位相等，中间 (+1) 位具有 b##:::#b 的模式 B 和 b ##:::# b 的模式 B0。 鉴于字符串的长度为 L，最后的 (L x 1) 位是等效的。  b 位被称为 \sentry 位”，它们用于定义中断的概率。在标准形式中，B = S0 并且哨兵位必须为 1。以下有向无环图说明了 \string 的所有生成器 损失”用于 S0 的 5 位方程的标准形式。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223840800.png" alt="image-20210801223840800" style="zoom:67%;" />

图结构允许将所有生成器的字符串损失集可视化。 一般来说，这个图的根由一个字符串定义，在第一个和最后一个位位置有一个哨兵位，在所有其他中间位置有一个生成器标记 \#"。在图中向下和向左移动会导致 最左边的哨兵位向右移动；向下和向右移动会导致最右边的哨兵位向左移动。哨兵位置之外的所有位都是 \0" 位。 对图表进行总结，可以看出，作为串损耗的潜在来源，产生的 PLƀ1 j=1 j 2Lƀj1 或 (2L L 1) 串

对于由上述图形结构中的 \middle" 生成器之一产生的每个字符串 Si，将以下形式的项添加到损失方程中：

![image-20210801223934362](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210801223934362.png)

其中 (Si) 是一个函数，用于计算字符串 Si 中哨兵位之间的交叉点数。

##### 7.3 Generating String Gains for 1-point crossover

Bridges 和 Goldberg (1987) 指出，弦 B 的弦增益由两个弦 Q 和 R 产生，这两个弦与 B 具有以下关系。





## 遗传算法综述：过去、现在和未来

在本文中，讨论了对遗传算法的最新进展的分析。 选择研究界非常感兴趣的遗传算法进行分析。 这篇综述将帮助新的和要求苛刻的研究人员提供更广泛的遗传算法视野。 介绍了众所周知的算法及其实现，以及它们的优缺点。 讨论遗传算子及其用法的目的是为新研究人员提供便利。涵盖了遗传算法中涉及的不同研究领域。 讨论了遗传算子、适应度函数和混合算法领域的未来研究方向。这种结构化的审查将有助于研究和研究生教学

关键词：优化，元启发式，遗传算法，交叉，突变，选择，进化

### 1 Introduction

近年来，元启发式算法被用于解决来自经济、工程、政治、管理和工程等不同领域的现实生活中的复杂问题[113]。 集约化和多样化是元启发式算法的关键要素。 这些元素之间需要适当的平衡才能有效地解决现实生活中的问题。 大多数元启发式算法的灵感来自生物进化过程、群体行为和物理学定律 [17]。

这些算法大致分为两类，即单一解决方案和基于群体的元启发式算法（图 1）。 基于单一解决方案的元启发式算法利用单一候选解决方案并通过使用局部搜索来改进该解决方案。 然而，从基于单一解决方案的元启发式获得的解决方案可能会陷入局部最优 [112]。著名的基于单一解决方案的元启发式算法是模拟退火、禁忌搜索 (TS)、微规范退火 (MA) 和引导局部搜索 (GLS)。 基于群体的元启发式算法在搜索过程中使用多个候选解决方案。 这些元启发式保持了种群的多样性，避免了解决方案陷入局部最优。 一些著名的基于种群的元启发式算法是遗传算法 (GA) [135]、粒子群优化 (PSO) [101]、蚁群优化 (ACO) [47]、斑点鬣狗优化器 (SHO) [41]、 帝企鹅优化器 (EPO) [42] 和海鸥优化 (SOA) [43]。

![image-20210802153908524](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802153908524.png)

在元启发式算法中，遗传算法（GA）是一种众所周知的算法，其灵感来自生物进化过程[136]。  GA 在自然界中模仿了达尔文的适者生存理论。  GA 是由 J.H.Holland 于 1992 年提出的。GA 的基本要素是染色体表示、适应度选择和生物启发的算子。  Holland 还引入了一个新元素，即 Inversion，它通常用于 GA [77] 的实现。 通常，染色体采用二进制字符串格式。 在染色体中，每个基因座（染色体上的特定位置）都有两个可能的等位基因（基因的变异形式）——0 和 1。

染色体被认为是解空间中的点。 这些是使用遗传算子通过迭代替换其种群来处理的。 适应度函数用于为种群中的所有染色体分配一个值 [136]。 受生物学启发的算子是选择、变异和交叉。 在选择中，染色体是根据其适应度值进行选择以进行进一步处理。 在交叉算子中，选择一个随机基因座并改变染色体之间的子序列以创建后代。 在突变中，染色体的某些位将根据概率随机翻转 [77, 135, 136]。 基于算子、表示和适应度的 GA 的进一步发展已经减弱。因此，本文重点关注 GA 的这些要素

本文的主要贡献如下： 

1. 用数学公式阐述了遗传算法和混合遗传算法的总体框架。

   2. 讨论了各种类型的遗传算子及其优缺点。
   3. 讨论了 GA 的变体及其优缺点。
   4. 讨论了遗传算法在多媒体领域的适用性

本文的主要目的有两个方面。 首先，介绍了遗传算法的变体及其在各个领域的适用性。 二是拓宽了各个领域的可能用户范围。讨论了各种类型的交叉、变异、选择和编码技术。讨论了单目标、多目标、并行和混合 GAs 的优缺点。 阐述了遗传算法的多媒体应用。

本文的其余部分组织如下：第 2 节介绍了用于开展研究的方法。 第 3 节讨论经典遗传算法和遗传算子。第 4 节介绍遗传算法的优缺点。第 5 节描述遗传算法的应用。 第 6 节提出了挑战和未来的研究方向。 结论性意见在第 7 节中得出。

### 2 Research methodology

PRISMA 的指南用于对 GA 进行审查 [138]。 在谷歌学术和 PubMed 上进行了详细搜索，以识别与 GA 相关的研究论文。本文还补充了人工检索中发现的重要研究成果。
在搜索过程中，使用了一些关键词，例如“遗传算法”或“遗传算法的应用”或“遗传算法的算子”或“遗传算法的表示”或“遗传算法的变体”。 探索性研究论文的选择和拒绝基于表1中提到的原则。

共有 27,64,792 篇研究论文在 Google Scholar、PubMed 和手动搜索中进行了探索。 还包括与多媒体应用遗传算法相关的研究工作。 在研究论文筛选过程中，所有重复论文和2007年之前发表的论文都被丢弃。 根据2007年和重复条目筛选出4340篇研究论文。 此后，根据标题淘汰了 4050 篇研究论文。  220篇研究论文在阅读摘要后被淘汰。 第三轮筛选后留下70篇研究论文。 在阅读全文并发现论文中的事实后，还有 40 篇研究论文被丢弃。 经过第四轮筛选，最终选出30篇研究论文进行评审。

根据研究的相关性和质量，选择了30篇论文进行评估。 研究的相关性是通过一些标准来决定的，如表 1 所示。

![image-20210802154324825](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802154324825.png)

选定的研究论文包括用于多媒体应用的遗传算法、遗传算子的进步以及遗传算法与其他完善的元启发式算法的混合。 遗传算子的优缺点见上节

### 3 Background

本节讨论遗传算法的基本结构及其遗传算子的优缺点。

#### 3.1 Classical GA

遗传算法（GA）是一种受自然选择启发的优化算法。 它是一种基于群体的搜索算法，它利用了适者生存的概念 [135]。 新种群是通过对种群中存在的个体迭代使用遗传算子产生的。 染色体表示、选择、交叉、变异和适应度函数计算是遗传算法的关键要素。  GA的过程如下。  $n$​ 条染色体的种群 ($Y$​) 是随机初始化的。 计算 $Y$​ 中每个染色体的适应度。 两条染色体 $C1$​ 和 $C2$ 是根据适应度值从群体Y中选出的。

将具有交叉概率（$C_p$​​）的单点交叉算子应用于 $C1$​​ 和 $C2$​​ 以产生后代 $O$​​。此后，对产生的后代（$O$​​）以变异概率（$M_p$​​）应用均匀变异算子以产生 $O'$​。 新的后代 $O'$ 被放置在新的种群中。 选择、交叉和变异操作将在当前种群上重复进行，直到新种群完成。

遗传算法的数学分析如下[126]：遗传算法通过交叉和变异的概率动态改变搜索过程，达到最优解。  GA 可以修改编码的基因。  GA 可以评估多个个体并产生多个最优解。 因此，GA 具有更好的全局搜索能力。 亲本染色体交叉产生的后代很可能废除亲本染色体的优良遗传模式，交叉公式定义为[126]：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802161701406.png" alt="image-20210802161701406" style="zoom: 50%;" />

其中 $g$ 为世代数，$G$ 为种群设定的进化世代总数。 从式(1)可以看出，R随着进化代数的增加而动态变化和增加。 在 GA 的初始阶段，个体之间的相似度非常低。  R的值应该低，以确保新种群不会破坏个体优良的遗传图式。 在进化末期，个体之间的相似度很高，R的值也应该很高。

根据模式定理，必须用修改后的模式替换原始模式。 为了保持种群的多样性，新模式在进化的早期保留了初始种群。 在进化结束时，将产生适当的模式，以防止对优良遗传图式的任何扭曲 [65, 75]。 算法1显示了经典遗传算法的伪代码

**Input**：种群大小 $n$ 

最大迭代次数  $MAX$​ 

**Output**：全局最佳解，$Y_{bt}$

**begin**： 生成 $n$ 条染色体的初始种群 $Y_i (i=1, 2, n)$ 

设置迭代计数器 $t=0$​ 

计算每个染色体的适应值 

**while(t<  MAX)** 

基于适应度从初始种群中选择一对染色体 

以交叉概率对选定的染色体应用交叉操作 

以变异概率对后代应用变异 

用新生成的种群替换旧种群 

将当前迭代 $t$ 增加 1 

**end while**，同时返回最佳解 y

#### 3.2 Genetic operators

GA 在搜索过程中使用了多种运算符。 这些操作符是编码方案、交叉、变异和选择。 图 2 描述了 GA 中使用的运算符。

##### 3.2.1 Encoding schemes

对于大多数计算问题，编码方案（即转换特定形式）起着重要作用。 给定的信息必须以特定的位串进行编码 [121, 183]。 编码方案根据问题域进行区分。众所周知的编码方案是二进制、八进制、十六进制、置换、基于值和树。

二进制编码是常用的编码方案。 每个基因或染色体都表示为一串 1 或 0 [187]。 在二进制编码中，每一位代表解的特征。 它提供了更快的交叉和变异算子的实现。然而，转换成二进制形式需要额外的努力，算法的准确性取决于二进制转换。 比特流根据问题改变。 由于上位性和自然表示，二进制编码方案不适用于某些工程设计问题。

在八进制编码方案中，基因或染色体以八进制数（0-7）的形式表示。 在十六进制编码方案中，基因或染色体以十六进制数（0-9，A-F）的形式表示 [111, 125, 187]。置换编码方案一般用于排序问题。在这种编码方案中，基因或染色体由代表**序列中位置**的一串数字表示。在值编码方案中，基因或染色体用一些值的字符串表示。这些值可以是实数、整数或字符 [57]。 这种编码方案有助于解决使用更复杂值的问题。 由于二进制编码可能会在此类问题中失败。 它主要用于神经网络中寻找最佳权重。

在树编码中，基因或染色体由功能或命令树表示。 这些函数和命令可以与任何编程语言相关。这与树格式的抑制表示非常相似 [88]。 这种类型的编码通常用于演进的程序或表达式。 表2显示了GA不同编码方案的比较。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802162613000.png" alt="image-20210802162613000" style="zoom:67%;" />

##### 3.2.2 Selection techniques

选择是遗传算法中的一个重要步骤，它决定了特定的字符串是否会参与复制过程。 选择步骤有时也称为再现算子 [57, 88]。  GA 的收敛速度取决于选择压力。 众所周知的选择技术是轮盘赌、排名、锦标赛、玻尔兹曼和随机通用抽样。

轮盘选择将所有可能的字符串映射到一个轮子上，轮子的一部分根据它们的适应值分配给它们。 然后随机旋转这个轮子以选择将参与下一代形成的特定解决方案[88]。然而，它存在许多问题，例如由其随机性质引入的错误。De Jong 和 Brindle 修改了轮盘赌的选择方法，通过在选择过程中引入确定性的概念来消除错误。 排名选择是轮盘选择的改进形式。 它利用排名而不是适应度值。 根据他们的适应度值给他们排名，以便每个人都有机会根据他们的排名被选中。 秩选择方法减少了将解过早收敛到局部最小值的机会 [88]。

锦标赛选择技术由 Brindle 于 1983 年首次提出。根据个体的适应度值从随机轮盘赌中成对选择。 选择后，将适应度值较高的个体加入到下一代池中[88]。 在这种选择方法中，如果每个个体达到解决方案的最终群体，则将每个个体与所有 n-1 个其他个体进行比较 [88]。 随机通用抽样 (SUS) 是对现有轮盘赌选择方法的扩展。 它使用来自一代人的个体列表中的随机起点，并以均匀间隔选择新个体 [3]。 它为所有被选中参与下一代交叉的人提供了平等的机会。 虽然在旅行商问题的情况下，SUS 表现良好，但随着问题规模的增加，传统的轮盘选择表现相对较好[180]。

玻尔兹曼选择基于蒙特卡罗模拟中使用的熵和采样方法。 它有助于解决早熟收敛的问题[118]。 选择最佳字符串的概率非常高，而它的执行时间非常短。但是，存在信息丢失的可能性。 它可以通过精英主义来管理[175]。

精英选择由 K. D. Jong (1975) 提出，用于提高轮盘选择的性能。 它确保一代中的精英个体始终传播到下一代。 如果经过正常选择程序后具有最高适应度值的个体没有出现在下一代中，那么精英个体也会自动包含在下一代中[88]。 上述选择技术的比较如表 3 所示。

| 编码方案 | 优点                  | 缺点                 | 应用                 |
| -------- | --------------------- | -------------------- | -------------------- |
| 二进制   | 易于实施 执行速度更快 | 不支持反演运算符     | 支持二进制编码的问题 |
| 八进制   | 易于实施              | 不支持反演运算符     | 限制使用             |
| 十六进制 | 易于实施              | 不支持反演运算符     | 限制使用             |
| 排列     | 支持反演算子          | 不支持二元运算符     | 任务排序问题         |
| 值       | 无需价值转换          | 需要特定的交叉和突变 | 神经网络问题         |
| 树       | 操作员可以轻松应用    | 一些问题难以设计树   | 发展计划             |

##### 3.2.3 Crossover operators

交叉算子通过结合两个或多个亲本的遗传信息来产生后代。著名的交叉算子有单点交叉、两点交叉、k点交叉、均匀交叉、部分匹配交叉、顺序交叉、优先保持交叉、随机交叉、简化代理和循环交叉

在单点交叉中，选择一个随机交叉点。超过这一点的双亲的遗传信息将相互交换[190]。图3显示了交换后的遗传信息。它取代了双亲的尾部数组位来获得新的后代。
在两点和k点交叉中，选择两个或多个随机交叉点，并根据已创建的片段交换亲本的遗传信息[190]。图4显示了交叉点之间遗传信息的交换。父母的中间部分被替换以产生新的后代。

在均匀交叉中，父项不能分解为段。亲本可以单独作为每个基因处理。我们随机决定是否需要将该基因与另一条染色体的相同位置互换[190]。图5描述了均匀交叉操作下的个体交换。

部分匹配交叉（PMX）是最常用的交叉算子。它是一种性能优于大多数其他交叉算子的算子。部分匹配（映射）交叉是由D.戈德伯格和R.林格尔提出的[66]。选择两个父母进行交配。父母中的一方捐赠部分遗传物质，另一方的相应部分参与到孩子身上。一旦这一过程完成，遗漏的等位基因将从第二个亲本复制[83]。图6描述了PMX的示例。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802165901491.png" alt="image-20210802165901491" style="zoom:67%;" />

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802165925053.png" alt="image-20210802165925053" style="zoom:67%;" />

顺序交叉（OX）是由Davis在1985年提出的。OX将父代的一个（或多个）部分从选定的切点复制到子代，并用复制部分中包含的值以外的值填充剩余空间。OX的变体是由不同的研究人员针对不同类型的问题提出的。OX对于排序问题很有用[166]。然而，我们发现，在旅行商问题的情况下，OX的效率较低[140]。

优先保持交叉（PPX）在应用交叉之前保持子代父代中存在的单个解的顺序。子代初始化为随机1和0的字符串，以决定是否选择来自双亲的个体。在[169]中，作者针对多目标调度问题提出了一种改进的PPX。

Shuffle交叉是由Eshelman等人[20]提出的，以减少其他交叉技术引入的偏差。它在交叉之前洗牌单个解决方案的值，并在执行交叉操作后取消缓冲，以便交叉点不会在交叉中引入任何偏差。然而，近年来，这种交叉的应用非常有限。

减少代理交叉（RCX）减少了不必要的交叉，如果父母有相同的基因序列用于解决方案表示[20，139]。RCX是基于这样一个假设，即如果父母的遗传组成足够多样化，遗传算法会产生更好的个体。然而，RCX不能为那些具有相同成分的父母产生更好的个体。周期交叉由Oliver提出[140]。它试图使用父代生成子代，其中每个元素通过引用其父代的位置占据该位置[140]。在第一个循环中，它从第一个父级获取一些元素。在第二循环中，它从第二父级获取剩余元素，如图7所示。

表4显示了交叉技术的比较。从表4可以看出，单点和k点交叉技术易于实现。均匀交叉适用于大型子集。顺序和循环交叉比其他交叉技术提供更好的探索。部分匹配交叉提供了更好的探索。部分匹配交叉技术的性能优于其他交叉技术。减少代理和循环交叉会导致过早收敛。

![image-20210802170322500](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802170322500.png)

![image-20210802170335800](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802170335800.png)

##### 3.2.4 Mutation operators

突变是一种保持种群间遗传多样性的算子。著名的变异算子有置换、简单反演和置乱变异。置换突变（DM）算子在其自身内置换给定个体解的子串。从给定的位移子串中随机选择位置，这样得到的解是有效的，并且是随机位移突变。DM的变异有交换突变和插入突变。在交换变异和插入变异算子中，单个解的一部分分别与另一部分交换或插入到另一个位置[88]。

简单反转变异算子（SIM）在单个解中的任意两个指定位置之间反转子串。SIM是一种反转运算符，可反转随机选择的字符串并将其放置在随机位置[88]。置乱变异（SM）算子以随机顺序将元素放置在单个解决方案的指定范围内，并检查最近生成的解决方案的适应度值是否得到改善[88]。

表5显示了不同突变技术的比较。

表6显示了编码方案、变异和交叉技术的最佳组合。从表6可以看出，均匀和单点交叉可用于大多数编码和变异算子。部分匹配交叉与反向变异结合使用，置换编码方案提供了最优解。

| 算子         | 优点                             | 缺点                         |
| ------------ | -------------------------------- | ---------------------------- |
| 置换突变     | 易于实现，适用于小问题实例       | 过早收敛的风险               |
| 简单倒位突变 | 易于实现                         | 早熟收敛                     |
| 乱序突变     | 影响适用于大型问题实例的大量基因 | 种群扰动若干问题解的质量劣化 |

| 编码方案   | 突变 | 交叉                                       |
| ---------- | ---- | ------------------------------------------ |
| 二进制编码 | 反转 | 均匀、算术、1点、N点置换反转部分匹配交叉， |
| 置换       | 反转 | 循环交叉，顺序交叉                         |
| 价值       | 取代 | 均匀、算术、1点、N点                       |
| 树         | 争夺 | 均匀，1点                                  |

![image-20210802171023221](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802171023221.png)

### 4 Variants of GA

研究人员已经提出了遗传算法的各种变体。遗传算法的变体大致分为五大类，即实数和二进制编码、多目标、并行、混沌和混合气体。这些算法及其应用的优缺点已在前面的小节中讨论过

#### 4.1 Real and binary coded GAs

基于染色体的表示，遗传算法分为两类，即二进制遗传算法和实数编码遗传算法。

##### 4.1.1 Binary coded GAs

二进制表示用于编码遗传算法，称为二进制遗传算法。遗传算子也被修改以执行搜索过程。Payne和Glen[153]开发了一种二元遗传算法来识别分子间的相似性。他们用二元表示分子的位置和构象。然而，该方法具有较高的计算复杂度。龙岩等人[203]研究了使用二进制遗传算法（BGA）设计风电场的三种不同方法。他们的方法产生了更好的适应值和农场效率。Shukla等人[185]利用BGA进行特征子集选择。他们使用互信息最大化的概念来选择重要特征。BGA面临着汉明悬崖、不均匀的模式和难以达到精度的问题[116199]。

##### 4.1.2 Real-coded GAs

实际编码的GA（RGAS）已广泛用于各种现实生活应用。 染色体的表示与现实生活问题密切相关。  RGA的主要优点是强大，高效，准确。 然而，RGAS遭受过早的收敛性。 研究人员正在研究RGA来提高他们的表现。  RGA大部分是通过修改交叉，突变和选择运算符开发的

**Crossover operators ** 对于连续搜索空间，交叉算子的搜索能力并不令人满意。 交叉算子的发展已经完成，以提高它们在真实环境中的性能。  Wright [210] 提出了一种启发式交叉，应用于父母以产生后代。  Michalewicz [135] 提出了 RGA 的算术交叉算子。  Deb 和 Agrawal [34] 开发了一种实数编码的交叉算子，它基于 BGA 中单点交叉的特点。 开发的交叉算子称为模拟二元交叉（SBX）。  SBX 能够克服汉明悬崖、精度和固定映射问题。  SBX 在二变量阻塞函数中的性能并不令人满意。 埃舍曼等人。  [53]利用模式概念来设计 RGA 的混合交叉。 单峰正态分布交叉算子（UNDX）是由小野等人开发的。[144]。 他们使用椭球概率分布来生成后代。 基塔等人。  [106] 提出了一种多父 UNDX（MP-UNDX），它是 [144] 的扩展。 但是，带有 MP-UNDX 的 RGA 的性能与 UNDX 非常相似。  Deep 和 Thakur [39] 提出了 RGA 的拉普拉斯交叉，它基于拉普拉斯分布。 庄等人。  [27] 开发了一种基于方向的交叉来进一步探索所有可能的搜索方向。 但是，搜索方向是有限的。 启发式正态分布交叉算子是由 Wang 等人开发的。  [207]。 它生成交叉生成的后代以进行更好的搜索操作。但是，这种方法不考虑更好的个体。 苏巴拉吉等人。  [192] 提出了田口自适应 RCGA。 他们使用田口方法和模拟二元交叉来开发有能力的后代。

**Mutation operators** 变异算子在种群中产生多样性。 在应用突变过程中必须解决两个主要挑战。 首先，变异算子应用于种群的概率。 其次，变异过程后染色体中产生的异常值。  Michalewicz [135] 提出了 RGA 的统一和非统一变异算子。  Michalewicz 和 Schoenauer [136] 表 6 最佳环境编码方案下各种算子的最佳组合变异交叉二进制编码反转均匀，算术，1-点，N-点置换反转部分匹配交叉，循环交叉，阶交叉值位移统一，算术 , 1-Point, N-Point Tree Scramble Uniform, 1-Point Multimedia Tools and Applications 8102 (2021) 80:8091–8126 开发了一种统一突变的特例。 他们开发了边界突变。Deep 和 Thakur [38] 提出了一种基于幂律的新型变异算子，命名为幂变异。  Das 和 Pratihar [30] 提出了基于方向的指数变异算子。 他们使用变量的方向信息。  Tang 和 Tseng [196] 提出了一种新的变异算子，用于提高 RCGA 的性能。
   他们的方法快速而可靠。 但是，它在某些应用程序中停留在局部最优。 德布等人。  [35] 开发了用于 RCGA 的多项式突变。
   它提供了更好的探索。 然而，收敛速度很慢，并且停留在局部最优。 卢卡修斯等人。  [129] 提出了一种实数编码遗传算法（RCGA）。
   它简单易行。 然而，它存在局部最优问题。
   王等人。  [205] 开发了多后代遗传算法并研究了它们在单点交叉上的表现。 王等人。  [206] 阐述了多后代遗传算法的理论基础。 该方法的性能优于非多后代遗传算法。
   帕塔奈克等人。  [152] 提出了 RCGA 的改进。。

| 算子                   |                                                              |
| ---------------------- | ------------------------------------------------------------ |
| 模拟二元交叉           | $p_i=\frac12[(1-\beta)x_i+(1+\beta)y_i]$​​   $q_i=\frac12[(1+\beta)x_i+(1-\beta)y_i]$​这里，生成两个后缀（ $P$ 和 $Q$ ）。  $X$​ 和 $Y$​ 是个人。  $β$ 是一个变量，其值间于$[0，∞)$​ |
| 融合交叉               | 从父母x和y从间隔生成后代p                                    |
| 算术交叉几何交叉       |                                                              |
| 单向正态分布交叉运算符 |                                                              |
| 拉普拉斯交叉           |                                                              |

#### 4.2 Multiobjective GAs

MultiobjectiveGA(MOGA)是简单GA的修改版本。MOGA在适应度函数分配方面与GA不同。 其余步骤与 GA 类似。 多目标遗传算法的主要动机是在目标空间中生成最优的帕累托前沿，这样就不会在不干扰其他适应度函数的情况下进一步增强任何适应度函数[123]。收敛性、多样性和覆盖率是多目标遗传算法的主要目标。 多目标 GA 大致分为两类，即基于帕累托的多目标 GA 和基于分解的多目标 GA [52]。 这些技术在前面的小节中讨论过。

##### 4.2.1 Pareto-based multi-objective GA

帕累托优势的概念是在多目标 GA 中引入的。  Fonseca 和 Fleming [56] 开发了第一个多目标遗传算法（MOGA）。 提出了利基和决策者概念来解决多模式问题。 然而，MOGA 存在参数调整问题和选择压力的程度。 霍恩等人。  [80] 提出了一种利基帕累托遗传算法（NPGA），它利用了锦标赛选择和帕累托优势的概念。  Srinivas 和 Deb [191] 开发了一种非支配排序遗传算法（NSGA）。 然而，它缺乏精英主义，需要共享参数，计算复杂度高。 为了缓解这些问题，Deb 等人。  [36] 开发了一种快速精英非支配排序遗传算法（NSGA-II）。  NSGA-II 的性能可能会因许多客观问题而恶化。  NSGA-II 无法保持帕累托前沿的多样性。 为了缓解这个问题，Luo 等人。  [130] 在 NSGA-II 中引入了动态拥挤距离。  Coello 和 Pulido [28] 开发了一种多目标微遗传算法。 他们使用存档来存储非支配解决方案。 在许多客观问题中，基于帕累托的方法的性能可能会下降 [52]。

##### 4.2.2 Decomposition-based multiobjective GA

基于分解的 MOGA 将给定的问题分解为多个子问题。 这些子问题同时解决并在相邻子问题之间交换解决方案[52]。  Ishibuchi 和 Murata [84] 开发了一种多目标遗传局部搜索（MOGLS）。 在 MOGLS 中，随机权重用于选择父母并对其后代进行本地搜索。他们使用代换和轮盘选择方法。  Jaszkiewicz [86] 通过利用不同的父母选择机制修改了 MOGLS。  Murata 和 Gen [141] 提出了一种用于多目标优化的细胞遗传算法（C-MOGA），它是 MOGA 的扩展。 他们在 MOGA 中添加了细胞结构。 在 C-MOGA 中，选择算子是在每个单元格的相邻单元格上执行的。  C-MOGA 通过引入移民程序进一步扩展，称为 CI-MOGA。  Alves 和 Almeida [11] 开发了一种基于 Tchebycheffs 的多目标遗传算法 (MOTGA)，可确保收敛性和多样性。  Tchebycheff 标量函数用于生成非支配解集。 帕特尔等人。  [151]提出了一种基于分解的MOGA（D-MOGA）。他们在 D-MOGA 中集成了基于对立的多媒体工具和应用程序学习以生成权重向量。  D-MOGA 能够在解决方案的多样性和搜索空间的探索之间保持平衡。

##### 4.3 Parallel GAs

并行 GA 背后的动机是通过分布式个体提高计算时间和解决方案的质量。 并行 GA 分为三大类，例如主从并行 GA、细粒度并行 GA 和多群体粗粒度并行 GA [70]。 在主从并行 GA 中，适应度函数的计算分布在多个处理器上。 在细粒度 GA 中，并行计算机用于解决现实生活中的问题。 遗传算子受限于它们的邻域。 但是，个人之间允许交互。 在粗粒度 GA 中，执行子种群之间的个体交换。 控制参数也在迁移过程中传输。 并行 GA 的主要挑战是最大化内存带宽并安排线程以利用 GPU 的能力 [23]。 表 8 显示了并行 GA 在硬件和软件方面的对比分析。 在前面的小节中研究了众所周知的并行 GA

###### 4.3.1 Master slave parallel GA

与其他方法相比，主从并行 GA (MS-PGA) 中使用了大量处理器。 可以通过增加处理器的数量来增加适应度函数的计算。 洪等人。  [79] 使用 MS-PGA 来解决数据挖掘问题。 模糊规则与并行遗传算法一起使用。 适应度函数的评估是在从机上进行的。 然而，它受到高计算时间的影响。  Sahinzo [174] 为无人机寻路问题实现了 MS-PGA。 遗传算子在处理器上执行。 他们使用了四核的多核 CPU。 选择和适应度评估是在从机上完成的。  MS-PGA 应用于[127]中的流量分配问题。 他们在新加坡国立大学使用了 30 个处理器来解决这个问题。
   杨等人。  [213] 开发了一种基于网络的并行遗传算法。 他们在分布式环境中实现了 NSGA-II 的主从版本。 然而，该系统本质上是复杂的。

![image-20210802212809531](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210802212809531.png)

###### 4.3.2 Fine grained parallel GA

在过去的几十年里，研究人员正在研究细粒度并行遗传算法 (FGPGA) 的迁移策略。
   波尔塔等人。  [161] 利用时钟时间作为迁移频率，这与世代无关。 他们使用了非均匀结构和静态配置。 选择最佳解决方案进行迁移，最差解决方案替换为迁移解决方案。  Kurdi [115] 使用了自适应迁移频率。 迁移过程开始，直到连续十代后获得的解决方案没有变化。 使用了非均匀和动态结构。 在[209]中，局部最优解被同步并形成全局最优解。 全局最佳解决方案被转移到所有处理器以供父执行。 迁移频率取决于世代数。 他们使用统一的结构和固定的配置。 张等人。
   [220] 使用并行遗传算法解决无线网络的集合覆盖问题。 他们使用分而治之的策略将种群分解为子种群。 此后，将遗传算子应用于局部解，并使用 Kuhn-Munkres 合并局部解。











































































































































































































































