## 

## A Genetic Algorithm Tutorial

本教程涵盖了规范遗传算法以及更多实验形式的遗传算法，包括并行岛模型和并行细胞遗传算法。 本教程还说明了通过超平面采样进行遗传搜索。 回顾了遗传算法的理论基础，包括模式定理以及最近开发的规范遗传算法的精确模型

#### 1 Introduction

遗传算法是一系列受进化启发的计算模型。 这些算法在简单的类似染色体的数据结构上对特定问题的潜在解决方案进行编码，并将重组算子应用于这些结构以保留关键信息。 遗传算法通常被视为函数优化器，尽管遗传算法所应用的问题范围相当广泛。

遗传算法的实现始于一群（通常是随机的）染色体。 然后评估这些结构并以这样一种方式分配繁殖机会，即那些代表目标问题的更好解决方案的染色体比那些较差解决方案的染色体有更多的机会“繁殖”。

解决方案的“优”通常是根据当前种群定义的。这种对遗传算法的特殊描述是有意抽象的，因为在某种意义上，遗传算法这个术语有两个含义。 在严格的解释中，遗传算法是指由 John Holland (1975) 和 Holland 的学生 (e.g., DeJong, 1975) 引入和研究的模型。 大多数现有的遗传算法理论仍然是这样，要么单独或主要适用于 Holland 引入的模型，以及本文中将被称为规范遗传算法的变体。 建模遗传算法的最新理论进展也主要适用于规范遗传算法（Vose，1993）。

在该术语的更广泛用法中，遗传算法是任何基于群体的模型，它使用选择和重组算子在搜索空间中生成新的样本点。研究人员从实验的角度引入了许多遗传算法模型。 这些研究人员中有许多是面向应用的，并且通常对作为优化工具的遗传算法感兴趣。

本教程的目标是以这样一种方式介绍遗传算法，使刚接触该领域的学生可以在学习本教程时掌握遗传算法背后的基本概念。 它应该允许更老练的读者相对容易地吸收这些材料。 本教程还涵盖了一些主题，例如反演，这些主题有时会被该领域的新研究人员误解和误用。

本教程首先对优化进行了非常初级的讨论，以介绍优化的基本思想以及与遗传算法相关的基本概念。 在第 2 节中，回顾了典型的遗传算法。 第 3 节探讨了超平面采样的原理，并介绍了一些基本的交叉算子。 在第 4 节中，模式定理的各种版本逐步发展，并讨论了其他交叉算子。 在第 5 节中考虑了二进制字母及其对超平面采样的影响。 在第 6 节中考虑了对模式定理的简要批评，并在第 7 节中开发了遗传算法的精确模型。 本教程的最后三个部分涵盖了遗传算法和进化计算模型的替代形式，包括专门的并行实现

##### 1.1 Encodings and Optimization Problems

大多数遗传算法中通常只有两个与问题相关的主要元素：问题编码和评估函数。

考虑一个参数优化问题，我们必须优化一组变量以最大化某些目标（例如利润的大小），或者最小化成本或某种误差。 我们可能会将此类问题视为一个黑匣子，其中包含一系列代表不同参数的控制旋钮； 黑盒的唯一输出是评估函数返回的值，该值指示特定参数设置组合解决优化问题的效果。 目标是设置各种参数以优化某些输出。 用更传统的术语来说，我们希望最小化（或最大化）某个函数 $F(X_1,X_2,..., X_M)$。

遗传算法的大多数用户通常关注非线性问题。这通常也意味着不可能将每个参数视为可以独立于其他变量求解的独立变量。 为了最大化或最小化黑盒的输出，必须考虑参数的组合效应。 在遗传算法中，变量之间的相互作用有时被称为上位性。

通常做出的第一个假设是表示参数的变量可以由位串**(bit strings)**表示。 这意味着变量以先验方式离散化，并且离散化的范围对应于 2 的某个幂。例如，对于每个具有10 比特位的参数，我们将会获得具有 1024 个离散值的区间。 如果参数实际上是连续的，那么这种离散化就不是一个特别的问题。 当然，这假设离散化提供了足够的分辨率，以便能够以所需的精度水平调整输出。 它还假设离散化在某种意义上代表了底层函数

如果某些参数只能采用一组精确的有限值，那么编码问题就变得更加困难。 例如，如果恰好有 1200 个离散值可以分配给某个变量 $X_i$，该怎么办？ 我们至少需要 11 位来覆盖这个范围，但是这个代码总共有 2048 个离散值。  848 个不必要的位可能会导致没有评估、默认的最坏评估，或者某些参数设置可能会被表示两次，以便所有二进制字符串都产生一组合法的参数值。 解决此类编码问题通常被认为是评估函数设计的一部分。

除了编码问题，评估函数通常作为问题描述的一部分给出。 另一方面，开发评估函数有时可能涉及开发模拟。 在其他情况下，评估可能基于绩效并且可能仅代表近似或部分评估。 例如，考虑一个控制应用程序，其中系统可以处于指数级的大量可能状态中的任何一种。 假设使用遗传算法来优化某种形式的控制策略。 在这种情况下，必须以有限的方式对状态空间进行采样，并且由此产生的控制策略评估是近似且嘈杂的（参见 Fitzpatrick 和 Grefenstette，1988）。

评估函数也必须相对较快。 对于任何优化方法来说，这通常都是正确的，但它可能对遗传算法尤其造成问题。 由于遗传算法适用于潜在解决方案的群体，因此会产生评估该群体的成本。 此外，种群会在代际基础上（全部或部分）被替换。

种群的成员进行繁殖，然后必须评估它们的后代。 如果做一个评估需要1小时，那么做10000次评估需要1年多。 对于只有 200 个字符串的群体，这将是大约 50 代。

##### 1.2 How Hard is Hard?

假设参数之间的相互作用是非线性的，搜索空间的大小与问题编码中使用的比特数有关。 对于长度为 $L$​ 的位串编码； 搜索空间大小为 $2^L$​，形成一个超立方体。 遗传算法对这个 $L$​ 维超立方体的角进行采样。

通常，大多数测试函数的长度至少为 30 位，大多数研究人员可能会同意需要更大的测试函数。 任何小得多的东西都代表一个可以枚举的空间。  （考虑一下 1993 年美国的国债大约为 $2^{42}$​ 美元，$2^{30}$​ 听起来并没有那么大。）当然，表达式 $2^L$​ 相对于 $L$​ 呈指数增长。考虑编码为 400 位的问题。 关联的搜索空间有多大？ 一本关于人工智能的经典介绍性教科书给出了这种大小空间的一个特征。  Winston (1992:102) 指出，$2^{400}$ 是国际象棋中可能的棋盘配置的搜索空间的有效大小的一个很好的近似值。  （这假设每个可能移动的有效分支因子为 16，并且游戏由 100 个移动组成；$16^{100}$​ = $(2^4)^{100} = 2^{400}$）。温斯顿说这是一个大得离谱的数字。 事实上，如果宇宙中的所有原子自大爆炸（如果有的话）以来一直以皮秒的速度计算国际象棋走法，那么分析才刚刚开始。”

关键是，只要问题的“好的解决方案”的数量相对于搜索空间的大小来说是稀疏的，那么随机搜索或通过枚举大的搜索空间进行搜索就不是解决问题的实用形式 .另一方面，除了随机搜索之外的任何搜索都会在如何寻找更好的解决方案以及它在搜索空间中的位置方面施加一些偏差。遗传算法确实在空间中的哪些新点方面引入了特定的偏差 然而，遗传算法属于人工智能社区中被称为“弱方法”的一类方法，因为它对正在解决的问题做出的假设相对较少。

当然，在数学和运筹学中已经开发了许多优化方法。 遗传算法作为优化工具扮演什么角色？ 遗传算法通常被描述为一种不使用梯度信息的全局搜索方法。 因此，不可微函数以及具有多个局部最优值的函数代表可能应用遗传算法的问题类别。

遗传算法作为一种弱方法，鲁棒但非常通用。 如果针对特定问题存在良好的专门优化方法，那么遗传算法可能不是该应用程序的最佳优化工具。 另一方面，一些研究人员使用混合算法，将现有方法与遗传算法相结合。

#### 2 The Canonical Genetic Algorithm

实现任何遗传算法的第一步是生成初始种群。在规范遗传算法中，这个群体的每个成员都是一个长度为 $L$​ 的二进制字符串，对应于问题编码。 每个字符串有时被称为 "genotype" (Holland, 1975) 或 "chromosome" (Schaer, 1987)。 在大多数情况下，初始种群是随机生成的。 创建初始种群后，然后评估每个字符串并分配一个适应度值。

评估和适应度的概念有时可以互换使用。 但是，区分评估函数和遗传算法使用的适应度函数是有用的。 在本教程中，评估函数或目标函数提供了关于一组特定参数的性能度量。适应度函数将这种绩效衡量转化为生殖机会的分配。表示一组参数的字符串的评估独立于任何其他字符串的评估。 然而，该字符串的适应度总是相对于当前种群的其他成员来定义的。

在规范遗传算法中，适应度定义为： $f_i/ f$ 其中 $f_i$ 是与字符串 $i$ 关联的评估，$f$ 是总体中所有字符串的平均评估。也可以根据字符串在总体中的排名（Baker，1985；Whitley，1989）或通过抽样方法，例如锦标赛选择（Goldberg，1990）来分配适应度。

将遗传算法的执行视为两阶段过程是有帮助的。 它从当前的种群开始。**选择**应用于当前种群以创建中间种群。 然后将**重组和突变**应用于中间种群以创建下一个种群。 从当前种群到下一个种群的过程构成了遗传算法执行中的一代。Goldberg (1989) 将此基本实现称为简单遗传算法 (SGA)。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728125203677.png" alt="image-20210728125203677" style="zoom: 80%;" />

我们将首先考虑从当前种群构建中间种群。 在第一代中，当前种群也是初始种群。 对当前种群中的所有字符串计算 $f_i/\bar{f}$ 后，进行选择。 在规范遗传算法中，当前种群中的字符串被复制（即重复）并放置在中间代中，其概率与其适应度成正比。

有多种方法可以进行选择。 我们可以将总体映射到轮盘赌轮上，其中每个人都由一个与其适应度成比例对应的空间表示。 通过反复旋转轮盘赌轮，使用“有替换的随机抽样”来选择个体以填充中间群体。

更接近于预期适应度值的选择过程是 “remainder” 随机抽样。”对于 $f_i/\bar{f}$​ 大于 $1.0$​ 的每个字符串 $i$​，该数字的整数部分表示该字符串的多少副本被直接放入中间群体。所有字符串（包括那些 $f_i/ \bar{f}$​ 小于 $1.0$​ 的字符串）然后在中间群体中放置额外的副本，其概率对应于 $f_i/\bar{ f}$​ 的小数部分。例如，具有 $f_i/\bar{f}=1.36$​ 的String在中间种群中放置 1 个副本，然后获得 $0.36$​ 放置第二个副本的机会。具有 $f_i/\bar{ f} = 0.54$​ 适应度 的字符串有 0.54 在中间种群中放置一个字符串的机会 

''剩余随机抽样”是使用称为随机通用抽样的方法最有效地实现的。假设人口以随机顺序排列，如饼图，其中每个人在饼图上被分配与适应度成比例的空间 . 接下来，在饼周围放置一个带有 N 个等距指针的外轮盘。轮盘的单次旋转现在将同时选择中间种群的所有 N 个成员。结果选择也是无偏的（Baker，1987）。

选择完成后，中间群体的构建完成，可以进行重组。 这可以看作是从中间种群创建下一个种群。 交叉应用于随机配对的字符串，概率表示为 $p_c$​（随机选择过程应该已经充分地调整了总体）选择一对字符串。 以概率 $p_c$​ 重组这些字符串形成两个新的字符串，插入到下一个群体中。

考虑以下二进制字符串：1101001100101101。该字符串将代表某些参数优化问题的可能解决方案。 空间中的新样本点是通过重新组合两个父字符串生成的。 考虑字符串 1101001100101101 和另一个二进制字符串 yxyyxyxxyyyxyxxy，其中值 0 和 1 由 x 和 y 表示。 使用单个随机选择的重组点，1 点交叉发生如下

![image-20210728210228445](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210228445.png)

在两个父对象之间交换片段会产生以下字段

![image-20210728210251303](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210251303.png)

重组后，我们可以应用变异算子。 对于总体中的每一个字段，它们都会以一些低概率 $p_m$ 变异。 通常，突变率的应用概率小于 1%。 在某些情况下，突变被解释为随机生成一个新位（一个随机的1或者0），也就是说，在这种情况下，只有 50% 的突变会实际改变位值。在其他情况下，突变被解释为意味着实际 ping 位。 只要用户/读者意识到差异并理解第一种形式的变异产生位值变化的频率仅为第二种形式的一半，并且变异的一个版本只是另一个的缩放版本。

在选择、重组和突变过程完成后，可以评估下一个种群。 遗传算法在执行过程中，评估、选择、重组和变异的过程形成一代

##### 2.1 Why does it work? Search Spaces as Hypercubes

大多数刚接触遗传算法领域的人此时会问的问题是，为什么这样的过程应该做任何有用的事情。 为什么要相信这会产生一种有效的搜索或优化形式？

最广泛地解释遗传算法的计算行为的答案来自 John Holland 的工作。 在他 1975 年的经典著作《自然和人工系统中的适应》中，Holland 提出了几个论点，旨在解释 “遗传计划”或“遗传算法”如何通过隐式采样搜索空间的超平面分区来实现复杂而稳健的搜索。

也许理解遗传算法如何对超平面分区进行采样的最好方法是考虑一个简单的 3 维空间（见图 2）。 假设我们有一个仅用 3 位编码的问题； 这可以表示为一个简单的立方体，原点是字符串 000。 这个立方体中的角由位串编号，所有相邻的角由位串标记，位串正好相差 1 位。 图 2 顶部给出了一个示例。立方体的前平面包含所有以 0 开头的点。如果"*" 表示"don't care" 或通配符匹配符号，则该平面也可以由特殊字符串0** 表示。 包含 * 的字符串称为模式（**schema**）； 每个模式对应于搜索空间中的一个超平面。 超平面的”阶数“指的是出现在其模式中的实际位值（指的是不可以变动的数）的数量。因此，1** 是 1 阶，而 $1****1**0**$ 是 3 阶 .

![image-20210728210642314](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728210642314.png)

如果位串可以通过将适当的位值替换为 "*" 符号从超平面中构造出来（指找到一个“共集”），那么位串与特定架构匹配。通常，与特定架构匹配的所有位串都包含在由该架构表示的超平面分区中。每个二进制编码都是一个“染色体”，它对应于超立方体中的一个角，并且是(指的是所有这些拥有同样编码共性的字段) $2^L-1$  个不同超平面的成员，其中 $L$ 是二进制编码的长度。  （所有 * 符号的字符串对应于空间本身，不计为空间的分区（Holland 1975:72））。 这可以通过取一个位串并查看可以用 "*" 符号替换任何位子集的所有可能方式来显示。换句话说，位串中有 $L$ 个位置，每个位置可以是位 包含在字符串或 \*" 符号中的值。

也相对容易看出，可以在整个搜索空间上定义 $3^L-1$  超平面分区。 对于位串中的每个 $L$ 位置，我们可以使用值 *、1 或 0，从而产生 $3^L$ 种组合。

如果孤立地检查搜索空间中的每个点，则确定每个字符串都是 $2^L- 1$ 超平面分区的成员并不能提供太多信息。 这就是为什么基于群体的搜索的概念对遗传算法至关重要。 一组样本点提供了有关众多超平面的信息； 此外，低阶超平面应该由总体中的许多点进行采样。  （在本文的后续部分中更详细地重新研究了这个问题）遗传算法的内在或隐式并行性的一个关键部分来自这样一个事实，即我们可以在评估一组字符串时对许多超平面进行采样（Holland 1975）； 事实上，可以说采样的超平面数量比总体中包含的字符串数量多得多。 每次评估单个字符串时，都会以隐式并行方式评估不同的超平面（Holland 1975:74）； 但它是评估一组点的累积效应，提供有关任何特定超平面子集的统计信息。隐式并行意味着许多超平面竞争同时并行解决。 该理论表明，通过复制和重组过程，竞争超平面的图式根据位于这些超平面分区中的字符串的相对性来增加或减少它们在总体中的表示。

由于遗传算法对字符串群体进行操作，因此可以通过跟踪代表群体中特定超平面的单个模式的比例表示，来指示当基于适合度的选择与交叉结合时，该超平面所代表的种群中的个体数是否会随着时间的推移增加或减少

(注：Holland 最初在其 1975 年的专著中使用术语内在并行性，然后决定改用隐式并行性以避免与并行计算中的术语混淆。 不幸的是，并行计算社区中的术语隐式并行是指从用没有显式并行构造的函数式语言编写的代码中提取的并行性。 隐式并行并不是指在并行硬件上运行遗传算法的潜力，尽管遗传算法通常被视为高度可并行化的算法)

#### 3 Two Views of Hyperplane Sampling

图 3 显示了另一种查看超平面分区的方法。将单个变量上的函数绘制为一维空间，以函数最大化为目标。

超平面 $0****...**$​ 张得空间的前半部分，而 $1****...**$​ 张出空间的后半部分。 由于 $0****...**$​ 分区中的字符串的适合度好于 $1****...**$​ 分区中的字符串，我们希望搜索按比例偏向该分区。 在第二张图中，与 $**1**...**$​ 对应的空间部分被阴影化，这也突出了 $0****...**$​ 和 $**1**...**$​ 的交集 ，即 $0*1*...**$​。最后，在第三张图中，$0*10**...**$ 突出显示。

图 3 的要点之一是超平面分区的采样并没有真正受到局部最优的影响。 同时，与其他竞争分区相比，提高高于平均水平的分区的采样率并不能保证收敛到全局最优。 例如，全局最优可能是一个相对孤立的峰值。

查看一个运行中的简单遗传算法的示例也是一个有用的练习。在表 1 中，明确给出了每个字符串的前 3 位，而未指定其余位位置。 目标是仅查看在前 3 位位置上定义的那些超平面，以便查看根据 适合度复制字符串时在选择阶段实际发生的情况。 遗传算法背后的理论表明，每个超平面中点的新分布应该根据相应超平面分区中包含的种群中字符串的平均适合度变化。因此，即使遗传算法从未明确评估任何特定的超平面分区，它也应该改变字符串副本的分布，就好像它已经如此规定了一样。

![image-20210731141524844](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731141524844.png)

![image-20210731141533144](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731141533144.png)

![image-20210731142003171](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731142003171.png)

表 1：根据等级将适合度分配给字符串的总体。  Random 是一个随机数，它决定是否为适合度的小数余数授予一个字符串的副本

表 1 中的示例总体仅包含 21 个（部分指定的）字符串。 由于我们并不特别关心这些字符串的精确评估，因此将根据等级分配适合度值。（未详细讨论按等级而不是按比例表示分配适合度的概念，但当前示例涉及由于适合度引起的表示变化，而不是如何分配该适合度。）该表包括有关每个字符串适合度的信息和要放置在中间群体中的副本数。 在此示例中，选择期间生成的副本数通过自动分配整数部分来确定，然后通过生成 0.0 和 1.0 之间的随机值（余数随机采样的一种形式）分配小数部分。 如果随机值大于（1-余数）； 然后将额外的副本授予相应的个人。

当选择作用于群体时，遗传算法似乎并行地隐式处理许多超平面. 表 2 列举了 27 个超平面 ($3^3$)，这些超平面可以定义在群体中字符串的前三位，并明确计算与相应超平面分区相关联的适合度。 超平面分区的真实适合度对应于位于该超平面分区中的所有字符串的平均适合度。

遗传算法使用总体作为样本来估计该超平面划分的适合度。 当然，样本只有在第一代期间是随机的。 在此之后，新字符串的样本应该偏向于先前包含的字符串高于先前种群平均适合度水平的区域。

如果遗传算法如我们所描述的那样工作，则选择后实际落在特定超平面分区中的字符串副本数应近似于应落在该分区中的预期副本数。

![image-20210731143935259](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731143935259.png)

表2：明确计算了在第一个三比特位置上定义的27个超平面的样本的平均适合度（Mean）。显示了预期表示（Expect）和观察表示（Obs）。Count指选择前超平面H中的字符串数。

在表 2 中，可以通过将选择前当前总体中超平面样本的数量乘以落入该分区的总体中字符串的平均适合度来计算选择后对超平面分区进行采样的预期字符串数（在上表中即为 "Mean" $\times$ "Count")，上表还给出了选择后实际得到的可观察副本数。 在大多数情况下，预期采样率和观察到的采样率之间的匹配度相当好：误差是由于总体规模较小而导致的抽样误差

开始将跟踪超平面的潜在采样率 $H$​​ 的想法用数学语言表示是有用的。记 $M(H, t)$​ 是当前代 $t$​ 中某个群体中采样 $H$​ (即超平面 $H$ )中所包含的字符串数量。 记 $(t+intermediate)$​ 为第 $t$ 代在选择后（但在交叉和变异之前）的世代，$f(H,t)$ 是当前种群中分区 $H$ 中字符串样本的平均适应度。 因此根据此前的表述，我们得到这个选择后（但在交叉和变异前的）世代中的个体（字符串）数量为：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731161300393.png" alt="image-20210731161300393" style="zoom: 50%;" />

当然，当字符串仅被复制时，实际上不会发生新的超平面采样，因为没有生成新的样本。 从理论上讲，我们希望有一个具有相同分布的新点样本。 在实践中，这通常是不可能的。然而，重组和变异提供了一种生成新样本点的方法，同时部分地保留了在中间群体中观察到的跨超平面的字符串分布

##### 3.1 Crossover Operators and Schemata

表 2 中观察到的超平面表示对应于选择后但重组前的中间群体中的表示。 重组对观察到的字符串分布有何影响？ 显然，1 阶超平面样本不受重组的影响，因为单个关键位总是由后代之一继承。 然而，观察到的来自 2 阶及更高阶超平面分区的潜在样本分布可能会受到交叉的影响。 此外，相同阶的所有超平面不一定以相同的概率受到影响。 考虑单点杂交。 这个重组算子很好，因为它相对容易量化它对表示超平面的不同模式的影响。 为简单起见，假设我们正在处理一个仅用 12 位编码的字符串。 现在考虑以下两个模式

![image-20210731144526380](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731144526380.png)

第一个模式中的位在单点杂交期间被这两个“基因”（指的是字符串中不变的两个点位）被分离的概率仅为 $1/L- 1$​​，因为通常在长度为 $L$​​ 的字符串中存在 $L- 1$​ 个交叉点；而右边的字符串两个基因被分离的概率则为 $(L-1)(这是两个点位之间的间隔数)/(L-1)(字符串中的总间隔数)=1.0$​ ，因此我们观察到：当使用单点杂交时，模式中基因的位置对于确定这些基因在交叉期间保持在一起的可能性很重要

###### 3.1.1  2-point Crossover

如果使用两点杂交算子会发生什么？ 两点杂交算子使用两个随机选择的交叉点，字符串会交换落在这两个点之间的段。  Ken DeJong 首先观察到 (1975)两点杂交将字符串和模式视为形成一个环，这可以说明如下：

![image-20210731144658012](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210731144658012.png)

其中 $b1$​​​​ 到 $b12$​​​ 表示第 $1$​​​ 到 $12$​​ 位。从这种角度来看，单点杂交是两点杂交的一种特殊情况，即对于单点杂交而言，其中一个交叉点总是出现在第一个和最后一个比特之间的环绕位置。 现在，当 2 位位于此环上的互补位置时，会发生 2 阶模式的最大中断。

对于单点和两点杂交，很明显，在字符串编码（或环）上具有靠近在一起的位的模式不太可能被交叉破坏。更准确地说，由具有更紧凑表示的模式表示的超平面应该以更接近于单独选择实现的那些潜在采样分布目标的速率进行采样。 对于当前的目的，关于模式的紧凑表示是最小化交叉期间中断概率的表示。 请注意，此定义依赖于算子，因为在 3.1 节中检查的两个 2 阶模式在 2 点交叉方面具有同等且最大程度的紧凑性，但在 1 点交叉方面存在最大差异。

###### 3.1.2 Linkage and Defining Length

连锁是指一组位作为\coadapted 等位基因"的现象，它们倾向于作为一个集合一起遗传。在这种情况下，等位基因将对应于染色体上特定位置的特定位值。当然， 连锁现象可以看作是关于模式的紧凑表示概念的概括。连锁有时由字符串编码中位的物理相邻性定义；这隐含地假设 1 点交叉是正在使用的运算符。连锁在 2 点交叉下是不同的，当被视为一个环时，必须根据染色体上的距离来定义。然而，链接通常等同于字符串上的物理邻接，通过定义长度来衡量。

模式的定义长度基于模式中第一个和最后一个位之间的距离，值为 0 或 1（即，不是 * 符号）。 鉴于模式中的每个位置都可以是 0、1 或 *，然后从左到右扫描，如果 Ix 是 0 或 1 最右边出现的位置的索引，并且 Iy 是最左边出现的索引 a 0 或 1，则定义长度仅为 Ix precision 表示超平面 H 在这里由 (H) 表示。 定义长度是对有多少可能的交叉点落在图式的重要部分内的直接度量。 如果使用 1 点交叉，则 (H)=L 1 也是交叉在交叉期间落入图式的重要部分的可能性的直接度量。

























































































































































































































































































































































































































































































































