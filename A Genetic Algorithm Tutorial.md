## A Genetic Algorithm Tutorial

本教程涵盖了规范遗传算法以及更多实验形式的遗传算法，包括并行岛模型和并行细胞遗传算法。 本教程还说明了通过超平面采样进行遗传搜索。 回顾了遗传算法的理论基础，包括模式定理以及最近开发的规范遗传算法的精确模型

#### 1 Introduction

遗传算法是一系列受进化启发的计算模型。 这些算法在简单的类似染色体的数据结构上对特定问题的潜在解决方案进行编码，并将重组算子应用于这些结构以保留关键信息。 遗传算法通常被视为函数优化器，尽管遗传算法所应用的问题范围相当广泛。

遗传算法的实现始于一群（通常是随机的）染色体。 然后评估这些结构并以这样一种方式分配繁殖机会，即那些代表目标问题的更好解决方案的染色体比那些较差解决方案的染色体有更多的机会“繁殖”。

解决方案的“优”通常是根据当前种群定义的。这种对遗传算法的特殊描述是有意抽象的，因为在某种意义上，遗传算法这个术语有两个含义。 在严格的解释中，遗传算法是指由 John Holland (1975) 和 Holland 的学生 (e.g., DeJong, 1975) 引入和研究的模型。 大多数现有的遗传算法理论仍然是这样，要么单独或主要适用于 Holland 引入的模型，以及本文中将被称为规范遗传算法的变体。 建模遗传算法的最新理论进展也主要适用于规范遗传算法（Vose，1993）。

在该术语的更广泛用法中，遗传算法是任何基于群体的模型，它使用选择和重组算子在搜索空间中生成新的样本点。研究人员从实验的角度引入了许多遗传算法模型。 这些研究人员中有许多是面向应用的，并且通常对作为优化工具的遗传算法感兴趣。

本教程的目标是以这样一种方式介绍遗传算法，使刚接触该领域的学生可以在学习本教程时掌握遗传算法背后的基本概念。 它应该允许更老练的读者相对容易地吸收这些材料。 本教程还涵盖了一些主题，例如反演，这些主题有时会被该领域的新研究人员误解和误用。

本教程首先对优化进行了非常初级的讨论，以介绍优化的基本思想以及与遗传算法相关的基本概念。 在第 2 节中，回顾了典型的遗传算法。 第 3 节探讨了超平面采样的原理，并介绍了一些基本的交叉算子。 在第 4 节中，模式定理的各种版本逐步发展，并讨论了其他交叉算子。 在第 5 节中考虑了二进制字母及其对超平面采样的影响。 在第 6 节中考虑了对模式定理的简要批评，并在第 7 节中开发了遗传算法的精确模型。 本教程的最后三个部分涵盖了遗传算法和进化计算模型的替代形式，包括专门的并行实现

##### 1.1 Encodings and Optimization Problems

大多数遗传算法中通常只有两个与问题相关的主要元素：问题编码和评估函数。

考虑一个参数优化问题，我们必须优化一组变量以最大化某些目标（例如利润的大小），或者最小化成本或某种误差。 我们可能会将此类问题视为一个黑匣子，其中包含一系列代表不同参数的控制旋钮； 黑盒的唯一输出是评估函数返回的值，该值指示特定参数设置组合解决优化问题的效果。 目标是设置各种参数以优化某些输出。 用更传统的术语来说，我们希望最小化（或最大化）某个函数 $F(X_1,X_2,..., X_M)$。

遗传算法的大多数用户通常关注非线性问题。这通常也意味着不可能将每个参数视为可以独立于其他变量求解的独立变量。 为了最大化或最小化黑盒的输出，必须考虑参数的组合效应。 在遗传算法中，变量之间的相互作用有时被称为上位性。

通常做出的第一个假设是表示参数的变量可以由位串**(bit strings)**表示。 这意味着变量以先验方式离散化，并且离散化的范围对应于 2 的某个幂。例如，对于每个具有10 比特位的参数，我们将会获得具有 1024 个离散值的区间。 如果参数实际上是连续的，那么这种离散化就不是一个特别的问题。 当然，这假设离散化提供了足够的分辨率，以便能够以所需的精度水平调整输出。 它还假设离散化在某种意义上代表了底层函数

如果某些参数只能采用一组精确的有限值，那么编码问题就变得更加困难。 例如，如果恰好有 1200 个离散值可以分配给某个变量 $X_i$，该怎么办？ 我们至少需要 11 位来覆盖这个范围，但是这个代码总共有 2048 个离散值。  848 个不必要的位可能会导致没有评估、默认的最坏评估，或者某些参数设置可能会被表示两次，以便所有二进制字符串都产生一组合法的参数值。 解决此类编码问题通常被认为是评估函数设计的一部分。

除了编码问题，评估函数通常作为问题描述的一部分给出。 另一方面，开发评估函数有时可能涉及开发模拟。 在其他情况下，评估可能基于绩效并且可能仅代表近似或部分评估。 例如，考虑一个控制应用程序，其中系统可以处于指数级的大量可能状态中的任何一种。 假设使用遗传算法来优化某种形式的控制策略。 在这种情况下，必须以有限的方式对状态空间进行采样，并且由此产生的控制策略评估是近似且嘈杂的（参见 Fitzpatrick 和 Grefenstette，1988）。

评估函数也必须相对较快。 对于任何优化方法来说，这通常都是正确的，但它可能对遗传算法尤其造成问题。 由于遗传算法适用于潜在解决方案的群体，因此会产生评估该群体的成本。 此外，种群会在代际基础上（全部或部分）被替换。

种群的成员进行繁殖，然后必须评估它们的后代。 如果做一个评估需要1小时，那么做10000次评估需要1年多。 对于只有 200 个字符串的群体，这将是大约 50 代。

##### 1.2 How Hard is Hard?

假设参数之间的相互作用是非线性的，搜索空间的大小与问题编码中使用的比特数有关。 对于长度为 $L$​ 的位串编码； 搜索空间大小为 $2^L$​，形成一个超立方体。 遗传算法对这个 $L$​ 维超立方体的角进行采样。

通常，大多数测试函数的长度至少为 30 位，大多数研究人员可能会同意需要更大的测试函数。 任何小得多的东西都代表一个可以枚举的空间。  （考虑一下 1993 年美国的国债大约为 $2^{42}$​ 美元，$2^{30}$​ 听起来并没有那么大。）当然，表达式 $2^L$​ 相对于 $L$​ 呈指数增长。考虑编码为 400 位的问题。 关联的搜索空间有多大？ 一本关于人工智能的经典介绍性教科书给出了这种大小空间的一个特征。  Winston (1992:102) 指出，$2^{400}$ 是国际象棋中可能的棋盘配置的搜索空间的有效大小的一个很好的近似值。  （这假设每个可能移动的有效分支因子为 16，并且游戏由 100 个移动组成；$16^{100}$​ = $(2^4)^{100} = 2^{400}$）。温斯顿说这是一个大得离谱的数字。 事实上，如果宇宙中的所有原子自大爆炸（如果有的话）以来一直以皮秒的速度计算国际象棋走法，那么分析才刚刚开始。”

关键是，只要问题的“好的解决方案”的数量相对于搜索空间的大小来说是稀疏的，那么随机搜索或通过枚举大的搜索空间进行搜索就不是解决问题的实用形式 .另一方面，除了随机搜索之外的任何搜索都会在如何寻找更好的解决方案以及它在搜索空间中的位置方面施加一些偏差。遗传算法确实在空间中的哪些新点方面引入了特定的偏差 然而，遗传算法属于人工智能社区中被称为“弱方法”的一类方法，因为它对正在解决的问题做出的假设相对较少。

当然，在数学和运筹学中已经开发了许多优化方法。 遗传算法作为优化工具扮演什么角色？ 遗传算法通常被描述为一种不使用梯度信息的全局搜索方法。 因此，不可微函数以及具有多个局部最优值的函数代表可能应用遗传算法的问题类别。

遗传算法作为一种弱方法，鲁棒但非常通用。 如果针对特定问题存在良好的专门优化方法，那么遗传算法可能不是该应用程序的最佳优化工具。 另一方面，一些研究人员使用混合算法，将现有方法与遗传算法相结合。

#### 2 The Canonical Genetic Algorithm

实现任何遗传算法的第一步是生成初始种群。在规范遗传算法中，这个群体的每个成员都是一个长度为 $L$​ 的二进制字符串，对应于问题编码。 每个字符串有时被称为 "genotype" (Holland, 1975) 或 "chromosome" (Schaer, 1987)。 在大多数情况下，初始种群是随机生成的。 创建初始种群后，然后评估每个字符串并分配一个适应度值。

评估和适应度的概念有时可以互换使用。 但是，区分评估函数和遗传算法使用的适应度函数是有用的。 在本教程中，评估函数或目标函数提供了关于一组特定参数的性能度量。适应度函数将这种绩效衡量转化为生殖机会的分配。表示一组参数的字符串的评估独立于任何其他字符串的评估。 然而，该字符串的适应度总是相对于当前种群的其他成员来定义的。

在规范遗传算法中，适应度定义为： $f_i/ f$ 其中 $f_i$ 是与字符串 $i$ 关联的评估，$f$ 是总体中所有字符串的平均评估。也可以根据字符串在总体中的排名（Baker，1985；Whitley，1989）或通过抽样方法，例如锦标赛选择（Goldberg，1990）来分配适应度。

将遗传算法的执行视为两阶段过程是有帮助的。 它从当前的种群开始。**选择**应用于当前种群以创建中间种群。 然后将**重组和突变**应用于中间种群以创建下一个种群。 从当前种群到下一个种群的过程构成了遗传算法执行中的一代。Goldberg (1989) 将此基本实现称为简单遗传算法 (SGA)。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210728125203677.png" alt="image-20210728125203677" style="zoom: 80%;" />

我们将首先考虑从当前种群构建中间种群。 在第一代中，当前种群也是初始种群。 对当前种群中的所有字符串计算 $f_i/\bar{f}$ 后，进行选择。 在规范遗传算法中，当前种群中的字符串被复制（即重复）并放置在中间代中，其概率与其适应度成正比。

有多种方法可以进行选择。 我们可以将总体映射到轮盘赌轮上，其中每个人都由一个与其适应度成比例对应的空间表示。 通过反复旋转轮盘赌轮，使用“有替换的随机抽样”来选择个体以填充中间群体。

更接近于预期适应度值的选择过程是 “remainder” 随机抽样。”对于 $f_i/\bar{f}$​ 大于 $1.0$​ 的每个字符串 $i$​，该数字的整数部分表示该字符串的多少副本被直接放入中间群体。所有字符串（包括那些 $f_i/ \bar{f}$​ 小于 $1.0$​ 的字符串）然后在中间群体中放置额外的副本，其概率对应于 $f_i/\bar{ f}$​ 的小数部分。例如，具有 $f_i/\bar{f}=1.36$​ 的String在中间种群中放置 1 个副本，然后获得 $0.36$​ 放置第二个副本的机会。具有 $f_i/\bar{ f} = 0.54$​ 适应度 的字符串有 0.54 在中间种群中放置一个字符串的机会 

''剩余随机抽样”是使用称为随机通用抽样的方法最有效地实现的。假设人口以随机顺序排列，如饼图，其中每个人在饼图上被分配与适应度成比例的空间 . 接下来，在饼周围放置一个带有 N 个等距指针的外轮盘。轮盘的单次旋转现在将同时选择中间种群的所有 N 个成员。结果选择也是无偏的（Baker，1987）。

选择完成后，中间群体的构建完成，可以进行重组。 这可以看作是从中间种群创建下一个种群。 交叉应用于随机配对的字符串，概率表示为 $p_c$​（随机选择过程应该已经充分地调整了总体）选择一对字符串。 以概率 $p_c$​ 重组这些字符串形成两个新的字符串，插入到下一个群体中。
   考虑以下二进制字符串：1101001100101101。该字符串将代表某些参数优化问题的可能解决方案。 空间中的新样本点是通过重新组合两个父字符串生成的。 考虑字符串 1101001100101101 和另一个二进制字符串 yxyyxyxxyyyxyxxy，其中值 0 和 1 由 x 和 y 表示。 使用单个随机选择的重组点，1 点交叉发生如下























































































































































































































































































































































































































































































































































































