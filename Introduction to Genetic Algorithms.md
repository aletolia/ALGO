# Introduction to Genetic Algorithms

进化算法的起源是试图模仿自然进化中发生的一些过程。 虽然生物进化的细节还没有完全被理解（即使是现在），但有一些观点得到了强有力的实验证据的支持： • 进化是一个作用于染色体而不是生物体的过程。前者是对生物结构进行编码的有机工具，即一个生物是通过解码一组染色体而“建造”出来的。

 • 自然选择是将染色体与其代表的实体的效率联系起来的机制，从而使适应环境的高效有机体比不适应环境的有机体更频繁地繁殖。
 • 进化过程发生在繁殖阶段。 自然界中存在着大量的繁殖机制。 最常见的是突变（导致后代的染色体与父母的染色体不同）和重组（将父母的染色体结合以产生后代）。

基于上述特征，上述三种进化计算模型是独立（几乎同时）开发的。进化算法 (EA) 是对一组个体（种群）进行操作的迭代和随机过程。 每个人都代表了正在解决的问题的潜在解决方案。 该解决方案是通过编码/解码机制获得的。 最初，种群是随机生成的（也许在构造启发式的帮助下）。 通过适应度函数，种群中的每个个体都被分配了一个衡量其相对于所考虑问题的优度的度量。 该值是算法用来指导搜索的定量信息。

在进化技术中，遗传算法 (GA) 是代表进化工具应用的最广泛的一组方法。 它们依赖于选择、交叉和变异算子的使用。 更换通常是由几代新人进行的。直觉上，遗传算法通过应用非常简单的操作来创造连续几代越来越好的个体。 搜索仅由与种群中每个个体相关联的适应度值指导。 该值用于根据个人对所解决问题的相对适合性对个人进行排名。 问题是每个人负责分配适应度值的适应度函数。

此类技术相对于其他确定性和非确定性程序的位置如下树所示。 下图概述了自然技术在其他众所周知的搜索过程中的情况。

![image-20210804174805168](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804174805168.png)

EA 与爬山算法的组合非常强大。 集中使用这种局部搜索机制的遗传算法被称为模因算法。 并行模型也增加了搜索的扩展性和质量。对于类似的搜索工作，EA 探索与其他搜索技术相比相当不错。 在 EA 中，开发是一个更困难的目标，但现在有许多解决方案可供 EA 细化解决方案。

遗传算法是目前人工生命系统中最突出和使用最广泛的进化计算模型。 这些分散的模型为理解世界上许多其他系统和现象提供了基础。对生命中 GA 的研究给出了说明性示例，其中遗传算法用于研究学习和进化如何相互作用，以及对生态系统、免疫系统、认知系统和社会系统进行建模。

**About the Book**

本书适用于希望学习遗传算法基本概念的广大读者。 它也适用于工作基于优化技术的程序员、研究人员和管理专家。 遗传算法的基本概念通过可用于理解优化过程的相关信息和知识进行了详细处理。 遗传算法运算中涉及的各种算子通过实例进行说明。
 已经以清晰的方式讨论了高级运算符和各种分类，因此初学者可以以最少的努力理解概念。

具体问题的解决方案使用MATLAB 7.0求解并给出解决方案。 还包括 MATLAB GA 工具箱，以方便读者参考，以便他们可以动手使用各种 GA 函数。除了MATLAB解决方案外，还使用C和C++解决了某些问题并给出了解决方案。
   本书旨在提供有关遗传算法的广泛深入的知识。
   本书可作为所有工程学科、管理部门、运筹学领域、计算机应用领域的学生以及在优化领域工作的各种专业人士的手册和指南。

目前，遗传算法是院士、研究人员和程序开发人员的热门话题。 因此，本书不仅适用于学生，也适用于在该领域工作的广大研究人员和开发人员。 本书可作为遗传算法研究学者的现成参考指南。 此处涵盖的各种领域的大多数运算符、分类和应用程序都可以作为高级学术教科书使用。总而言之，我们希望读者会发现这本书是一本有用的指南，也是有关遗传算法概念的几个实际应用的宝贵信息来源。

**1 Organization of the Book**

全书共11章。 它首先介绍了进化计算。 还讨论了各种应用案例研究。
各章组织如下：

• 第 1 章介绍了进化计算、它的发展和它的特性。

• 第 2 章加强了遗传算法的发展及其与其他传统优化技术的比较。 还讨论了基本的简单遗传算法及其优点和局限性。

• 遗传算法中涉及的各种术语和基本算子在第 1 章中讨论。  3. 附例题少，让读者了解遗传算法的基本操作。

• 第 4 章讨论了遗传算法中涉及的高级运算符和技术。

• 遗传算法的不同分类在第 1 章中提供。  5. 与他们的运营商和运营模式讨论每个分类以实现优化解决方案。

• 第 6 章简要介绍了遗传编程。 这里描述了遗传编程及其应用所涉及的步骤和特征。

• 第7 章讨论了各种遗传算法优化问题，包括模糊优化、多目标优化、组合优化、调度问题等。

• 使用MATLAB 实现遗传算法在第1 章讨论。  8.本章提供了工具箱功能和针对特定问题的模拟结果。

• 第9 章给出了使用C 和C++ 实现遗传算法概念。 该实现是针对少数基准问题执行的。

• 遗传算法在各个新兴领域的应用以及案例研究在第 10 章中给出。

• 第11 章简要介绍了粒子群优化和蚁群优化。

文末附有参考书目，供读者参考。

**2 Salient Features of the Book**

## Chapter 1 Evolutionary Computation

### 1.1 Introduction

查尔斯达尔文在 1859 年的进化本质上是一个如此萧条的搜索和优化机制。 达尔文的“适者生存”原则引起了大众的想象。这个原理可以作为引入进化计算的起点。 进化的生物群在各个层面展示了优化的复杂行为：细胞、器官、个体和群体。 生物物种解决了混乱、偶然性、非线性交互性和时间性问题。 这些问题被证明与经典的优化方法是等效的。 进化概念可以应用于不存在启发式解决方案或导致结果不令人满意的问题。 因此，进化算法最近引起了人们的兴趣，特别是对于解决实际问题。

自然选择理论提出，今天存在的植物和动物是数百万年适应环境需求的结果。在任何给定时间，许多不同的生物可能共存并争夺生态系统中的相同资源。 最有能力获取资源并成功繁殖的生物是未来后代趋于众多的生物。 无论出于何种原因，能力较弱的生物体在未来往往很少或没有后代。 前者被认为比后者更适合，而导致前者适合的区别特征被认为是针对后者的特征而选择的。 随着时间的推移，据说生态系统的整个种群进化为包含平均比前几代种群更健康的生物，因为它们表现出更多倾向于促进生存的特征。

进化计算 (EC) 技术将这些进化原理抽象为可用于搜索问题的最佳解决方案的算法。 在搜索算法中，一个问题有许多可能的解决方案，任务是在固定的时间内找到可能的最佳解决方案。 对于只有少量可能解决方案的搜索空间，可以在合理的时间内检查所有解决方案并找到最佳解决方案。 然而，随着搜索空间的增大，这种详尽的搜索很快变得不切实际。

传统的搜索算法一次随机采样（例如，随机游走）或启发式采样（例如，梯度下降）搜索空间一个解，以期找到最优解。 将进化搜索算法与此类传统算法区分开来的关键在于它是基于群体的。 通过大量个体的连续世代的适应，进化算法执行有效的定向搜索。 进化搜索通常比随机搜索更好，并且不易受到基于梯度搜索的爬山行为的影响。

进化计算始于将思想从生物进化理论提升到计算机科学中，并继续寻找新的生物研究发现以寻求灵感。然而，过度热情的“生物学嫉妒”只能通过掩盖更广泛的潜力来损害这两个学科 共享见解和相互类比的双向智力流量。 生物进化的三个基本特征说明了两个社区之间潜在的智力流动范围：微粒基因对生物进化具有一些微妙的影响，这些影响尚未转化为主流 EC； 遗传密码的适应性特性说明了两个社区如何促进对适当的进化抽象的共同理解； 最后，EC 对表征语言的探索似乎是预先适应的，以帮助生物学家理解为什么生命进化出基因型和表型的二分法。

### 1.2 The Historical Development of EC

在进化计算的情况下，有四种历史范式作为该领域大部分活动的基础：遗传算法（Holland，1975）、遗传编程（Koza，1992、1994）、进化策略（Recheuberg，  1973) 和进化规划 (Forgel et al., 1966)。 范式之间的基本区别在于表示方案的性质、复制算子和选择方法。

#### 1.2.1 Genetic Algorithms

进化计算研究中最流行的技术是遗传算法。 在传统的遗传算法中，使用的表示是一个固定长度的位串。 假设字符串中的每个位置代表个体的特定特征，并且存储在该位置的值代表该特征在解决方案中的表达方式。 通常，该字符串被“评估为具有很少或没有交互的解决方案的结构特征的集合”。 这种类比可以直接用于生物有机体中的基因。 每个基因代表一个在结构上独立于其他基因的实体。

使用的主要复制算子是位串交叉，其中两个串用作父母，并通过在两个串之间交换子序列来形成新个体（见图 1.1）。 另一个流行的算子是位翻转突变，其中字符串中的单个位被翻转以形成新的后代字符串（见图 1.2）。 还开发了各种其他运算符，但使用频率较低（例如，反转，其中位串中的子序列被反转）。

不同算子之间的主要区别在于他们是否向总体中引入了任何新信息。 例如，交叉不会，而变异会。 所有运算符也被限制以与基因结构解释一致的方式操作字符串。 例如，两个字符串上相同位置的两个基因可能会在父母之间交换，但不会根据它们的值进行组合。 传统上，根据个体的适应度值概率性地选择个体作为父母，并且创建的后代替换父母。 例如，如果选择了 N 个亲本，则生成 N 个后代来替换下一代的亲本。

![image-20210804185224263](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804185224263.png)

图 1.1 父母 a & b 的位串交叉形成后代 c & d

#### 1.2.2 Genetic Programming

一种越来越流行的技术是基因编程技术。 在标准遗传程序中，使用的表示是一个大小可变的函数和值树。 树中的每个叶子都是来自一组可用值标签的标签。 树中的每个内部节点都是来自一组可用函数标签的标签。

整个树对应于可以评估的单个函数。 通常，树以最左边的深度优先方式进行评估。 叶子被评估为相应的值。 使用作为其子项评估结果的参数对函数进行评估。 遗传算法和遗传编程在大多数其他方面是相似的，除了复制算子是为树表示量身定制的。 最常用的运算符是子树交叉，其中整个子树在两个父级之间交换（见图 1.3）。 在标准的遗传程序中，假定所有值和函数都返回相同的类型，尽管函数的参数数量可能会有所不同。 这个封闭原则（Koza，1994）允许任何子树在结构上被认为与任何其他子树相同，并确保诸如子树交叉之类的算子总是会产生合法的后代。

![image-20210804185304316](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804185304316.png)

图 1.2 亲本 a 的位翻转突变形成后代 b

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805182910830.png" alt="image-20210805182910830" style="zoom:67%;" />



图1.3 亲本a&b子树交叉形成后代c&d

#### 1.2.3 Evolutionary Strategies

在进化策略中，使用的表示是一个固定长度的实值向量。 与遗传算法的位串一样，向量中的每个位置都对应于个体的一个特征。 然而，这些特征被认为是行为性的而不是结构性的。  “因此，在评估过程中，特征之间的任意非线性相互作用是预期的，这迫使采用更全面的方法来发展解决方案”（Angeline，1996）。

进化策略中的主要繁殖算子是高斯突变，其中将来自高斯分布的随机值添加到个体向量的每个元素以创建新的后代（见图 1.4）。 另一个使用的算子是中间重组，其中两个亲本的向量被逐个元素平均在一起，形成一个新的后代（见图 1.5）。 这些算子的效果反映了与表示的结构解释相反的行为，因为向量元素的值的知识用于导出新的向量元素。

与遗传算法和遗传编程相比，选择父母以形成后代的限制更少。 例如，由于表示的性质，很容易对来自许多个体的向量进行平均以形成单个后代。在典型的进化策略中，N 个亲本被均匀随机地选择（即不基于适应度），通过使用重组产生超过 N 个后代，然后确定性地选择 N 个幸存者。 从最好的 N 个后代（即没有父母存活）或从最好的 N 个父母和后代中选择幸存者

![image-20210805183102600](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805183102600.png)

图1.4 亲本a高斯突变形成后代b

![image-20210805183124709](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805183124709.png)

图1.5 亲本a&b中间重组形成后代c

#### 1.2.4 Evolutionary Programming

进化编程采用了将个体表型盟友表示为能够响应环境刺激并开发操作符以随着时间的推移影响结构和行为变化的有限状态机的想法。 这个想法被应用于广泛的问题，包括预测问题、优化和机器学习。

上述特征导致以下观察结果。  GA 从业者很少受限于固定长度的二进制实现。  GP 允许使用可变大小的函数和值树。  ES 从业者已将重组算子纳入他们的系统。  EP 用于有限状态机的演化。

进化编程中使用的表示通常是针对问题域量身定制的。 一种常用的表示是固定长度的实值向量。 进化编程与以前的方法之间的主要区别在于，种群中的个体之间不进行物质交换。 因此，仅使用变异算子。 对于实值向量表示，进化规划与没有重组的进化策略非常相似。典型的选择方法是选择种群中的所有个体作为N个亲本，将每个亲本变异形成N个后代，并根据适应度从总共2N个个体中概率性地选择N个幸存者形成下一代。

### 1.3 Features of Evolutionary Computation

在进化算法中，研究人员选择一种表示方案来定义形成算法搜索空间的一组解决方案。 创建了许多单独的解决方案以形成初始总体。 然后迭代重复以下步骤，直到找到满足预定义终止标准的解决方案。 每个人都使用特定于要解决的问题的适应度函数进行评估。 根据他们的适应度值，选择许多人作为父母。 新个体或后代是使用繁殖算子从这些亲本中产生的。 确定这些后代的适应度值。 最后，从老种群和后代中选出幸存者，形成下一代的新种群。

决定选择哪些和多少父母、创造多少后代以及哪些个体将存活到下一代的机制共同代表了一种选择方法。 文献中提出了许多不同的选择方法，它们的复杂性各不相同。 但是，通常情况下，大多数选择方法可确保每一代的种群大小相同。随着生物研究不断改变我们对进化过程的看法，EC 技术的复杂性和可取性不断增加。

在此背景下，我们介绍生物进化的三个基本特征： 

1. 微粒基因和群体遗传学 

2.  适应性遗传密码

3. 基因型和表型的二分法

   选择每种现象来代表之间可能的关系谱中的一个不同点 计算和生物进化理论。 选择第一个是询问当前的 EC 是否已经完全转移了生物进化的基础。 第二个展示了生物和计算进化理论家如何有助于对进化抽象的共同理解。选择第三个是为了说明一个生物进化问题，EC 似乎比生物学更适合解决这个问题。

#### 1.3.1 Particulate Genes and Population Genetics

当时的主流思想将表型的遗传本质视为一种液体，只要男性和女性相遇就会混合繁殖。 世界上第一位工程学教授弗莱明詹金（Fleming Jenkin，1867 年）指出了混合遗传的数学后果：在有性繁殖生物体中出现的一种新的有利突变会在其通过任何传播途径传播的早期阶段将自身稀释而消失。

这是双亲遗传的一个简单结果。  Mendels 的微粒基因理论 (Mendel, 1866) 用数字系统取代了这种有缺陷的、类似的混合遗传概念，其中基因的有利版本（等位基因）存在或不存在，双亲遗传产生二倍体。

因此，自然选择仅仅改变了群体中等位基因的比例，并且可以选择一个有利的突变进行固定（存在于 100% 的个体内）而不会损失其适应性。 虽然已经有很多关于新达尔文综合论的文章，该综合论确保将孟德尔遗传学与达尔文理论相结合，但在很大程度上，生物学家逐渐接受了，基因的微粒性质本身就为建立关于进化的详细、定量预测提供了坚实的基础

事实上，将种群中基因的数学模型决定为“豆袋遗传学”忽略了从微粒遗传学中得出的逻辑推论的范围。 它们远远超出了对适应性现象的可测试解释，而是深入到生物进化的更深层次、抽象的概念。 例如，微粒基因将随机性引入进化。 由于基因在任何给定的基因组中存在或不存在，有性繁殖种群中每个新个体的基因组成是它从每个亲本继承哪些特定等位基因的概率结果。 除非后代数量无限，否则它们的等位基因频率不会准确反映亲代的频率，而是会显示一些采样错误（遗传漂移）。

这种抽样误差的大小与总体规模成反比。  Wright (1932) 指出，由于实际种群的大小波动，临时减少可以暂时放松选择，可能允许基因库扩散到远离局部最优的足够远的地方，以便在种群规模恢复和选择重新确立时找到新的目的地。 实际上，有限种群中的微粒基因将进化启发式算法从简单的爬山算法改进为更接近波动温度下模拟退火的算法。

在有性种群中运行的微粒基因的最后一个特性值得一提。 在自然选择最有效的大种群中，出现的任何新的有利突变只会在多代过程中达到固定。 在这种传播过程中，重组和二倍体共同确保等位基因会暂时处于许多不同的遗传环境中。

经典种群遗传学（例如，Fisher，1930）和实验性 EC 系统（例如，O'Reilly，1999）关注这种背景是否以及如何促进将基因连接到“共同适应的基因复合体”的选择压力。 一个更简单的观察是，一种新颖的、有利的等位基因产生负面上位效应的潜力是其微进化成功不可或缺的一部分。 概率将有利于固定等位基因，这些基因是优秀的“团队成员”（即，无论遗传背景如何，都可靠地发挥他们的优势。许多主流的 EC 方法简化了新突变的群体遗传学（例如，进入锦标赛），以加快适应过程。 这保留了非混合遗传甚至遗传漂变，但尚不清楚它是否结合了群体遗传学对“prima donna”等位基因的隐式过滤器，这些等位基因仅在其遗传背景如此时才提供其适应性优势。生物学之间的这种基本差异是否 和 EC 有助于我们理解为什么重组似乎在两个系统中扮演如此不同的角色？

#### 1.3.2 The Adaptive Code Book

分子生物学的中心法则通过说明 DNA 转录为 RNA，然后再翻译为蛋白质，将基因与表型联系起来。转录和翻译这两个术语非常直白：RNA 是 DNA 的化学姐妹语言。 两者都是由四个化学字母（核苷酸）组成的字母表形成的聚合物，转录只不过是将 DNA 一个字母一个字母地补充为 RNA 的过程。 下一步是翻译，深刻影响生物进化。 蛋白质也是化学字母的线性聚合物，但它们来自包含 20 个元素的性质不同的字母表（氨基酸）。 显然，没有一对一的映射可以产生将核苷酸明确翻译成氨基酸的遗传密码，到 1966 年，人们知道可能的核苷酸三联体的组合集形成了一个“密码子”字典，每个密码子都翻译成一个氨基酸 意义。 进化理论最初的惊喜是发现像生命密码本这样基本的东西会表现出高度的冗余（4 个 RNA 字母的字母表允许 4×4×4 = 64 个可能的密码子映射到唯一的一个 20 个氨基酸的含义）。 早期的解释引发了非达尔文进化论的争论：对其编码的蛋白质没有影响的遗传变异必须对选择不可见，因此仅受漂移的支配。 最近，计算和生物进化理论都开始将这种编码中立性置于自适应启发式的更大范围内。 从本质上讲，研究结果似乎反映了赖特关于遗传漂移重要性的早期论点：代码中的冗余为适应度景观增加了选择性的中性维度，通过增加局部最优的连通性使自适应算法更有效。

目前，正在对遗传密码的不同适应性特征进行类似的重新解释：观察到生化相似的氨基酸被分配给只有一个核苷酸不同的密码子。 自然选择组织遗传密码以最小化突变的表型影响的早期推测已经获得了相当多的证据支持，因为计算机模拟能够探索自然忽略的理论密码。 然而，在适应性启发式的更广泛背景下，这种现象似乎再次具有更微妙的影响。  “错误最小化代码”实际上可以最大化对两个特征的随机影响定义生物体周围半径圆的概率。

这种突变提高适应度的概率（即，生物体将在白色区域内移动）与其幅度成反比，根据渐变主义的几何理论（图 1.6），突变产生适应度的增加。 对这种现象的初步测试揭示了一个更简单的影响：误差最小化代码使适应度图变得平滑，其中随机遗传代码会使它变得粗糙。 通过在彼此突变范围内聚集生化相似的氨基酸，可以确保针对特定氨基酸特性（例如疏水性）的任何选择都将针对适应性景观的互连区域，而不是孤立的局部最优。

![image-20210805184124210](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805184124210.png)

图 1.6 具有 2 个表型性状的生物体的适应度景观：（a）对于任何生物体，我们可以定义一个等倾线，该等倾线连接所有具有相同适应度的性状组合；  (b)（上面的适应度景观）：具有权衡的大小的随机突变

#### 1.3.3 The Genotype/Phenotype Dichotomy

适应性遗传密码的概念隐含着一个更深层次的问题，生物学在很大程度上仍未回答：为什么所有已知的生命都使用两种性质不同的聚合物，核酸和蛋白质，并且需要相关的翻译？

目前关于这种二分法起源的理论集中在发现 RNA 既可以作为遗传存储介质又可以作为催化分子的发现。 在最高度保守的代谢核心中，发现所有已知的生物体都在我们通常归因于蛋白质的角色中使用 RNA 分子（White，1976）。然而，二分法如何进化的答案在很大程度上掩盖了为什么 RNA 进化出一种性质不同的表型表征的问题。

一个典型的生物学答案是，较大的氨基酸字母表大小为复制子释放了更大的催化多样性，伴随着代谢复杂性的增加，从而优化了自我复制。 有趣的是，我们知道核酸不仅限于我们今天看到的 4 个化学字母：天然代谢活跃的 RNA 利用大量转录后修饰和合成化学，已经证明即使使用今天的基因字母表也可以添加多个额外的核苷酸字母。 细胞机械。 此外，越来越多的间接证据表明，蛋白质字母表本身在生命历史的早期经历了那种进化扩张。

鉴于核酸基因型和蛋白质表型在生命中无处不在，生物学很难评估进化这种“代表性语言”的重要性。 短语的选择是经过深思熟虑的：显然，EC 社区在形式化表征语言的概念和探索它的含义方面远远领先于生物学。 当进化程序员将我们的系统置于他们的发现中时，生物学将会受益，这说明了从 EC 获得生物学灵感的潜力。

### 1.4 Advantages of Evolutionary Computation

进化计算，描述了涉及所有进化算法的研究领域，并为几个优化问题提供了实际优势。 优点包括方法的简单性、对不断变化的环境的稳健响应以及灵活性等。 本节简要介绍了其中的一些优点，并为设计用于解决现实世界问题的进化算法提供了建议。

#### 1.4.1 Conceptual Simplicity

进化计算的一个关键优势是它在概念上很简单。图 1.7 显示了应用于函数优化的进化算法的流程图。该算法包括初始化、迭代变化和根据性能指标进行选择。 特别是，不需要向算法提供梯度信息。 通过随机变化和选择的迭代，可以使总体收敛到最优解。 进化算法的有效性取决于应用于所选表示和初始化的变异和选择算子。

#### 1.4.2 Broad Applicability

进化算法可以应用于任何可以表述为函数优化问题的问题。 为了解决这些问题，它需要一个数据结构来表示解决方案，从旧解决方案中评估解决方案。 人类设计师可以根据他的直觉来选择表示。 表示应该允许变异算子在父母和后代之间保持行为联系。

亲本结构的微小变化会导致后代的微小变化，同样，亲本结构的大变化也会导致后代的剧烈变化。 在这种情况下，开发了进化算法，以便它们以自适应方式进行调整。 这使得进化计算可以应用于广泛的领域，包括离散组合问题、混合整数问题等。

#### 1.4.3 Hybridization with Other Methods

进化算法可以与更传统的优化技术相结合。  这就像使用进化算法在初级搜索之后使用的共轭梯度最小化一样简单。 它还可能涉及算法的同时应用，例如使用对模型结构的进化搜索与对参数值的梯度搜索相结合。 此外，进化计算可用于优化神经网络、模糊系统、生产系统、无线系统和其他程序结构的性能。

#### 1.4.4 Parallelism

进化是一个高度并行的过程。 当分布式处理计算机变得越来越流行并且随时可用时，将进化计算应用于更复杂问题的潜力将会增加。 通常，独立于分配给竞争解决方案的评估来评估单个解决方案。每个解决方案的评估可以并行处理，选择只需要一些串行操作。 实际上，应用程序所需的运行时间可能与处理器数量成反比。 此外，当前的计算机器提供足够的计算速度以在合理的时间内生成对困难问题的解决方案。

#### 1.4.5 Robust to Dynamic Changes

传统的优化方法对环境中的动态变化并不稳健，它们需要完全重启才能提供解决方案。 相反，进化计算可用于使解决方案适应不断变化的环境。进化解的生成种群为进一步改进提供了基础，在许多情况下，没有必要随机重新初始化种群。这种适应动态环境的方法是一个关键优势。

例如，Wielaud (1990) 应用遗传算法来进化递归神经网络来控制由两个杆组成的车杆系统，如图 1.2 所示。在上面的图 1.8 中，目标是将推车保持在轨道限制之间，同时不允许任一杆超过指定的最大偏转角。 此处可用的控制是力，通过该力对推车执行拉动和推动动作。 这里的难点在于极长的相似性。 很少有研究人员使用进化算法来优化神经网络来控制不同极长的植物。

![image-20210805185308788](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805185308788.png)

#### 1.4.6 Solves Problems that have no Solutions

进化算法的优势包括它能够解决没有人类专业知识的问题。 即使在需要和可用时应使用人类专业知识； 它通常证明不太适合自动解决问题的程序。 专家系统存在一些问题：专家可能不同意，可能不合格，可能不一致或可能只是导致错误。 人工智能可能适用于几个需要高计算速度的难题，但它们无法与人类智能竞争，Fogel（1995）将人工智能宣称为“他们解决问题，但他们不解决如何解决问题的问题”。 相比之下，进化计算提供了一种解决问题的方法，即如何解决问题。

#### 1.5 Applications of Evolutionary Computation

在过去的二十年中，进化计算技术作为优化方法引起了很多关注。 从优化的角度来看，进化计算技术的主要优点是它们对优化问题没有太多的数学要求。 他们所需要的只是对目标函数的评估。 因此，它们被应用于非线性问题，定义在离散、连续或混合搜索空间，有约束或无约束。

进化计算的应用包括以下领域： 

   • 医学（例如在乳腺癌检测中）。
   • 工程应用（包括电气、机械、土木、生产、航空和机器人）。
   • 旅行商问题。
   • 机器智能。
   • 专业系统

   • 网络设计和路由 

   • 有线和无线通信网络等。

许多活动涉及难以建模的非结构化现实生活问题，因为它们需要几个不寻常的因素。 某些工程问题本质上是复杂的：作业车间调度问题、时间表、旅行推销员或设施布局问题。 对于所有这些应用，进化计算在优化运行结束时提供了一个接近最优的解决方案。 进化算法因此变得高效，因为它们很灵活，并且相对容易与领域相关的启发式混合。

## Chapter 2 Genetic Algorithms

### 2.1 Introduction

查尔斯·达尔文 (Charles Darwin) 在物种起源中阐述了自然进化论。 经过几代人，生物有机体根据自然选择“适者生存”的原则进化，以完成某些非凡的任务。 信天翁的完美形状与鲨鱼和海豚等的效率和相似性相提并论，是随机进化胜过智能的最好例子。
因此，它在自然界中运作良好，因此模拟自然进化并开发一种解决具体和搜索优化问题的方法应该很有趣。

在自然界中，人口中的个体会相互竞争食物、住所等虚拟资源。 同样在同一物种中，个体会竞争吸引配偶进行繁殖。 由于这种选择，表现不佳的个体生存的机会较少，而最适应或“健康”的个体会产生相对大量的后代。 还可以注意到，在繁殖过程中，每个祖先的良好特征的重组可以产生“最适合”的后代，其适应度大于父代的适应度。 几代之后，物种自发进化，越来越适应它们的环境。

1975 年，Holland 在他的著作《自然和人工系统中的适应》中提出了这个想法。 他描述了如何将自然进化的原理应用于优化问题并构建了第一个遗传算法。  Holland 的理论得到了进一步发展，现在遗传算法 (GA) 已成为解决搜索和优化问题的强大工具。 遗传算法基于遗传学和进化原理。

数学的力量在于技术转移：存在某些模型和方法，可以描述许多不同的现象并解决各种各样的问题。 遗传算法是数学技术转移的一个例子：通过模拟进化，人们可以解决各种来源的优化问题。 今天，GA 被用来解决复杂的优化问题，比如时间表、车间调度、游戏。

#### 2.3 What is Genetic Algorithm?

进化计算是由 I. Rechenberg 在 1960 年代在“进化策略”一书中引入的。 这个想法后来被其他研究开发出来。 遗传算法 (GAs) 是由 John Holland 发明的，并在 1975 年的《自然和人工系统中的适应》一书中发展了这一想法。 Holland 提出了遗传算法作为一种基于“适者生存”的启发式方法。  GA 被发现是解决搜索和优化问题的有用工具

#### 2.3.1 Search Space

大多数情况下，人们正在寻找一组特定解决方案中的最佳解决方案。 所有可行解的空间（期望解所在的解集）称为搜索空间（也称为状态空间）。 搜索空间中的每一个点都代表一种可能的解决方案。 因此，每个可能的解决方案都可以通过其适应值“标记”，具体取决于问题定义。使用遗传算法，可以在搜索空间中由一个点表示的许多可能解决方案中寻找最佳解决方案，即；  GA 用于在搜索空间中搜索最佳解决方案，例如最小值。 这种简化的困难在于局部最小值和搜索的起点（见图 2.6）。

![image-20210805193152590](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805193152590.png)

#### 2.3.2 Genetic Algorithms Worlds

遗传算法提出了几个重要的特征。 首先它是一个随机算法； 随机性在遗传算法中扮演着重要的角色。 选择和繁殖都需要随机程序。 第二个非常重要的点是遗传算法总是考虑解决方案的总体。 在每次迭代中将多个解决方案保留在内存中提供了许多优势。 该算法可以重新组合不同的解决方案以获得更好的解决方案，因此，它可以利用分类的好处。 人口基算法也非常适合并行化。

算法的鲁棒性也应该被提及作为算法成功的必要条件。 稳健性是指在广泛的问题类型上始终如一地表现良好的能力。 在使用 GAs 之前对问题没有特别的要求，因此可以应用它来解决任何问题。 所有这些特性使 GA 成为一个非常强大的优化工具。

随着遗传算法的成功，其他利用自然进化原理的算法也应运而生。 进化策略，遗传编程是那些相似算法中的一些相似之处。 这些不同算法之间的分类并不总是很清楚，因此为了避免混淆，它们都聚集在所谓的进化算法中。

与自然的类比赋予这些算法一些令人兴奋和愉快的东西，它们成功处理广泛问题领域的能力，包括其他方法难以解决的问题，这使它们非常强大。 但是今天，GA 正遭受着太多的潮流。  GAs 是一个新领域，部分理论仍有待完善。 我们可以找到几乎与该领域研究人员一样多的关于 GA 的意见。 遗传算法的发展很快，有些评论在几年内可能不会很准确。

在本介绍中提及 GA 限制也很重要。 像大多数随机方法一样，GA 不能保证找到问题的全局最优解，它们满足于找到问题的“可接受的好”解。  GA 也是非常通用的，因此用于解决特定问题的特定技术很可能在最终结果的速度和准确性方面都优于 GA。 当其他一切都失败或者我们对搜索空间一无所知时，GA 是值得尝试的。 然而，即使存在这样的专业技术，将它们与 GA 混合通常也很有趣，以便可能获得一些改进。 始终保持客观的观点很重要； 不要认为 GA 是解决所有优化问题的灵丹妙药。

此警告适用于那些可能想用 GA 解决任何问题的人。 谚语说：“如果我们有一把锤子，所有的问题看起来都像钉子”。如果将 GA 正确应用于适当的问题，它们确实可以工作并产生出色的结果。

#### 2.3.3 Evolution and Optimization

我们现在是在 4500 万年前研究龙王龙：龙王龙是鲸鱼的原型（图 2.7）。 它长约 15 米，重 5 吨。 它仍然有一个准独立的头部和后爪。 他使用起伏的动作移动并猎杀小型猎物。 它的前部成员被减少为带有肘关节的小鳍状肢。 在这种粘性元素（水）中运动非常困难，需要付出很大的努力。 有关人员必须有足够的能量来移动和控制其轨迹。 龙王的前部成员并不真正适应游泳。 为了适应它们，必须出现双重现象：肘关节锁定时“手臂”的缩短和构成鳍状肢基本结构的手指的伸展（参见图 2.8）。

图像显示普通海豚的两个手指肥大，损害了成员的其余部分。 龙王是猎人，他必须又快又准。 随着时间的推移，受试者的手指更长，手臂更短。 它们可以比以前更快、更精确地移动，因此寿命更长，后代也很多。

同时，其他关于空气动力学的改进也发生了，比如头部与身体的整合，轮廓的改善，尾鳍的加强。  .  . 最终产生了一个完全适应水环境限制的主题。 这种适应过程，这种形态优化是如此完美，以至于如今，鲨鱼、海豚或潜艇之间的相似性是惊人的。 但第一个是起源于泥盆纪（–4 亿年）的软骨鱼（Chondrichtyen），早在第一个鲸类下降的哺乳动物出现之前

![image-20210805194613904](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805194613904.png)

![image-20210805194619875](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805194619875.png)

达尔文机制因此产生优化过程，鱼类和其他海洋动物的流体动力学优化，翼手龙、鸟类或蝙蝠的空气动力学优化。 这个观察是遗传算法的基础

#### 2.3.4 Evolution and Genetic Algorithm

来自密歇根大学的 John Holland 于 60 年代初开始研究遗传算法。 第一个成就是 1975 年出版的《自然和人工系统适应》一书。Holland 有两个目标：提高对自然适应过程的理解，以及设计具有类似于自然系统特性的人工系统。

基本思想如下：给定种群的遗传库可能包含给定适应性问题的解决方案或更好的解决方案。 这个解决方案不是“主动”的，因为它所依赖的基因组合被分成几个主题。 只有不同基因组的关联才能导致解决方案。

简单地说，我们可以举例认为，我们龙王的爪子的缩短和手指的伸展是由两个“基因”控制的。没有受试者有这样的基因组，但在繁殖和交叉过程中，会出现新的基因组合，最后，受试者可以从父母双方那里继承一个“好基因”：他的爪子现在是鳍状肢。

Holland 方法特别有效，因为他不仅考虑了变异的作用（变异很少改进算法），而且还利用了遗传重组，（交叉）：这些重组，部分解的交叉极大地提高了算法的逼近能力 ，并最终找到最优值。

重组或有性繁殖是自然进化的关键操作符。从技术上讲，它需要两种基因型，并通过混合原始基因中的基因来产生新的基因型。 在生物学中，最常见的重组形式是交叉，将两条染色体在一处切割，然后将两半拼接起来以产生新的染色体。 重组的效果非常重要，因为它允许来自两个不同亲本的特征进行分类。 如果父亲和母亲拥有不同的好品质，我们会期望所有的好品质都会传给孩子。 因此，后代只要结合其父母的所有优点，就可能超越其祖先。 许多人认为，通过有性繁殖混合遗传物质是遗传算法最强大的特征之一。 作为关于有性生殖的快速括号，遗传算法表示通常不区分男性和女性个体（没有任何变态）。 与许多生物物种（例如蜗牛）一样，任何个体都可以是雄性或雌性。 事实上，对于几乎所有的重组算子来说，母亲和父亲都是可以互换的。

突变是获得新基因组的另一种方式。 突变在于改变基因的价值。 在自然进化中，突变大多会产生无生命力的基因组。 实际上，变异在自然进化中并不是一个非常频繁的算子。

然而，在优化方面，一些随机变化可以成为快速探索搜索空间的好方法。通过遗传的那些低级概念，我们已经看到了生物如何存储他们的特征信息以及这些信息如何传递给他们的后代。 它非常基础，但足以理解遗传算法理论。

达尔文完全不了解遗传学的生化基础。 现在我们知道遗传信息是如何在 DNA、RNA 和蛋白质中编码的，并且编码原理实际上是数字化的，非常类似于计算机中的信息存储。 然而，信息处理在许多方面完全不同。 被称为物种进化的壮观现象也可以让人们对信息处理方法和优化有一些了解。 根据达尔文主义，遗传变异具有以下特性： 

1.  变异必须是复制，因为选择不直接创造任何东西，但前提是有大量人口可以工作。

   2. 在实践中变化必须是小规模的。 物种不会突然出现。
   3. 变化是无方向的。 这也被称为盲人制表师范式。
      一个多世纪以来，自然科学的进化方法一直是分析和研究进化的不同方面以找到基本原理，而工程科学则乐于应用经过数十亿年严格测试的进化原理来攻击 最复杂的技术问题，包括蛋白质折叠。

### 2.4 Conventional Optimization and Search Techniques

优化的基本原则是稀缺资源的有效配置。优化可以应用于任何科学或工程学科。 优化的目的是找到一种算法来解决给定的一类问题。不存在解决所有优化问题的特定方法。 考虑一个函数， 

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805195607423.png" alt="image-20210805195607423" style="zoom:67%;" />

其中

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805195624896.png" alt="image-20210805195624896" style="zoom:67%;" />

对于上面的函数，$f$​ 可以通过减小 $\epsilon$​ 或者通过使 [$x^l,x^u$] 的区间变大来保持。 因此，一项艰巨的任务可以变得更容易。 因此，可以通过结合人类的创造力和计算机的原始处理能力来解决优化问题。

各种可用的常规优化和搜索技术讨论如下：

#### 2.4.1 Gradient-Based Local Optimization Method（基于梯度的局部优化方法）

当目标函数平滑且需要有效的局部优化时，最好使用基于梯度或基于 Hessian 的优化方法。 不同梯度方法的性能和可靠性差异很大。为了讨论基于梯度的局部优化，让我们假设一个平滑的目标函数（即连续的一阶和二阶导数）。 目标函数表示为，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805195815345.png" alt="image-20210805195815345" style="zoom:67%;" />

一阶导数包含在梯度向量 $∇ f(x)$ 中

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805195843429.png" alt="image-20210805195843429" style="zoom:67%;" />

目标函数的二阶导数包含在 Hessian 矩阵 $H(x)$ 中。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805195909432.png" alt="image-20210805195909432" style="zoom:67%;" />

很少有方法只需要梯度向量，但在牛顿法中，我们需要 Hessian 矩阵。

梯度方法中使用的通用伪代码如下：

选择一个初始猜测值 $x^1$​ 并设置 $n=1$。
   重复从下面的 (2.5) 或 (2.6) 中求解搜索方向 $p^n$。
   使用下面的 (2.7) 确定下一个迭代点：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805200033391.png" alt="image-20210805200033391" style="zoom:67%;" />

n=n+1

直到 $||X^n-X^{n-1}||<\epsilon$

这些梯度方法搜索最小值而不是最大值。 根据算法的细节获得了几种不同的方法。

共轭梯度法中的搜索方向 $P^n$ 为： 

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805200228453.png" alt="image-20210805200228453" style="zoom:67%;" />

割线法

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805200247462.png" alt="image-20210805200247462" style="zoom:67%;" />

用于寻找搜索方向。  (2.2) 中的矩阵 $B_n$ 估计了 Hessian。矩阵 $B_n$ 在每次迭代中更新。当 $B_n$ 被定义为恒等矩阵时，最速下降法出现。 当矩阵 $B_n$ 是 Hessian H(xn) 时，我们得到牛顿法。

搜索步长度 $λ_n$ 使用以下方法计算：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805200412674.png" alt="image-20210805200412674" style="zoom:67%;" />

讨论的是一个一维优化问题。最速下降法的性能很差。 因此，可以使用共轭梯度法。 如果二阶导数容易计算，那么牛顿法可能会提供最好的结果。 割线方法比共轭梯度方法快，但会出现内存问题。

因此，这些局部优化方法可以与其他方法相结合，以获得性能和可靠性之间的良好联系。

#### 2.4.2 Random Search

随机搜索是一种极其基本的方法。 它仅通过随机选择解决方案并评估其适应度来探索搜索空间。 这是一种相当愚蠢的策略，很少单独使用。 尽管如此，这种方法有时值得一试。 实施它不需要太多努力，并且可以相当快地完成大量评估。 对于新的未解决问题，将更高级算法的结果与仅通过随机搜索相同数量的评估获得的结果进行比较可能会很有用。 例如，在比较遗传算法与随机搜索时，很可能会出现令人讨厌的惊喜。 请记住，GA 的效率极其依赖于一致的编码和相关的复制操作符。 构建一个遗传算法，它执行的只是随机搜索，发生的频率超出了我们的预期。如果复制算子只是产生新的随机解决方案，而与上一代选择的解决方案没有任何具体联系，那么遗传算法只是随机搜索而已。

随机搜索确实有一些有趣的特性。 不管得到的解有多好，如果它不是最优解，它总是可以通过继续运行随机搜索算法足够长的时间来改进。 随机搜索永远不会卡在任何点，例如局部最优。 此外，理论上，如果搜索空间有限，则保证随机搜索达到最优解。 不幸的是，这个结果完全没有用。 对于我们感兴趣的大多数问题，探索整个搜索空间需要很长时间。

#### 2.4.3 Stochastic Hill Climbing(随机爬山)

对于表现良好的连续适应度函数的问题，存在有效的方法。这些方法使用一种梯度来引导搜索方向。 随机爬山是这些类型中最简单的方法。 每次迭代包括在当前解决方案的邻域中随机选择一个解决方案，并且只有在改进适应度函数时才保留这个新解决方案。 如果问题的适应度函数是连续的并且只有一个峰值（单峰函数），则随机爬山会向最优解收敛。

在具有许多峰值的函数（多峰函数）上，算法可能会在它找到的第一个峰值处停止，即使它不是最高的峰值。 一旦达到峰值，爬山就不能再进行了，当这个点是局部最优时，这是有问题的。 随机爬山通常从随机选择点开始。避免陷入第一个局部最优的一个简单想法是每次从随机选择的不同点开始重复几次爬山。 这种方法有时被称为迭代爬山。 通过发现不同的局部最优点，它有更多的机会达到全局最优。 如果搜索空间中没有太多局部最优值，则效果很好。 但如果适应度函数非常“嘈杂”，有很多小山峰，随机爬山绝对不是一个好用的方法。 然而，这种方法具有非常容易实施并且非常快速地给出相当好的解决方案的巨大优势。

#### 2.4.4 Simulated Annealing(模拟退火)

模拟退火最初是受到冷却过程中固体晶体形成的启发，即物理冷却现象。 铁器时代的铁匠很久以前就发现，冷却越慢，形成的晶体就越完美。通过冷却，复杂的物理系统自然会收敛到最低能量的状态。 系统随机移动，但保持在特定配置中的概率直接取决于系统的能量和温度。吉布斯定律正式给出了这个概率： 

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805200720045.png" alt="image-20210805200720045" style="zoom:67%;" />

其中 $E$ 代表能量，$k$ 是玻尔兹曼常数，$T$ 是温度。

在 70 年代中期，柯尔帕特里克通过类比这些物理现象首次对模拟退火进行了描述。
 与随机爬山一样，模拟退火的迭代包括在实际解的邻域内随机选择一个新解。 如果新解的适应度函数优于当前解的适应度函数，则新解被接受为新的当前解。 如果适应度函数没有改进，新的解决方案以以下的概率保留 

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805200803036.png" alt="image-20210805200803036" style="zoom:67%;" />

其中 $f (y) − f (x)$ 是新旧解之间适应度函数的差异。

模拟退火的行为类似于爬山方法，但可能会下坡以避免陷入局部最优。 当温度高时，解恶化的概率相当重要，然后很多大的动作就有可能探索搜索空间。 温度降低得越多，下坡就越困难，算法尝试从当前解爬升以达到最大值。 当温度较低时，可以利用当前的解决方案。 如果温度太低，则接受数字恶化，该算法的行为就像随机爬山方法。 通常，模拟退火从高温开始，并呈指数下降。 冷却越慢，就越有利于找到好的解决方案。 甚至已经证明，在无限缓慢冷却的情况下，该算法几乎肯定会找到全局最优值。 唯一的一点是无限慢在于找到合适的温度下降率以获得算法的良好行为。

通过混合探索特征（如随机搜索）和开发特征（如爬山）的模拟退火通常会产生相当好的结果。 模拟退火是遗传算法的有力竞争者。 值得尝试比较每个获得的结果。 两者都源自与自然系统进化的类比，并且都处理相同类型的优化问题。  GAs 有两个主要特征，这应该使它们更高效。  First GAs 使用基于群体的选择，而 SA 在每次迭代中只处理一个个体。 因此，GA 预计在每次迭代时覆盖更大的搜索空间，但另一方面，SA 迭代要简单得多，因此通常要快得多。  GA 的巨大优势在于其出色的并行化能力，而 SA 并没有获得太多的并行化能力。 这主要是由于GA使用的人口计划。 其次，GAs 使用重组算子，能够混合来自不同解决方案的良好特征。 重组算子的利用被认为有助于找到问题的最佳解决方案

另一方面，模拟退火实现起来仍然非常简单，而且效果很好。 他们已经证明了他们在解决大量难题上的效率，例如印刷电路板的最佳布局或著名的旅行商问题。 遗传退火是近年来发展起来的，是将遗传算法和模拟退火相结合的一种尝试。

#### 2.4.5 Symbolic Artificial Intelligence (AI)

大多数符号 AI 系统都是非常静态的。 他们中的大多数通常只能解决一个给定的特定问题，因为他们的架构首先是为任何特定问题而设计的。 因此，如果给定的问题以某种方式被改变，这些系统可能很难适应它们，因为最初到达解决方案的算法可能不正确或效率较低。 创建遗传算法（或 GA）来解决这些问题。 它们基本上是基于自然生物进化的算法。 实现遗传算法（或 GA）的系统架构更能适应广泛的问题。

### 2.5 A Simple Genetic Algorithm

算法是解决问题的一系列步骤。 遗传算法是一种使用遗传学作为其解决问题模型的问题解决方法。 这是一种寻找优化和搜索问题近似解的搜索技术。

基本上，优化问题看起来非常简单。 人们知道对应于特定问题的所有可能解决方案的形式。 满足这种形式的所有解的集合构成了搜索空间。 问题在于从所有可能的解决方案中找出最适合的解决方案，即收益最高的解决方案。 如果可以快速列举所有的解决方案，这个问题不会引起太大的困难。 但是，当搜索空间变大时，枚举很快就不再可行，因为它会花费太多时间。 在这种情况下，需要使用特定的技术来找到最佳解决方案。

遗传算法提供了这些方法之一。 实际上，它们都以类似的方式工作，使简单的遗传学适应算法机制。GA 处理大量可能的解决方案。 每个解决方案都通过一个染色体来表示，这只是一个抽象的表示。 将所有可能的解决方案编码到染色体中是第一部分，但肯定不是遗传算法中最直接的部分。 还必须确定一组复制运算符。 复制算子直接应用于染色体，用于对问题的解决方案进行突变和重组。 适当的表示和复制运算符确实是决定性的，因为 GA 的行为极其依赖于它。

通常，要找到一种表示，它尊重搜索空间和再现算子的结构，根据问题的性质，它们是连贯的和相关的。选择应该能够比较种群中的每个个体。选择是通过使用适应度函数完成的。 每条染色体都有一个关联值，对应于它所代表的解的适应度。 适应度应该对应于对候选解决方案的好坏程度的评估。 最优解是最大化适应度函数的那个。 遗传算法处理最大化适应度函数的问题。 但是，如果问题在于最小化成本函数，那么适应就很容易了。 要么可以将成本函数转换为适应度函数，例如通过反转它； 或者可以以这样的方式调整选择，使他们认为具有低评估功能的个人更好。

一旦正确定义了繁殖和适应度函数，遗传算法就会根据相同的基本结构进化。 它首先生成初始染色体群。 第一个种群必须提供广泛多样的遗传材料。 基因库应该尽可能大，以便可以生成搜索空间的任何解决方案。 通常，初始种群是随机生成的。然后，遗传算法在迭代过程中循环以使种群进化。 每次迭代包括以下步骤：

• 选择：第一步是选择个体进行繁殖。
这种选择是随机进行的，概率取决于个体的相对适应度，因此通常选择最好的而不是差的进行繁殖。

• 繁殖：在第二步中，后代由选定的个体繁殖。为了产生新的染色体，该算法可以同时使用重组和变异。

• 评估：然后评估新染色体的适应度。

• 替换：在最后一步，旧种群中的个体被杀死并被新种群取代。当总体向最优解收敛时，算法停止。

基本的遗传算法如下： 

• [开始] n 条染色体的遗传随机种群（问题的合适解） 

• [适应度] 评估种群中每条染色体 $x$ 的适应度 $f(x)$​ 

• [新种群] 创建一个新的 通过重复以下步骤直到新种群完成来种群 - [选择] 根据它们的适应度从种群中选择两个父染色体（适应度越好，被选中的机会就越大）。

   - [交叉] 以交叉概率，交叉父母形成新的后代（孩子）。 如果没有进行交叉，后代就是父母的精确副本。
   - [突变] 以突变概率，在每个基因座（染色体中的位置）突变新后代 - [接受] 将新后代放入新种群中。

   • [替换] 使用新生成的种群进一步求和算法。
   • [Test] 如果满足结束条件，则停止并返回当前种群中的最佳解决方案。
   • [循环] 转到步骤2 进行适合度评估。

遗传算法过程通过图2.9中的GA循环来讨论。繁殖是将两个或多个亲本的遗传物质结合以获得一个或多个后代的过程。 在适应度评估步骤中，评估个人的质量。 对一个人进行突变以产生它的新版本，其中一些原始遗传材料已被随机改变。 选择过程有助于决定使用哪些个体进行繁殖和变异，以产生新的搜索点。GA 过程的流程图如图 2.10 所示。

在实现 GA 之前，重要的是要了解设计通用搜索算法的一些指南，即基于适应度景观的属性和最常见的优化方法类型的全局优化算法：

1. 确定性：纯确定性搜索可能在解决方案质量方面具有极高的差异，因为它可能很快陷入最坏的情况，由于其确定性而无法逃脱。 这是可以避免的，但众所周知的事实是，通常不能保证观察到最坏情况。
2. 不确定性：随机搜索方法通常不会遇到上述潜在的最坏情况“狼陷”现象。 因此，搜索方法很可能应该是随机的，但它很可能包含很大一部分确定性。 原则上，具有尽可能多的不确定性就足以避免最坏情况的狼陷阱。

![image-20210805232309326](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805232309326.png)

![image-20210805232325083](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210805232325083.png)

3. 局部决定论：纯随机方法通常很慢。 因此，对（本地）程序的最有希望的方向进行尽可能多的有效确定性预测是合理的。 根据明显的策略，这称为局部爬山或贪婪搜索。基于前面的讨论，GA 方法的重要标准可以表述如下
4. - 完整性：任何解决方案都应该有它的编码 -
   - 非冗余：代码和解决方案应该一一对应 - 
   - 健全性：任何代码（由遗传算子产生）应该有其对应的解决方案 - 
   - 特性毅力：后代应该从父母那里继承有用的特性。

简而言之，简单遗传算法解决问题的基本四个步骤是： 

1. 问题的表示 
2. . 适应度计算
3. 控制算法所涉及的各种变量和参数 
4. 结果的表示和方式 终止算法

#### 2.6 Comparison of Genetic Algorithm with Other Optimization Techniques

GAs 的原理很简单：通过计算机程序模仿遗传学和自然选择：问题的参数被最自然地编码为类似 DNA 的线性数据结构、向量或字符串。 有时，当问题自然是二维或三维时，也会使用相应的数组结构。

这些问题相关参数值向量的一组称为种群由 GA 处理。 首先，通常有一个完全随机的群体，即由随机数生成器生成的不同参数的值。 典型的人口规模从几十到几千不等。 为了进行优化，我们需要一个成本函数或适应度函数，因为在使用遗传算法时通常会调用它。 通过适应度函数，我们可以从总体中选择最佳解决方案候选并删除不太好的样本。

将 GA 与其他优化方法进行比较时的好处是，适应度函数几乎可以是计算机可以评估的任何东西，甚至可以是计算机无法评估的东西！ 在后一种情况下，它可能是人类的判断，不能说是一个清晰的程序，就像在目击者的情况下，人类在 GA 生成的替代方案中进行选择。

因此，对适应度函数的性质没有任何明确的数学限制。 它可以是离散的、多模态的等。用于对优化算法进行分类的主要标准如下：连续/离散、约束/无约束和顺序/并行。 离散问题和连续问题之间有明显的区别。 因此，注意到连续方法有时用于解决固有的离散问题，反之亦然是有益的。 并行算法通常用于加速处理。 但是，在某些情况下，并行而不是顺序运行多个处理器更有效。 这些情况包括其中每个单独的搜索运行很可能陷入局部极值的情况。

不考虑上述分类，优化方法可以进一步分为确定性和非确定性方法。 此外，优化算法可分为局部或全局。 在能量和熵方面，局部搜索对应于熵，而全局优化本质上取决于适应度，即能量景观。

遗传算法在以下方面与传统优化技术不同： 

1. GA 使用问题参数的编码版本而不是参数本身进行操作，即 GA 使用解决方案集的编码而不是解决方案本身。

  2. 几乎所有传统的优化技术都是从单个点搜索，但 GA 总是对整个点（字符串）群体进行操作，即，GA 使用解决方案的群体而不是单个解决方案进行搜索。 这对遗传算法的鲁棒性起着重要作用。 它提高了达到全局最优的机会，也有助于避免局部静止点。
  3. GA 使用适应度函数进行评估而不是导数。 因此，它们可以应用于任何类型的连续或离散优化问题。 这里要执行的关键点是识别和指定有意义的解码函数。
 4. GAs 使用概率转换操作，而用于连续优化的传统方法应用确定性转换操作，即 GAs 不使用确定性规则。
      这些是遗传算法和传统优化技术之间存在的主要区别 

### 2.7 Advantages and Limitations of Genetic Algorithm

遗传算法的优点包括： 

1. 并行性 
2. 责任性 
3. 解空间更广 
4. 适应度景观复杂 
5. 容易发现全局最优 
6. 问题具有多目标函数 
7. 仅使用函数评估。
8. 针对不同问题轻松修改。

   9. 处理嘈杂的功能。
      10. 可以轻松处理大的、难以理解的搜索空间 
      11. 适用于多模态问题 返回一套解决方案。
      12. 对目标函数评估中的困难非常健壮。
      13. 它们不需要关于响应曲面的知识或梯度信息 
      14. 响应曲面上存在的不连续性对整体优化性能几乎没有影响 
      15. 它们不会陷入局部最优

16. 它们在大规模优化问题上表现非常好 
17. 可用于各种优化问题

遗传算法的局限性包括： 

1. 适应度函数的识别问题 
2. 问题表示的定义 
3. 过早收敛 
4. 选择种群大小、变异率、交叉率等各种参数的问题 ，选择方法及其强度。

   5. 不能使用渐变。
   6. 不能轻易地结合问题的具体信息 
      7. 不擅长识别局部最优 
      8. 没有有效的终结者。
      9. 对平滑单峰函数无效 
      10. 需要结合局部搜索技术。
      11. 难以找到精确的全局最优值 
      12. 需要大量响应（适应度）函数评估 
      13. 配置并不简单

### 2.8 Applications of Genetic Algorithm

遗传算法已被用于解决困难问题（例如 NP 难题）、机器学习以及进化简单程序。 它们也被用于一些艺术，用于不断发展的图片和音乐。  GA 的一些应用如下： 

• 非线性动力系统——预测、数据分析 

• 机器人轨迹规划 • 进化 LISP 程序（遗传编程）

• 策略规划 • 寻找蛋白质分子的形状 

• TSP 和序列调度 

• 用于创建图像的功能 

• 控制——气体管道、杆平衡、导弹躲避、追踪 

• 设计——半导体布局、飞机设计、键盘配置、通信网络 

• 调度——制造、设施调度、资源分配 

• 机器学习——设计神经网络，包括架构和权重，改进 分类算法、分类器系统 

• 信号处理 – 滤波器设计 • 组合优化 – 集合覆盖、旅行商 (TSP)、序列调度、路由、装箱、图着色和分区

## Chapter 3 Terminologies and Operators of GA

### 3.1 Introduction

遗传算法使用一个比喻，其中优化问题代替环境，可行的解决方案被视为生活在该环境中的个体。 在遗传算法中，个体是二进制数字或从有限集合中提取的一些其他符号集合。 由于计算机内存是由位数组组成的，因此任何东西都可以存储在计算机中，也可以由足够长的位串进行编码。 根据问题的特定解决方案的适当编码，群体中的每个编码个体都可以被视为一种表示。 为了让遗传算法找到最佳解决方案，必须对这些个体执行某些操作。 本章讨论遗传算法中使用的基本术语和运算符，以便为可能的终止条件获得足够好的解决方案。

### 3.2 Key Elements

GA 中的两个不同元素是个体和群体。 个体是单个解，而种群是当前参与搜索过程的个体集合

### 3.3 Individuals

一个人是一个单一的解决方案。 个人将两种形式的解决方案组合在一起，如下所示： 

1. 染色体，这是遗传算法处理的原始“遗传”信息（基因型）。

   2. 表型，这是染色体在模型方面的表现。

染色体被细分为基因。 基因是遗传算法对控制因子的单个因子的表示。 解集中的每个因子对应于染色体中的基因。 图 3.1 显示了基因型的表示。

染色体应该以某种方式包含有关它所代表的解决方案的信息。 形态发生功能将每个基因型与其表型相关联。**它只是意味着每个染色体必须定义一个唯一的解决方案，但并不意味着每个解决方案都由一个染色体编码**。 事实上，形态发生函数不一定是双射的，有时甚至是不可能的（尤其是二进制表示）。 尽管如此，形态发生函数至少应该是主观的。 的确; 问题的所有候选解必须对应至少一个可能的染色体，以确保可以探索整个搜索空间。 当将每条染色体与一个解相关联的形态发生函数不是单射时，即不同的染色体可以编码相同的解，则称该表示是退化的。

即使算法寻找最优解的空间不可避免地被扩大，轻微的退化也不是那么令人担忧。 但过于重要的退化可能是一个更严重的问题。 它会严重影响 GA 的行为，主要是因为如果几个染色体可以代表相同的表型，那么每个基因的含义显然不会对应于解决方案的特定特征。 它可能会在搜索中增加某种混乱。

染色体由位串编码，如下图 3.2 所示，

![image-20210806001611469](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806001611469.png)

### 3.4 Genes

基因是构建通用算法的基本“指令”。 染色体是基因序列。 基因可能描述了一个问题的可能解决方案，但实际上并不是解决方案。 基因是任意长度的位串。 位串是从下限开始的间隔数的二进制表示。 基因是遗传算法对控制因子的单个因子值的表示，其中控制因子必须有上限和下限。 这个范围可以分为基因位串可以表达的区间数。 长度为“$n$​​”的位串可以表示 $(2n-1)$​ 个区间。 间隔的大小将是$（范围）/（2n-1）$。

每个基因的结构在表型参数记录中定义。表型参数是基因型和表型之间映射的说明。也可以说是将解集编码为染色体，将染色体解码为解集。 基因型和表型之间的映射对于将模型中的解决方案集转换为遗传算法可以使用的形式，以及将遗传算法中的新个体转换为模型可以评估的形式是必要的。 在染色体中，基因表示为（图 3.3）：

### ![image-20210806001919245](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806001919245.png)3.5 Fitness

个体在遗传算法中的适应度是其表型的目标函数值。 为了计算适应度，必须首先解码染色体并评估目标函数。 适应度不仅表示解的好坏，还对应于染色体与最优解的接近程度。

在多准则优化的情况下，适应度函数肯定更难确定。 在多准则优化问题中，如何确定一种解决方案是否优于另一种解决方案通常存在两难选择。 如果一个解决方案对一个标准更好但对另一个标准更差，应该怎么做？ 但在这里，问题更多地来自“更好”解决方案的定义，而不是如何实施 GA 来解决它。 如果有时通过不同标准的简单组合获得的适应度函数可以给出良好的结果，则假设标准可以以一致的方式组合。 但是，对于更高级的问题，考虑优化帕累托之类的东西或多准则优化理论中的其他想法可能会很有用。

### 3.6 Populations

种群是个体的集合。 一个群体由许多被测试的个体、定义个体的表型参数和一些关于搜索空间的信息组成。 遗传算法中使用的种群的两个重要方面是： 

1. 初始种群生成。
2. 人口规模。

对于每个问题，人口规模将取决于问题的复杂性。 它通常是进行种群的随机初始化。 在二进制编码染色体的情况下，这意味着每个位都被初始化为随机的零或一。 但是可能存在使用一些已知好的解决方案进行种群初始化的情况。

理想情况下，第一个种群应该有一个尽可能大的基因库，以便能够探索整个搜索空间。 每个人的所有不同可能的等位基因都应该存在于群体中。 为了实现这一点，在大多数情况下，初始种群是随机选择的。 然而，有时可以使用一种启发式方法来播种初始种群。 因此，种群的平均适应度已经很高，它可以帮助遗传算法更快地找到好的解决方案。 但是为了做到这一点，应该确保基因库仍然足够大。 否则，如果种群严重缺乏多样性，算法只会探索搜索空间的一小部分，永远找不到全局最优解。

人口规模也不会引起什么问题。 人口越多，探索搜索空间就越容易。 但是已经确定 GA 收敛所需的时间是 $O (nlogn)$ 次函数评估，其中 $n$ 是总体规模。 当所有的个体都非常相似时，我们说种群已经收敛，进一步的改进可能只有通过突变才有可能。

Goldberg 还表明，达到全局最优而不是局部最优的 GA 效率在很大程度上取决于种群的大小。 综上所述，大量人口是非常有用的。 但它需要更多的计算成本、内存和时间。 实际上，大约 100 个人的人口规模是相当频繁的，但无论如何，与要达到的结果的质量相比，这个规模可以根据时间和机器上配置的内存进行更改。

由各种染色体组合而成的种群如图 3.4 所示，因此上述种群由 4 条染色体组成。

![image-20210806002301666](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806002301666.png)

### 3.7 Data Structures

GA 中的主要数据结构是染色体、表型、目标函数值和适应度值。 当使用 MATLAB 包作为数值工具时，这特别容易实现。 给定个体数量及其基因型表示的长度，可以将整个染色体群体存储在单个数组中。 类似地，通过将染色体表示中的一些映射应用到设计空间中而获得的设计变量或表型可以存储在单个数组中。 实际映射取决于所使用的解码方案。 目标函数值可以是标量或向量，并且必须与适应度值相同。 适应度值是使用缩放或排序函数从对象函数导出的，并且可以存储为向量。

### 3.8 Search Strategies

搜索过程包括初始化种群，然后繁殖新个体，直到满足终止条件。 搜索过程可以有多个目标，其中之一是找到全局最优值。 对于 GA 使用的模型类型，这永远无法保证。 搜索中的下一次迭代总是有可能产生更好的解决方案。 在某些情况下，搜索过程可能会运行数年，并且不会产生比第一次小迭代更好的解决方案。

另一个目标是更快的收敛。当目标函数的运行成本很高时，需要更快的收敛，但是，收敛到局部最优值的机会增加，并且可能非常不合标准。

除此之外，另一个目标是产生一系列多样化但仍然很好的解决方案。 当解空间包含几个不同的最优值时，它们的适应度相似，能够在它们之间进行选择是有用的，因为模型中因子值的某些组合可能比其他组合更可行。 此外，某些解决方案可能比其他解决方案更稳健。

### 3.9 Encoding

编码是表示单个基因的过程。 该过程可以使用位、数字、树、数组、列表或任何其他对象来执行。 编码主要取决于解决问题。 例如，可以直接编码实数或整数。

#### 3.9.1 Binary Encoding

最常见的编码方式是二进制串，如图 3.5 所示 每个染色体编码一个二进制（位）串。 字符串中的每一位都可以代表解决方案的一些特征。 因此，每个位串都是一个解决方案，但不一定是最佳解决方案。 另一种可能性是整个字符串可以表示一个数字。 位串编码的方式因问题而异。

二进制编码提供了许多可能的染色体，但等位基因数量较少。 另一方面，这种编码对于许多问题来说并不自然，有时必须在遗传操作完成后进行更正。 主要使用带有 1 和 0 的二进制编码字符串。 字符串的长度取决于准确性。

在这方面， • 整数被精确表示 • 可以表示有限数量的实数 • 表示的实数数量随着字符串长度的增加而增加

#### 3.9.2 Octal Encoding（八进制编码）

此编码使用由八进制数 (0–7) 组成的字符串。

#### 3.9.3 Hexadecimal Encoding

此编码使用由十六进制数字 (0–9, A–F) 组成的字符串。

#### 3.9.4 Permutation Encoding (Real Number Coding)

每条染色体都是一串数字，依次代表数字。有时需要在基因操作完成后进行修正。 在置换编码中，每条染色体都是一串整数/实数值，代表序列中的数字 

![image-20210806003048494](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806003048494.png)

置换编码仅对排序问题有用。 即使对于某些类型的交叉和突变校正问题，也必须使染色体保持一致（即，其中具有真实序列）。

#### 3.9.5 Value Encoding

每条染色体都是一串值，这些值可以是与问题相关的任何东西。 这种编码对一些特殊问题产生了最好的结果。 另一方面，通常需要针对问题开发新的遗传算子。 直接值编码可用于使用一些复杂值（如实数）的问题。 对此类问题使用二进制编码将非常困难。

在值编码中，每条染色体都是一些值的字符串。 值可以是任何与问题、形式数字、实数或一些复杂对象的字符相关的东西。

![image-20210806003304482](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806003304482.png)

值编码对于一些特殊问题非常有用。 另一方面，对于这种编码，通常需要针对该问题开发一些新的交叉和变异

#### 3.9.6 Tree Encoding

这种编码主要用于遗传编程的进化程序表达式。每个染色体都是一些对象的树，例如编程语言的函数和命令

### 3.10 Breeding

育种过程是遗传算法的核心。 正是在这个过程中，搜索过程创造了新的、希望更健康的人。
   繁殖周期包括三个步骤： 

a. 选择父母。
b. 跨越父母创造新的个体（后代或孩子）。
c.用新个体替换种群中的旧个体。

#### 3.10.1 Selection

选择是从种群中选择两个亲本进行杂交的过程。在决定了编码之后，下一步是决定如何进行选择，即如何选择种群中的个体来为下一代创造后代，以及每个个体将创造多少后代。 选择的目的是强调种群中更健康的个体，希望他们的后代具有更高的适应性。 从初始种群中选择染色体作为亲本进行繁殖。 问题是如何选择这些染色体。 根据达尔文的进化论，最好的人会存活下来创造新的后代。

图 3.10 显示了基本的选择过程。

![image-20210806010432135](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806010432135.png)

选择是一种根据染色体的评价函数从种群中随机挑选染色体的方法。 适应度函数越高，个体被选中的机会就越大。 选择压力被定义为更优秀的个体受到青睐的程度。 选择压力越大，越好的个体受到青睐。 这种选择压力驱使 GA 提高连续几代的种群适应度。

GA 的收敛速度很大程度上取决于选择压力的大小，选择压力越大，收敛速度越高。遗传算法应该能够在明智的选择方案压力范围内确定最佳或接近最佳的解决方案。 但是，如果选择压力太低，收敛速度会很慢，GA 会花费不必要的时间来寻找最优解。 如果选择压力太高，GA 的变化会增加，过早地收敛到不正确的（次优）解决方案。 除了提供选择压力外，选择方案还应保持种群多样性，因为这有助于避免过早收敛。

通常我们可以区分两种类型的选择方案，比例选择和基于顺序的选择。 基于比例的选择根据个体相对于群体中其他个体的适应度的适应度值来挑选个体。 基于序数的选择方案不是根据他们的原始适应度来选择个人，而是根据他们在群体中的排名。 这就要求选择压力与种群的适应度分布无关，完全基于种群的相对排序（排序）。

也可以使用缩放函数重新分配种群的适应度范围，以适应选择压力。 例如，如果所有解决方案的适应度都在 [999, 1000] 范围内，那么使用基于比例的方法选择比任何其他解决方案更好的个体的概率将不重要。 如果每个个体的适应度都公平地达到 [0, 1] 范围内，那么选择好个体而不是坏个体的概率将很重要。

选择必须与变异形式的交叉和突变相平衡。 过强的选择意味着次优的高度适合的个体将接管种群，减少变革和进步所需的多样性； 选择太弱会导致进化太慢。 各种选择方法讨论如下：

##### 3.10.1.1 Roulette Wheel Selection

轮盘赌选择是传统的 GA 选择技术之一。 常用的再生算子是比例再生算子，其中以与适应度成正比的概率从交配池中选择一个字符串。 轮盘赌选择的原则是通过轮盘赌轮进行线性搜索，轮盘上的槽的权重与个人的适应度成比例。 设定目标值，它是总体中适应度总和的随机比例。

逐步通过总体直到达到目标值。 这只是一种中等强度的选择技术，因为不能保证选择合适的个人，但在某种程度上有更大的机会。 一个合适的个体对目标值的贡献会更大，但如果不超过它，那么下一条染色体就有机会，它可能很弱。 人口不能按适应度排序是很重要的，因为这会极大地偏向选择。

上述轮盘赌过程也可以解释如下：个体的期望值是适应度除以种群的实际适应度。每个人都被分配了一块轮盘赌，这块的大小与个人的是一个都成正比。 轮子旋转 N 次，其中 N 是种群中的个体数量。 在每次旋转时，轮子标记下的个体被选为下一代的父母池。

该方法的实现方式如下： 

1. 对种群中个体的总期望值求和。 让它成为T。
  2.重复N次： 

  i. 在 o 和 T 之间选择一个随机整数“r”。
  ii. 循环遍历种群中的个体，对期望值求和，直到总和大于或等于‘r’。 其期望值使总和超过此限制的个人是被选中的人。

  轮盘选择更容易实现，但嘈杂。 进化速度取决于种群中适应度的方差

##### 3.10.1.2 Random Selection

这种技术从群体中随机选择一个父母。 就遗传密码的破坏而言，平均而言，随机选择比轮盘选择更具破坏性。

##### 3.10.1.3 Rank Selection

当适应度值相差很大时，轮盘就会出现问题。如果最佳染色体适应度为 90%，则其周长占据轮盘的 90%，然后其他染色体被选中的机会太少。  Rank Selection 对种群进行排序，每条染色体都从排序中获得适应度。

最差的适应度为 1，最好的适应度为 N。这会导致收敛缓慢但防止收敛过快。 当适应度方差较低时，它还可以保持选择压力。 它保留了多样性，从而导致成功的搜索。实际上，选择了潜在的父母并举行了一场比赛来决定哪些人将成为父母。 有很多方法可以实现这一点，两个建议是： 

1. 随机选择一对个体。 生成一个介于 0 和 1 之间的随机数 R。如果 R < r，则使用第一个个体作为父母。 如果 R>=r 则使用第二个个体作为父母。 重复此操作以选择第二个父项。  r 的值是此方法的参数。

   2. 随机选择两个人。 评价最高的个体成为父母。 重复以找到第二个父级。

##### 3.10.1.4 Tournament Selection

理想的选择策略应该能够调整其选择压力和种群多样性，从而微调 GA 搜索性能。 与轮盘选择不同，锦标赛选择策略通过在 $N_u$ 个个体之间举行锦标赛比赛来提供选择压力。 比赛中最好的个人是身体素质最高的人，即 $N_u$ 的获胜者。 锦标赛比赛和获胜者然后被插入到交配池中。 比赛重复进行，直到产生新后代的交配池被填满。 由锦标赛获胜者组成的交配池具有更高的平均种群适应度。 适应度差异提供了选择压力，促使遗传算法提高后继基因的适应度。这种方法更有效，并导致最佳解决方案。

##### 3.10.1.5 Boltzmann Selection

模拟退火是一种函数最小化或最大化的方法。 该方法模拟熔融金属缓慢冷却的过程，以在最小化问题中实现最小函数值。 控制以玻尔兹曼概率分布概念引入的类似温度的参数模拟了冷却现象。

在玻尔兹曼选择中，连续变化的温度根据预设时间表控制选择速率。 温度开始高，这意味着选择压力低。 温度逐渐降低，这逐渐增加了选择压力，从而在保持适当的多样性程度的同时，允许遗传算法更靠近搜索空间的最佳部分。

发现对数降低的温度有助于收敛，而不会陷入局部最小值状态。 但是将系统冷却到平衡状态需要时间。

令 $f_{max}$​ 为当前可用的最佳字符串的适应度。 如果下一个字符串的适应度 $f(X_i)$​ 使得 $f(X_i)>f_{max}$，则选择新字符串。 否则以 Boltz Mann 概率选择，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806011743468.png" alt="image-20210806011743468" style="zoom:67%;" />

其中 $T = T_o(1-α)^k$​​​ 且 $k = (1 + 100∗g/G)$​​；  $g$​​ 是当前代号；  G，g 的最大值。  $α$​​ 的值可以在 $[0, 1]$​ 范围内选择，$T_o$​ 可以在 $[5, 100]$ 范围内选择。 当计算接近 $T$ 的零值时达到最终状态，即在此时获得全局解。

选择最佳字符串并将其引入交配池的概率非常高。 然而，精英主义可用于消除突变阶段任何不希望的信息丢失的机会。 此外，执行时间更少。

**精英主义**

第一个最好的染色体或少数最好的染色体被复制到新的种群中。其余部分以经典方式完成。 如果没有选择这些个体进行繁殖，或者如果交叉或突变破坏了他们，这些个体可能会丢失。 这显着提高了 GA 的性能

##### 3.10.1.6 Stochastic Universal Sampling.

随机通用抽样提供零偏差和最小传播。 个体被映射到一条线的连续段，这样每个个体的段的大小与其在轮盘赌选择中的适应度完全相同。 这里等距的指针放置在线上，与要选择的个人一样多。 考虑 NPointer 是要选择的个体数量，那么指针之间的距离为 1/NPointer，第一个指针的位置由 [0, 1/NPointer] 范围内随机生成的数字给出。
   对于要选择的 6 个个体，指针之间的距离为 1/6=0.167。
   图 3.11 显示了上述示例的选择。
   [0, 0.167] 范围内 1 个随机数的样本：0.1。
   选择后交配种群由个体组成

#### 3.10.2 Crossover (Recombination)

交叉是采用两个父解决方案并从中产生子解决方案的过程。 在选择（繁殖）过程之后，种群中会出现更好的个体。 复制会克隆好的字符串，但不会创建新的字符串。 将交叉算子应用于交配池，希望它能产生更好的后代。

Crossover 是一个重组算子，分三步进行：

​    i. 繁殖操作员随机选择一对两个单独的串进行配对。
   ii. 沿着字符串长度随机选择一个交叉站点。
  iii. 最后，位值在交叉点之后的两个字符串之间交换。

也就是说，最简单的方法是随机选择一些交叉点并从第一个父节点复制该点之前的所有内容，然后从另一个父节点复制交叉点之后的所有内容。 各种交叉技术讨论如下：

##### 3.10.2.1 Single Point Crossover

传统的遗传算法采用单点交叉，将交配的两条染色体在对应点切一次，切后的切片交换。

在这里，沿着匹配串的长度随机选择交叉站点或交叉点，并交换交叉站点旁边的位。 如果选择合适的地点，结合好父母可以得到更好的孩子，否则会严重影响字段的质量。
上面的图 3.12 说明了单点交叉，可以观察到交叉点旁边的位被交换以产生子节点。 交叉点可以随机选择。

##### ![image-20210806012136926](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806012136926.png)3.10.2.2 Two Point Crossover

除了单点交叉之外，还设计了许多不同的交叉算法，通常涉及多个切点。 应该注意的是，添加更多的交叉点会降低 GA 的性能。 添加额外交叉点的问题是构建块更有可能被破坏。但是，具有更多交叉点的优点是可以更彻底地搜索问题空间。

在两点交叉中，选择两个交叉点，并在两个交配的父母之间交换这些点之间的内容。

![image-20210806012227168](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806012227168.png)

在上面的图 3.13 中，虚线表示交叉点。 因此，这些点之间的内容在父母之间交换，以产生新的孩子以供下一代交配。

最初，GA 使用一点交叉，将两条染色体剪成一点，然后将两半拼接起来以创建新的染色体。 但是通过这种单点交叉，一条染色体的头部和尾部不能一起传递给后代。 如果一条染色体的头部和尾部都包含良好的遗传信息，那么通过单点交叉直接获得的后代都不会共享这两个良好的特征。 使用 2 点交叉避免了这个缺点，因此通常被认为比 1 点交叉更好。 事实上，这个问题可以推广到染色体中的每个基因位置。 靠近染色体的基因有更多机会一起传递给通过 N 点交叉获得的后代。 它导致彼此相邻的基因之间出现不需要的相关性。 因此，N 点交叉的效率将取决于基因在染色体内的位置。 在遗传表示中，编码解的依赖特征的基因应该靠近在一起。为了避免基因位点的所有问题，最好使用统一交叉作为重组算子。

##### 3.10.2.3 Multi-Point Crossover (N-Point crossover)

这种交叉有两种方式，一种是偶数跨站，另一种是奇数跨站。 在偶数个跨站的情况下，围绕一个圆圈随机选择跨站并交换信息。 在奇数个交叉点的情况下，总是在字符串开始处假设一个不同的交叉点。

##### 3.10.2.4 均匀交叉

均匀交叉与 N 点交叉有很大不同。 后代中的每个基因都是通过从根据随机生成的与染色体相同长度的二进制交叉掩码选择的一个或另一个亲本中复制相应基因来创建的。 如果交叉掩码中有 1，则该基因是从第一个亲本复制的，如果掩码中有 0，则该基因是从第二个亲本复制的。 为每对父母随机生成一个新的交叉掩码。 因此，后代包含来自每个亲本的基因混合物。 有效交叉点的数量不是固定的，而是平均L/2（其中L是染色体长度）。

在图 3.14 中，使用统一交叉方法产生新的孩子。 可以注意到，在生产子 1 时，当掩码中有 1 时，基因从父 1 复制，否则从父 2 复制。 在生产子 2 时，当掩码中有 1 时，基因 从父 2 复制，当掩码中有 0 时； 该基因是从父母 1 复制的

![image-20210806012938814](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806012938814.png)

##### 3.10.2.5 Three Parent Crossover

在这种交叉技术中，随机选择三个父母。 将第一个父项的每个位与第二个父项的位进行比较。 如果两者相同，则为后代取该位；否则； 来自第三个父母的比特被用于后代。 这个概念如图 3.15 所示。

![image-20210806013031083](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806013031083.png)

##### 3.10.2.6 Crossover with Reduced Surrogate

减少的代理操作符限制交叉以尽可能地产生新的个体。 这是通过限制交叉点的位置来实现的，这样交叉点只出现在基因值不同的地方。

##### 3.10.2.7 Shuffle Crossover

Shuffle 交叉与均匀交叉有关。 选择了单个交叉位置（如单点交叉）。 但是在交换变量之前，它们在父母双方中随机打乱。 重组后，后代中的变量未打乱。 这消除了位置偏差，因为每次执行交叉时都会随机重新分配变量。

##### 3.10.2.8 Precedence Preservative Crossover (PPX)

PPX 是由 Blanton 和 Wainwright (1993) 独立开发的用于车辆路径问题和 Bierwirth 等人的调度问题。  (1996)。 运算符以相同的速率将两个亲本排列中给出的操作的优先关系传递给一个后代，而没有引入新的优先关系。
   对于由六个操作 A-F 组成的问题，PPX 如下所示。
   运算符的工作原理如下： • 长度为 Sigma 的向量，sub i=1 到 mi，表示问题中涉及的操作数，随机填充集合 {1, 2} 的元素。
   • 此向量定义了从父项 1 和父项 2 连续绘制操作的顺序。
   • 我们还可以将父代和后代的排列视为列表，为其定义了“追加”和“删除”操作。
   • 首先，我们从初始化一个空后代开始。
   • 根据向量中给定的父级顺序选择两个父级之一中最左边的操作。
   • 选择操作后，它会在父项中删除。
   • 最后将选定的操作附加到后代。
   • 重复此步骤，直到双亲都为空并且后代包含所有涉及的操作。
   • 请注意，由于使用了“deletionappend”方案，PPX 不能以统一交叉方式工作。 示例如图 3.16 所示。

##### 3.10.2.9 Ordered Crossover

当问题是基于顺序的问题时，使用有序两点交叉，例如在 U 形装配线平衡等中。给定两个父染色体，选择两个随机交叉点将它们划分为左、中和右部分。 有序两点交叉的行为如下：子1从父1继承其左右部分，其中间部分由父1中间部分的基因按照值出现在父中的顺序决定 2. 应用类似的过程来确定子 2。如图 3.17 所示

##### 3.10.2.10 Partially Matched Crossover (PMX) 

PMX 可以有效地应用于 TSP。 实际上，TSP 染色体只是整数序列，其中每个整数代表不同的城市，顺序代表访问城市的时间。 在这种称为置换编码的表示下，我们只对标签感兴趣，而不对等位基因感兴趣。 它可以被看作是一种排列的交叉，它保证在每个后代中所有位置都只被发现一次，即两个后代都接收到完整的基因，然后是来自其父母的相应等位基因的填充。
   PMX 进行如下： 1. 两条染色体对齐。
   2. 沿字符串随机均匀选择两个交叉位点，定义匹配部分 • 匹配部分用于通过逐位交换操作实现交叉 • 等位基因移动到后代中的新位置 • 以下 说明了 PMX 的工作原理。
      • 考虑图 3.18 中所示的两个字符串 • 其中，点标记选定的交叉点。
      • 匹配部分定义了双亲必须发生的位置交换以产生后代。
      • 交换从一条染色体的匹配部分读取到另一条染色体的匹配部分。
      • 在示例中，交换位置的数字是 5 和 2、6 和 3、7 和 10。
      • 产生的后代如图3.19 PMX 将在下一章详细讨论。

##### 3.10.2.11 Crossover Probability

交叉技术的基本参数是交叉概率（Pc）。
   交叉概率是描述执行交叉频率的参数。
   如果没有交叉，后代就是父母的精确副本。 如果有交叉，后代是由父母双方染色体的一部分组成的。 如果交叉概率为 100%，则所有后代都是通过交叉产生的。 如果它是 0%，则整个新一代是由旧种群染色体的精确拷贝构成的（但这并不意味着新一代是相同的！）。 进行交叉是希望新染色体将包含旧染色体的良好部分，因此新染色体会更好。 然而，让一部分老年人存活到下一代是好的。

#### 3.10.3 Mutation

交叉后，对字符串进行变异。 变异可以防止算法陷入局部最小值。 突变起着恢复丢失的遗传物质以及随机干扰遗传信息的作用。 它是针对遗传材料不可逆转损失的保险单。  Mutation 传统上被认为是一种简单的搜索运算符。 如果交叉应该利用当前的解决方案来寻找更好的解决方案，那么变异应该有助于探索整个搜索空间。 突变被视为维持种群遗传多样性的背景算子。 它通过随机修改其一些构建块在种群中引入新的遗传结构。 突变有助于摆脱局部最小值的陷阱并保持种群的多样性。 它还使基因库储备充足，从而确保遍历性。 如果从任何种群状态产生任何解的概率不为零，则称该搜索空间是遍历的。
   对于不同类型的表示，有许多不同形式的变异。
   对于二进制表示，一个简单的突变可以包括以小概率反转每个基因的值。 概率通常取大约 1/L，其中 L 是染色体的长度。 也可以实现一种爬山变异算子，这些算子只有在提高解决方案的质量时才进行变异。 这样的操作符可以加速搜索。 但是应该小心，因为它也可能会降低种群的多样性并使算法向某些局部最优收敛。 位的突变涉及翻转位，将 0 更改为 1，反之亦然。

##### 3.10.3.1 Flipping

位翻转涉及根据生成的突变染色体将 0 更改为 1 和将 1 更改为 0。
   图 3.20 解释了突变翻转的概念。 考虑父母并随机生成突变染色体。 对于突变染色体中的 1，将父染色体中的相应位翻转（0 到 1 和 1 到 0）并产生子染色体。 在上述情况下，突变染色体的3个位置出现1个，父染色体中的相应位被翻转，产生子染色体。

![image-20210806013338341](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806013338341.png)

##### 3.10.3.2 Interchanging

选择字符串的两个随机位置，并交换与这些位置对应的位。 如图 3.21 所示。

![image-20210806013406590](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806013406590.png)

##### 3.10.3.3 Reversing

选择一个随机位置，并反转该位置旁边的位并产生子染色体。 如图 3.22 所示。

![image-20210806013436156](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806013436156.png)

##### 3.10.3.4 Mutation Probability

变异技术中的重要参数是变异概率（Pm）。突变概率决定了染色体部分突变的频率。
如果没有突变，则在交叉（或直接复制）后立即生成后代，没有任何变化。 如果进行突变，染色体的一个或多个部分会发生变化。 如果突变概率为 100%，则整个染色体被改变，如果为 0%，则什么都没有改变。 突变通常可以防止 GA 陷入局部极端。 变异不应该经常发生，因为那样GA实际上会变成随机搜索

#### 3.10.4 Replacement

更替是任何繁殖周期的最后阶段。 两个父母从一个固定大小的种群中抽取，他们繁殖了两个孩子，但不是所有四个都能回到种群中，所以必须更换两个，即一旦产生了后代，必须有一种方法来确定当前种群中的哪一个成员 ，如果有的话，应该被新的解决方案取代。 用于决定哪个个体留在种群中以及哪个个体被替换的技术，与影响收敛的选择相同。 基本上，有两种维持人口的方法； 世代更新和稳态更新。
   基本的世代更新方案包括从大小为 N 的种群中产生 N 个子代以在下一个时间步长（世代）形成种群，并且这个新的子代种群完全取代了父选择。 显然，这种更新意味着一个人只能与同一代人一起繁殖。 还使用派生形式的代更新，如 (λ + μ)-update 和 (λ, μ)-update。 这次从大小为 μ 的父种群中，产生了一些大小为 λ ≥ μ 的子代。 然后来自后代种群或组合的父代和后代种群（分别为 (λ, μ)- 和 (λ + μ)-update）的 μ 个最佳个体形成下一代。
   在稳态更新中，新个体一创建就被插入到种群中，而不是在每个时间步产生一个全新的世代的世代更新。 一个新个体的插入通常需要更换另一个种群成员。 可以选择要删除的个体作为群体中最差的成员。  （这会导致非常强的选择压力），或者作为人口中最老的成员，但这些方法非常激进：通常稳态更新使用基于序数的方法进行选择和替换，通常是锦标赛方法。 锦标赛替换与锦标赛选择完全相似，只是不太好的解决方案比好的解决方案更频繁地被选择。 一个微妙的替代方案是替换现有群体中最相似的成员。

##### 3.10.4.1 Random Replacement

孩子们替换了群体中随机选择的两个个体。 父母也是选择的候选人。 这对于在小群体中继续搜索很有用，因为可以将弱个体引入到群体中。

##### 3.10.4.2 Weak Parent Replacement

在弱父母替换中，较弱的父母被强大的孩子取代。四个个体中，只有最合适的两个，父母或孩子，返回群体。 当与选择适合和弱父母进行杂交的选择技术配对时，该过程提高了种群的整体适应度，但是如果弱个体并且在选择中受到歧视，则将永远不会增加替换它们的机会。

##### 3.10.4.3 Both Parents

父母双方更换很简单。 孩子取代了父母。 在这种情况下，每个人只能繁殖一次。 因此，种群和遗传物质会四处移动，但当与一种强烈有利于健康父母的选择技术相结合时会导致问题：健康的品种然后被处理掉。

### 3.11 Search Termination (Convergence Criteria)

简而言之，各种停止条件如下： • 最大代数——当指定的代数进化时，遗传算法停止。
   • 经过的时间——经过指定的时间后，遗传过程将结束。
   注意：如果在指定时间过去之前已达到最大生成数，则该过程将结束。
   • 适应度无变化——如果种群在指定世代数内的最佳适应度没有变化，则遗传过程将结束。
   注意：如果在指定的代数之前已达到最大代数且未达到任何更改，则该过程将结束。
   • Stall 代——如果对于一系列长度为Stall 代的连续代的目标函数没有改进，则算法停止。
   • 停顿时间限制——如果在等于停顿时间限制的秒数时间间隔内目标函数没有改进，则算法停止。
   终止或收敛标准最终使搜索停止。 以下是几种终止技术的方法。

#### 3.11.1 Best Individual

一旦群体中的最小适应度下降到收敛值以下，最佳个体收敛标准就会停止搜索。 这使搜索更快地得出结论，保证至少有一个好的解决方案。

#### 3.11.2 Worst individual

当群体中最不适合的个体的适应度小于收敛标准时，最差个体终止搜索。 这保证了整个种群都达到最低标准，尽管最好的个体可能不会比最差的个体好得多。 在这种情况下，可能永远不会满足严格的收敛值，在这种情况下，搜索将在超过最大值后终止。

#### 3.11.3 Sum of Fitness

在该终止方案中，当整个种群的适应度之和小于或等于种群记录中的收敛值时，认为搜索满足收敛。 这保证了群体中几乎所有的个体都将在特定的适应度范围内，尽管最好将此收敛标准与最弱的基因替换配对，否则群体中的一些不合适的个体将超出适应度总和。 在设置收敛值时必须考虑种群大小。

#### 3.11.4 Median Fitness

这里至少有一半的个体会优于或等于收敛值，这应该给出一个很好的解决方案范围可供选择

### 3.13 Solution Evaluation

在搜索结束时，遗传算法会显示最终种群及其适应度，从中可以选择一个解决方案并将其写回系统以供后代使用。 在某些系统中，在搜索之后声明所有必要的参数并不总是可行的，或者可能只是忽略了一些因素。 因此，一旦获得解决方案，就必须对其所考虑的所有各种参数进行评估，包括适应度、中值适应度、最佳个体、最大适应度等。

### 3.14 Search Refinement

选择、交叉和替换等搜索参数在搜索的早期阶段非常有效，但在搜索结束时不一定是最好的。 在早期搜索期间，希望在解空间中获得良好的点分布，以便至少找到各种最优解的开始。 一旦种群开始趋于最优，晚上最好进行更严格的选择和替换，以完全覆盖该空间区域。
   或者，也可以在单个基因的域和分辨率中进行改进。 搜索早期的大范围和粗分辨率将有助于分散点。 经过一段时间后，很明显，空间的少数部分会产生非常差的结果。 然后适当限制基因范围并提高分辨率以精细搜索更好的区域。 当适应度值的收敛速度变慢或经过预设的代数后，GA 可以监控其性能并更改搜索参数。
   搜索空间中外观较差的区域也可能包含未发现的最优值。
   在可能无法准确实施解决方案的情况下，解决方案的敏感性也很重要。 两个独特的解决方案可能具有相当的适应度，没有不良影响； 然而，一个可能位于非常陡峭的最优位置，而另一个可能位于一个宽阔的土丘上。 可以观察到，宽丘上的解决方案对实施中的错误比陡峭边上的解决方案更不敏感，即使是很小的偏差也会导致不同的适应度。

### 3.15 Constraints

如果处理的遗传算法仅由目标函数组成，而没有关于变量规格的信息，则称为无约束优化问题。 考虑以下形式的无约束优化问题，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014027139.png" alt="image-20210806014027139" style="zoom:67%;" />

并且没有关于“x”范围的信息。 遗传算法在随机规范中使用其运算符来最小化该函数。
   在约束优化问题的情况下，为所考虑的变量提供信息。 约束被分类为： 

1.平等关系。

2.不平等关系。

遗传算法使用所考虑的系统、目标函数（要最大化或最小化）和约束来生成要测试的参数序列。 在运行系统时，评估目标函数并检查约束以查看是否存在任何违规。 如果没有违反，则为参数集分配与目标函数评估相对应的适应度值。当违反约束时，解不可行，因此没有适应度。 许多实际问题受到约束，很难找到最佳的可行点。 因此，人们应该从不可行的解决方案中获得一些信息，而不管它们与约束违反程度相关的适应度排名。 这是在惩罚方法中执行的。
   惩罚方法是通过将惩罚或成本与所有约束违规相关联，将约束优化问题转换为无约束优化问题的方法。 该惩罚包含在目标函数评估中。
   考虑最大化形式的原始约束问题：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014157000.png" alt="image-20210806014157000" style="zoom:67%;" />

其中 x 是 k 向量。   将其转换为不受约束的形式：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014231737.png" alt="image-20210806014231737" style="zoom:67%;" />

其中 Φ–惩罚函数 p–惩罚系数 对于该惩罚函数，存在多种替代方案。 惩罚函数可以对所有违反的约束进行平方。 在某些情况下，无约束解会收敛到约束解，因为惩罚系数 p 趋于无穷大

### 3.16 Fitness Scaling

执行适应度缩放是为了避免过早收敛和缓慢完成。 适应度缩放的各种类型是： 1. 线性缩放 2. σ–截断 3. 幂律

#### 3.16.1 Linear Scaling

考虑，

f-未缩放的原始适应度 

f'-缩放后的适应度

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014340506.png" alt="image-20210806014340506" style="zoom: 67%;" />

• 为了使平均成员得到选择，缩放后的适应度平均值应等于缩放前的适应度平均值。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014402683.png" alt="image-20210806014402683" style="zoom:67%;" />

• 为了不让超级个体占据支配地位，分配给他们的副本数量通过

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014419875.png" alt="image-20210806014419875" style="zoom:67%;" />

C 是高度拟合个体的副本数

Case-1 最初 C 被选择为任何想要的值，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014919026.png" alt="image-20210806014919026" style="zoom:67%;" />

别的

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014939560.png" alt="image-20210806014939560" style="zoom:67%;" />

Case-2 对于整个运行，我们取 C=2 如果 fmin > (2fav-fmin)，则

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806014955957.png" alt="image-20210806014955957" style="zoom:67%;" />

#### 3.16.2 Sigma Truncation

### 3.17 Example Problems

#### 3.17.1 Maximizing a Functione

考虑最大化函数的问题，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806015050913.png" alt="image-20210806015050913" style="zoom:67%;" />

其中 x 允许在 0 到 31 之间变化。解决这个问题涉及的步骤如下： 

步骤 1：对于使用遗传算法方法，必须首先将决策变量“x”编码为有限长度的字符串。 使用五位（二进制整数）无符号整数，可以获得 0(00000) 和 31(11111) 之间的数字。这里的目标函数是要最大化的 $f(x) = x^2$。 在这里执行遗传算法的单代编码、选择、交叉和变异。

首先，随机选择初始种群。 这里选择大小为 4 的初始种群，但可以根据要求和应用选择任意数量的种群。 表 3.1 显示了随机选择的初始群体。

第 2 步：获取生成的初始种群的解码 x 值。 考虑字符串 1，

![image-20210806015148452](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806015148452.png)

因此，对于所有四个字符串，都获得了解码值。

第 3 步：计算适应度或目标函数。 这是通过简单地平方“x”值获得的，因为给定的函数是 $f(x) = x^2$。

当 $x = 12$ 时，适应度值为， 

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806015238288.png" alt="image-20210806015238288" style="zoom:67%;" />

第 4 步：计算选择概率，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806015256069.png" alt="image-20210806015256069" style="zoom:67%;" />

其中 n- 种群数 f(x)- 对应于种群中特定个体的适应度值 Σf(x)- 整个种群所有适应度值的总和。
   考虑字符串 1，

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210806015318742.png" alt="image-20210806015318742" style="zoom:67%;" />























































































































































































































































































































































































































































































































































































































































































































































































































































































































