## Selection Methods for Genetic Algorithms

### 1 INTRODUCTION

遗传算法（GAs）理论最初由约翰·霍兰德于 1960 年提出，并在他 1975 年出版的《自然和人工系统中的适应》一书中得到充分发展[1]。 他最初的目标不是开发优化算法，而是对适应过程进行建模，并展示该过程如何在计算系统中发挥作用。  GA 是使用孟德尔遗传学和达尔文进化的概念的随机搜索方法 [2,3]。 这种启发式方法已被证明可有效解决许多应用领域中的各种现实世界难题，包括经济学、工程、制造、生物信息学、医学、计算科学等 [4]。

原则上，通常以随机方式从搜索空间中选择的一组个体作为优化问题的候选解决方案 [3]。 该群体中的个体通过（“适应度”）适应函数进行评估。 然后使用选择机制来选择用作下一代父母的个体。 然后这些个体将被杂交和变异以形成新的后代。 下一代最终由父母与其后代之间的替代机制形成[4]。 重复这个过程，直到满足某个条件。

正如我们从上面的伪代码所看到的，GA 是一种参数算法，它应用于给定问题需要设置参数并做出关于以下方面的决定： 

 为后代生产选择父母的方式；  

选定的父母重新组合；  

调整了人口规模；  

个体发生变异或杂交； 

选择探索其他研究领域的交叉概率和突变概率 [5]。

最终目标是正确选择这些参数 [5]。 因此，研究一直在寻找能够动态调整和提高解决方案质量的技术。 我们在文献中发现很多关注遗传算子的探索，更多的是种群规模 [5]。 缺点是对选择运算符的关注较少。 没有这个算子，遗传算法只是简单的随机方法，每次都给出不同的值[3]。 具有较高适应度值的个体被该算子选为下一代的概率较高。 选择方法的研究重点是搜索空间的有希望的领域。

开发和探索之间的平衡对于遗传算法的行为至关重要。 可以通过选择算子的选择压力和交叉变异的概率进行调整。 在选择的情况下，强大的选择压力可能会导致算法收敛到局部最优，而低选择压力可能会导致 AG 随机运行不同的结果 [6]。 选择算子旨在利用良好候选解决方案的最佳特性，以便在几代中改进这些解决方案，原则上，这应该引导 GA 收敛到手头优化问题的可接受且令人满意的解决方案 [2]。

选择算子是可能影响 GA 性能的最重要参数 [7]。 它旨在利用候选解决方案的最佳特性，以便在几代中改进这些解决方案，原则上，这应该引导 GA 收敛到手头优化问题的可接受且令人满意的解决方案 [6]。

文献中有几种选择方法：轮盘赌选择[8]、随机通用抽样、锦标赛选择和玻尔兹曼选择等[9]。然而，尽管进行了数十年的研究，但没有关于为每个问题选择好的选择方法的一般指南或理论支持 [10]。 这可能是一个严重的问题，因为正如我们将通过数值结果看到的那样，不合适的选择算子会导致 GA 在快速性和可靠性方面的性能不佳。 为了说明这个问题，我们将考虑一组六种流行的选择方法，我们将它们应用于四个基准函数的优化问题。 在以下各节中，我们首先简要介绍每种研究的选择方法。 在第 3 节中，我们概述了我们提出的一项技术的介绍，以帮助减少选择算子对 GA 全局性能的影响。 数值结果在第 4 节中介绍和讨论。第 5 节专门讨论我们的结论和未来的工作。   

### 2 SELECTION METHODS FOR GAS

如前所述，在这项工作中考虑了六种不同的选择方法，即：轮盘选择（RWS）、随机通用抽样（SUS）、线性秩选择（LRS）、指数秩选择（ERS）、锦标赛 选择（TOS）和截断选择（TRS）。 在本节中，我们简要描述了每种研究的选择方法。

#### 2.1 轮盘选择 (RWS)

这种选择方法的显着特点是它给当前种群的每个个体 $i$ 被选择的概率 $p(i)$ [10]，与其适应度 $f (i)$​ 成正比

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803145127985.png" alt="image-20210803145127985" style="zoom:67%;" />

其中 $n$ 表示以个体数量表示的种群规模。  RWS可以根据如下伪代码实现

RWS_ pseudo-code

计算 $S=\sum_{i=1}^nf(i)$

对于每个个体 （$1\le i\le n$），有

生成随机数，范围为 $\alpha\in[0,S]$

记参数 $iSum=0;j=0$

Do{

$iSum+=f(j);$

$j+=1;$

}while($iSum<\alpha $&&$j<n$​)

选择个体 $j$

请注意，该技术的一个众所周知的缺点是 GA 过早收敛到局部最优值的风险，因为可能存在始终赢得竞争并被选为父项的主导个体

#### 2.2 随机通用抽样（SUS）

SUS [8] 是 RWS 的一种变体，旨在降低过早收敛的风险。 可以按照如下伪代码实现：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150427035.png" alt="image-20210803150427035" style="zoom:67%;" />

#### 2.3 线性等级选择（LRS）

LRS [9] 也是 RWS 的一个变体，它试图克服 GA 过早收敛到局部最优的缺点。 它基于个人的等级而不是他们的适合度。 等级 $n$ 被赋予最好的个体，而最差的个体获得等级 1。因此，基于它的等级，每个个体 $i$ 都有被选中的概率，由表达式给出

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150602771.png" alt="image-20210803150602771" style="zoom:67%;" />

一旦当前种群的所有个体都被排序，LRS过程可以根据以下伪代码实现：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150622599.png" alt="image-20210803150622599" style="zoom:80%;" />

#### 2.4 指数等级选择（ERS）

ERS [10] 基于与 LRS 相同的原理，但与 LRS 的不同之处在于选择每个个体的概率。 对于 ERS，此概率由以下表达式给出：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150653983.png" alt="image-20210803150653983" style="zoom:67%;" />

其中

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150709886.png" alt="image-20210803150709886" style="zoom: 67%;" />

一旦计算出 $n$ 个概率，该方法的其余部分可以通过以下伪代码来描述：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150740252.png" alt="image-20210803150740252" style="zoom:80%;" />

#### 2.5 锦标赛选择（TOS）

锦标赛选择 [11] 是基于排名的选择方法的一种变体。 其原理在于随机选择一组 $k$ 个个体。 然后根据它们的相对适应度对这些个体进行排名，并选择最适应的个体进行繁殖。 整个过程对整个种群重复 $n$ 次。

因此，每个个体被选中的概率由下面的表达式给出

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150855616.png" alt="image-20210803150855616" style="zoom:67%;" />

从技术上讲，TOS的实现可以根据伪代码进行：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150917604.png" alt="image-20210803150917604" style="zoom:80%;" />

![image-20210803150931355](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803150931355.png)

#### 2.6 截断选择（ERS）

截断选择 [10] 是一种非常简单的技术，它根据每个种群的适应度对每个种群的候选解进行排序。 然后，仅选择最适合个体的特定部分 $p$ 并复制 $1/ p$​ 次。 除了非常大的人口外，它在实践中的使用比其他技术少。 该技术的伪代码如下：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803151035210.png" alt="image-20210803151035210" style="zoom:80%;" />

### 3 DESCRIPTION OF THE PROPOSED TECHNIQUE

在实现上一节中描述的六种选择方法并在各种测试函数的优化问题上对它们进行测试后，我们发现结果从一种选择方法到另一种有显着差异。 这带来了为无法对结果进行后验验证的现实世界问题选择适当方法的问题。

为了帮助减轻这个重要的问题，我们在本节中介绍了我们提出的一种新选择程序的概要，作为替代方案，当没有任何其他技术可以足够自信地使用时，它会很有用。 **我们的技术是一种动态技术，因为选择协议可以从一代到另一代有所不同。 基本思想包括在比例方法之间找到一个很好的折衷方案**，这会降低选择压力的影响并确保种群内的一些遗传多样性，但可能会增加收敛时间； 和精英方法减少收敛时间，但可能会增加选择压力的影响，从而增加收敛到局部最小值的风险。

 为了实现这一目标，每一代都应用了不止一种选择方法，但以一种竞争的方式，这意味着实际上只考虑了具有最佳性能的选择算子提供的结果。 为了评估和比较候选选择方法的性能，采用了两个客观标准。 第一个标准是解决方案的质量； 它可以很容易地作为最佳个体的适应度 $ f^*$ 的函数来衡量。 第二个标准是遗传多样性，其量化不如第一个标准。 在这项工作中，作为种群 $P(t)$​ 内遗传多样性的度量，我们建议根据以下公式计算 $t$ 代超过 30 次运行的平均种群多样性：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803151455052.png" alt="image-20210803151455052" style="zoom:67%;" />

其中 $D_{i\ j} (k, t)$​ 是第 $k$​ 次运行的第 $t$​ 代第 $i$​ 和第 $j$​ 个个体之间的欧几里德距离，$n$​ 是种群大小，$max(d_{ij})$ 是个体之间假设的最大距离， $t$ 为代数或迭代次数。 为了衡量每一代解决方案的质量，我们使用了标准

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803151642096.png" alt="image-20210803151642096" style="zoom:67%;" />

其中 $ f_{max}$​ 和 $f_{min }$​​ 分别表示 $t$​ 代适应度的最大值和最小值，$f^* = f_{max}$​ 或 $f^* = f_{min}$ 取决于问题的性质，可以是最大化也可以是最小化 问题。 最后，为了将两个标准组合成一个独特的标准，我们使用了关系

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803151905205.png" alt="image-20210803151905205" style="zoom:67%;" />

### 4 EXPERIMENTAL STUDY

在本节中，我们展示了一些数值结果的例子，这些结果是通过将六种选择方法以及前几节中描述的提议的组合选择 (CS) 程序应用于一组四口井的遗传优化问题而获得的。 已知的基准函数 [12]。 第一个函数是一个经典的多模态和高维函数，定义在区间 [-30,30] 上，表达式为

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152010029.png" alt="image-20210803152010029" style="zoom:67%;" />

第二个测试函数也是一个单维的例子，但它是一个具有欺骗性的例子，如图 1 所示，它拥有两个局部最大值，优化算法可能会被困在其中

![image-20210803152029031](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152029031.png)

$f_2 (x)$​ 在区间 $[0,6]$ 上由下面的表达式定义

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152115934.png" alt="image-20210803152115934" style="zoom:67%;" />

第三个例子是双变量 Shubert 函数 [3] 定义，对于 $-10\le x_1\le 10$ 和 $-10\le x_2\le 10$​ ，有

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152239795.png" alt="image-20210803152239795" style="zoom:67%;" />

最后一个例子是更一般的 Rastrigin 函数 [4] 的双变量实例，定义为

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152305979.png" alt="image-20210803152305979" style="zoom:67%;" />

其中 $-5.12\le x_i\le5.12$​    $i=1,2,...,n$​

结果总结在表 1 到 3 中。 表 1 显示了对于每个选择和每个测试函数，GA 收敛到可接受的解决方案所需的代数

对表 I 的分析表明，对于六种研究的选择方法，GA 的收敛速度存在显着差异，特别是在欺骗性示例 $f_2$ 的情况下。

![image-20210803152457314](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152457314.png)

![image-20210803152509105](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152509105.png)

表 2 显示了每种研究的选择方法和每个函数的选择压力百分比。 给定选择方法的选择压力 $sp$ 定义为最佳个体在种群中占主导地位的世代数。 至于选择压力的百分比，它由 $ sp_{min}/ sp$ 定义，其中 $ sp_{min}$ 表示在所有研究的亲本选择方法中观察到的最小选择压力。 我们可以注意到，比例方法比精英方法更能保持遗传多样性。

表 3 提供了与本研究的另一个方面相关的样本结果。 这是 GA 为每个测试函数和每种选择方法提供的最优质量评估的方面，包括我们在这项工作中提出的组合选择方法。 为了衡量这种质量，我们使用了相对误差

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152631130.png" alt="image-20210803152631130" style="zoom:80%;" />

其中 $ f ^*$ 是算法提供的最优值，$f$ 是实际最优值，这是先验已知的

![image-20210803152710561](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803152710561.png)

通过分析该表，我们可以清楚地看到，所提出的选择方法比所研究的六种选择方法表现更好。

### 5 CONCLUSION

在本文中，研究、实施了六种著名的 GA 选择方法，并使用一组四个基准函数分析和比较了它们的相对性能。 这些方法可以分为两类：比例和精英。 第一类使用与每个个体的适应度成正比的选择概率。 该类别的选择方法允许在几代人中保持候选解群体内的遗传多样性，这是防止遗传算法收敛到局部最优的一个很好的特性。 但是，另一方面，这些方法往往会增加收敛时间。

相比之下，第二类的选择方法只选择最好的个体，这提高了收敛速度，但由于候选解决方案群体内遗传多样性的损失，有收敛到局部最优的风险。

从这些观察开始，我们进行了初步研究，旨在结合这两个类别的优势。 这项研究产生了一种新的组合选择程序，其概要在本文中进行了介绍。 该程序背后的主要思想是以竞争的方式使用一种以上的选择方法以及允许在每一代中选择最佳选择方法的客观标准。

所提出的技术成功地应用于一组众所周知的基准函数的优化问题，这鼓励了这一思想的进一步发展。

# 其他资料

## 资料1

本文介绍了使用轮盘赌选择和锦标赛选择的简单遗传算法 (SGA) 的性能比较。  SGA 主要由三个遗传操作组成，即选择、交叉和变异。 在相同的交叉和变异操作下，通过比较本文讨论的不同选择策略来研究模拟结果。描述了选择策略的定性分析，数值实验表明，采用锦标赛选择策略的 SGA 比轮盘选择收敛得更快

### 1.Introduction

约翰霍兰德通过模拟自然进化开创了遗传算法。 近40年来，遗传算法在模式识别、机器人、人工生命、专家系统、电子电气领域、元胞自动机等诸多领域得到了应用[1]-[7]。

通过使用遗传算法解决问题，我们首先将候选解决方案呈现为一系列值，并定义一个评估函数来评估候选解决方案。 人工遗传系统使用种群和世代等概念来模拟自然遗传系统。 一个种群由一定数量的个体组成，作为候选解决方案。 新一代种群是通过迭代中的选择、交叉、变异等遗传操作产生的。

根据达尔文的生存法则，即“适者生存”，优秀的个体有更多的机会适应环境和生存，而劣等的个体则消亡[8]。 残存物繁殖出具有更好基因的新个体，这使得新一代更能忍受自然。 类似地，GA（遗传算法）使用这种繁殖过程作为算法的基本遗传操作。 目前有几种选择策略，例如轮盘赌、锦标赛选择、基于排名的选择和确定性采样。

本文在SGA中采用轮盘选择和锦标赛选择，并对结果进行了比较。 实验结果表明，采用锦标赛选择策略的算法比轮盘选择算法收敛速度快得多。

### 2.Simple genetic algorithm

SGA 由三个遗传操作组成：选择、交叉和变异 [9]。 SGA 使用的步骤如下

第1步。 在基因串中编码给定的问题。

第2步。 创建一个由一定数量的个体组成的初始种群。

第3步。 执行以下子步骤，直到满足终止条件：

(a) 评估种群中每个个体的适应度值。
(b) 通过如下三个遗传操作创建一个新种群：

根据适应度值，以概率选择个体。 复制选定的群体以形成新的群体。
   􀂾 由从总体中概率选择的两个父代创建两个新个体，并在交叉点重新组合它们。
   􀂾 通过使用概率选择的变异对现有个体进行变异来创建新个体。

第4步。 当过程停止时，我们可以从遗传算法的结果中找到一个解决方案

在选择操作中，对个体的选择是基于其适应度值。 个体的适应度越好，被选中的概率就越大。 没有任何变化，选定的一个被复制到下一代种群中。

此外，由于遗传选择是概率性的，因此可能会选择适应度值较差的个体。为了实现选择操作，可以使用轮盘赌和锦标赛选择等策略。 不同的选择策略对算法性能的影响不同

一次对两个选定的个体进行交叉。 以一定的概率选择两个个体，然后随机选择交叉点，这对被选中的个体进行交叉的过程。 通过交叉操作产生两个后代。 例如，考虑由两个二进制字符串 S1、S2 表示的两个父母个体，即 S1=0 0 1 1 1 |  0 1 0, S2=1 1 1 0 1 |  0 1 1，他们随机产生一个数字 5 作为交叉位置。 交换交叉位置后的子串后，我们得到两个后代 S1=0 0 1 1 1 |  0 1 1, S2=1 1 1 0 1 |  0 1 0。

变异的操作始于从种群中概率性地选择一个个体。 然后随机选择一个突变点。 突变点的特征被改变，然后新个体被复制到下一代种群中。变异的概率通常设置得非常小。

### 3.Selection strategies

**A. 轮盘选择** 

轮盘选择是最常用的选择策略。 它是一种比例选择策略，其选择原理与轮盘赌相似。 图 1 显示了一个轮盘赌。 整个轮盘分为不同区域的几个扇区，对应不同的金额。当旋转的轮盘停止时，选择指针所指的扇区，游戏者获得该扇区对应的金额。虽然我们无法预见指针将指向哪个扇区，但可以评估一个扇区被选中的概率。 它与扇形中心角的大小成正比。 扇区的中心角越大，指针指向该扇区的概率就越大。 同样，在遗传算法中，整个种群由个体划分，每个扇区代表一个个体。 个体的适应度值占整个种群总适应度值的比例决定了个体对应的扇区面积，决定了个体被选入下一代的概率。

![image-20210803174925194](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803174925194.png)

以下步骤显示了使用轮盘赌策略的选择：

1) 计算种群中每个个体的适应度值之和。
2) 评估每个个体的相对适应度值。 计算每个个体的适应度值与整个种群中所有个体的适应度值之和的比例。比例代表个体被选中的概率。
 3) 根据第二步计算的比例划分轮盘赌。 每个区划代表一个个体。 扇区的面积与个人被选中的概率成正比。 将轮盘旋转 $n$ 次，其中 $n$ 是总体中的个体数量。当旋转的轮盘停止时，指针所指的扇区代表被选中的相应个体。

现在，考虑一个大小为 $n$​ 的种群（种群中的个体数为 $n$​），$P=\{a_1,a_2,a_3,...,a_n\}$​， 个体 $a_i$​ 的适应度值为 $f(a_i)$，则 $a_i$ 被选中的概率是

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803175301880.png" alt="image-20210803175301880" style="zoom:67%;" />

图 2 显示了轮盘赌的选择。

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803175318895.png" alt="image-20210803175318895"  />

**B. 锦标赛选择**

锦标赛选择也是一种选择策略，它根据个人的适应度值来选择个人。该策略的基本思想是从种群中一定数量的个体中选择适应度值最高的个体进入下一代。 在锦标赛选择中，没有基于适应度值的算术计算，而只是通过适应度值进行个体之间的比较。 参加锦标赛的人数称为锦标赛规模。 选择执行以下步骤：

1.从种群中随机选择几个人参加比赛。 通过比较每个个体的适应度值，从上面选择的个体中选出适应度值最高的个体。 然后将选择的一个复制到下一代种群中。

2.重复步骤 1 $n$ 次，其中 $n$ 是种群的个体数。

### 4.Experiments

在本节中，我们将讨论 SGA 的设计。 当使用不同的选择策略时，SGA 具有相同的交叉和变异操作。 该算法描述如下

![image-20210803175615540](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803175615540.png)

![image-20210803175633501](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803175633501.png)

上述算法中，Times<1000为终止条件，表示执行SGA的次数。 因为 GA 是随机计算技术，我们必须对一个问题执行多次 SGA，以便我们可以得到一个统计上好的结果。

POPSIZE 表示总体的个体数。  MAXGENS 是进化过程中的最大代数，这里我们设置 MAXGENS 为 1000。  PXOVER 是被选中的个体交叉的概率，而 PMUTATION 是被选中的个体发生变异的概率。 对于使用 SGA 的每个问题，我们有不同的参数组。 我们设置POPSIZE的值为50、100、150、200、250，PXOVER的值为0.1、0.3、0.5、0.7、0.9，PMUTATION的值为0.05、0.1、0.15、0.2、0.25 对SGA的POPSIZE、PXOVER、PMUTATION三个参数进行排列组合后，我们有100个参数组。 因此，对于每个要解决的问题，算法将使用不同的参数组执行 100 次，每次使用一个参数组。 该算法使用轮盘赌和锦标赛选择进行选择操作，每个策略SGA分别有100个结果。 特别地，在锦标赛选择策略中，参加锦标赛的个人数为6。

我们已经使用 SGA 对七个测试函数进行了实验。 表 I 显示了七个测试函数。每个函数都有一个规定的搜索域，在表的约束列中给出。 问题列表示我们想要获得的解决方案。 每个函数的最优解是预先知道的。

当候选解与最优解之间的绝对差异小于给定值时（差异列中所示），SGA 过程停止。 对于给定的函数，在执行 SGA 的 1000 次中的每一次，当 SGA 的进程终止时，我们保留 generation 的值。  generation 的值是 0 到 1000 之间的整数。 generation 的每个值都有一个对应的计数器，保存 SGA 获得这一代的次数

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180107906.png" alt="image-20210803180107906" style="zoom:67%;" />

### 5.Results and discussions

在本节中，我们将讨论不同选择策略下 SGA 的比较性能。 根据不同的参数组和不同的选择策略，每个函数共有 200 个结果。 对于每个参数组，SGA 将执行 1000 次。 每次我们在过程停止时获得生成值。generation 的值越小，算法收敛得越快。

让我们重点关注基于这个参数组的算法结果：POPSIZE=100，PXOVER=0.1，PMUTATION=0.15。 使用这些参数，SGA 执行 1000 次。 下图显示了7个函数的结果，其中X轴代表代的值，Y轴代表在某一代获得满意解的次数。 图中的一个点代表在某一代求解出满意解的一定次数。 以图3(a)为例，曲线中X轴值为100的点，Y轴值为4，这意味着SGA在第100代有4次得出满意的解。  SGA 得到前一代满意解的次数越多，算法的性能就会越好。

基于图3的结果，表II通过比较图3（a）和图3（b）来评估早期代获得满意解的总和。 在前 10 代中，该算法在轮盘选择中命中 135 次，在锦标赛选择中命中 427 次。 在前 20、30、40 和 50 代中，该算法在轮盘选择中分别达到了 297、436、581 和 703 次，而在锦标赛选择中分别达到了 747、914、971 和 990 次。 经过 100 代，带锦标赛选择的算法在 1000 条路径中都找到了满意的解决方案，但使用轮盘选择的算法在满意的解决方案上只命中了 952 次。 我们可以看到，在函数 f1(x1,x2)= x1 2+x2 2 中，锦标赛选择比轮盘选择表现要好得多。使用不同函数的图 4 到图 9 也表明，采用锦标赛选择的算法比轮盘选择算法表现更好。

![image-20210803180528133](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180528133.png)

![image-20210803180540199](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180540199.png)



![image-20210803180559173](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180559173.png)

![image-20210803180617596](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180617596.png)

![image-20210803180628106](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180628106.png)

![image-20210803180640885](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180640885.png)

![image-20210803180653626](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180653626.png)

![image-20210803180703874](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803180703874.png)

从上面显示的结果来看，使用锦标赛选择的 SGA 总是比轮盘选择在更早的世代中获得满意的解决方案。 这表明基于锦标赛选择的 SGA 比轮盘选择收敛得更快。 算法的收敛速度越快，算法解决问题所需的时间就越少。 从这个角度来看，使用锦标赛选择的 SGA 比轮盘选择具有更好的性能。 对于其他参数组，结果与 GA 与锦标赛选择的收敛速度相同。

## 资料2

通过随机接受选择轮盘赌

轮盘赌选择是遗传或进化算法中常用的方法。 现有例程使用 O(N) 或 O(logN) 复杂度的搜索算法选择 N 个个体之一。 我们提出了一个简单的轮盘赌选择算法，它通常具有 O(1) 复杂度，并且基于随机接受而不是搜索。 只需稍加修改，该算法也可用于在特定值处截断适合度的采样或无替换采样。

寻找晶体、无序磁体或蛋白质的低能量配置、从地震数据重建地质结构或分析 X 射线数据只是物理科学中优化问题的几个例子 [1]。 开发了各种技术来解决这些问题，其中最常用的一种是遗传算法 [2]。 他们的基本思想是模仿生物进化创造明显更适合物种的方式。 为此，需要将一组优化方法（例程、函数、策略等）表示为一组个体，这些个体在本质上受到两个（在某种意义上说是相反的）过程的影响。一方面，由于突变或交叉操作，种群的变异性增加。 另一方面，为了引导进化朝着理想的方向发展，人们必须通过一些选择机制来修剪种群。 事实证明，这种受生物学启发的方案使我们能够有效地找到各种问题的最佳或接近最佳的解决方案 [3]。

选择是遗传算法的重要组成部分，因为它会显着影响它们的收敛性。 基本策略是：个体越适合，其生存和交配的可能性就越大。 该规则最直接的实现是所谓的轮盘赌选择 [3]。 该方法假设选择的概率与个体的适应度成正比。 可以简要描述如下。 让我们考虑 N 个个体，每个个体的特征是其适应度 $w_i > 0 (i = 1, 2, . . , N)$。 因此，第 $i$ 个个体的选择概率为

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803181241874.png" alt="image-20210803181241874" style="zoom:67%;" />

让我们想象一个轮盘，其扇区大小与 $w_i (i = 1, 2, . . , N)$ 成正比。 个体的选择就相当于在轮子上随机选择一个点并定位相应的扇区（图 1）。当使用简单搜索时（穷举法），这样的位置需要 $O(N)$ 次操作，而二分搜索可以将其减少到 $O(logN)$。

还有其他选择概率取决于适应度的方法，例如随机余数或随机通用选择 [4, 5]。 它们的统计特性略有不同，通常会导致种群的变异性更大。在另一类选择方法中，个人的排名或排序而不是他们的适应度起着核心作用[6]。 当然很难指出这些方法中的哪一种是最好的 [7]。 尽管一些研究表明基于适应度的选择方法存在某些与缩放相关的问题 [8]，但有一些工作似乎可以缓解这种困难 [9]。

由于实现的简单性和直接的解释，轮盘赌选择经常用于遗传算法。 尽管二分搜索显着降低了计算复杂度，但在我们看来，更快的实现仍然是可取的。 在本文中，我们展示了轮盘选择可以通过一个复杂度通常为 $O(1)$ 的简单算法来实现。 所提出的算法不使用搜索，而是基于对随机选择的个体的随机接受。

我们的算法包括以下步骤： 

1. 随机选择一个个体（比如 $i$）。 选择以均匀概率 $(1/N$) 完成，不依赖于个体的适应度 $w_i$（图 2）。

   2. 以概率 $w_i/w_{max}$，其中 $w_{max} = max\{w_i\}^N _{i=1}$ 是种群中的最大适应度，选择被接受。 否则，从步骤 1 开始重复该过程（即，在拒绝的情况下，进行另一次选择尝试）。

![image-20210803181733446](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803181733446.png)

图2：在所提出的算法中，一个人随机（以等概率 1/N）选择一个个体（比如 i）并以概率 $w_i/w_{max}$ 接受这样的选择，其中 $w_{max}$​ 是最大适应度。 在拒绝的情况下，重新重复该程序（即，重复选择一个新人直到被接受）。 尽管它需要额外调用随机数生成器，但它仍然是典型的 $O(1)$ 算法。

当然，第 $i$​ 个个体在一次尝试中被选中的概率等于 $w_i/(Nw_{max})$。 但是，由于多次尝试可能会失败，因此必须计算在未指定次数的尝试中选择的个体将成为第 $i$ 个个体的概率。 直接计算给出

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803183449197.png" alt="image-20210803183449197" style="zoom:67%;" />

其中

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803183521153.png" alt="image-20210803183521153" style="zoom:67%;" />

是拒绝概率，$<w_i> = 1/N \Sigma ^N _{i=1} w_i$​ 是平均适应度。 几何级数 (2) 是收敛的 $(0 < q < 1)$​ ，不难得到

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803183833368.png" alt="image-20210803183833368" style="zoom:67%;" />

其中 $p_i$ 在等式(1)中定义。这表明我们程序的概率分布确实与轮盘赌选择相同。类似地，我们可以计算任何个体的单次选择所需的平均尝试次数 $\tau$。
<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803184017494.png" alt="image-20210803184017494" style="zoom:67%;" />

虽然决定了我们算法的计算复杂度的并不明确取决于 $N$​，但比率 $\frac{w_{max}} {<w>}$​ 可能会随 $N$​ 变化，具体取决于问题的特殊性。 然而，我们期望在许多应用中，例如在适应度保持有界（$w_i < B$​）的情况下，比率 $\frac{w_{max}} {<w>}$​ 不会随着 $N$ 无界增加，因此我们算法的典型复杂度应该是 $O(1)$。

可以检查一种更通用的算法，其中接受概率为 $w_i/A$​​​，其中 $A > w_{max}$​​ 是某个常数。 对于这样的算法，选择概率 $p'_ i$​ 也满足等式(4). 但是，较小的接受概率会导致较大的拒绝概率，并且算法的效率会降低（会增加）。 对于 $A < w_{max}$​​，一些分数 $w_i/A$ 可能会大于 1，并且与轮盘赌选择的等价性不成立。 因此，选择 $A = w_{max}$ 可确保最佳性能。

为了检查其性能，我们将我们的算法应用于 $N$​​​ 个个体的群体，其适应度为均匀分布的随机数 $0 < w_i < 1$​​。我们使用线性或二分搜索以及当前版本运行轮盘赌选择方法。 我们检查了这些程序生成的选定个体的分布是否在相同的统计误差范围内。 作为 $N$​​ 函数的每个单次选择的平均执行时间如图 3 所示。正如预期的那样，线性和二分搜索分别显示 $O(N)$​​ 和 $O(logN)$​​ 行为。 我们的算法需要有限的 CPU 时间，大 N 的轻微增加是由于超过缓存内存大小的过多内存需求。 我们还测量了平均尝试次数。 在我们的数值示例中，对于大 $N$​​，$w_{max} ≈ 1$，$<wi> ∼ 1/2$​。 因此，根据方程(5),  $\tau≈ 2$​，我们的数值数据与这个结果非常吻合（图 3）。

为确保总体具有足够大的可变性，有时需要使用无替换抽样。 为了保证曾经被选中的个体不会被再次选中，可以简单地将其适应度设置为 0。但是，当个体恰好具有最大适应度时，应该找到一个新的最大值。 稍微牺牲效率，可以使用旧的最大值来计算接受概率 $w_i/w_{max}$​​​。 类似地，当个体的适应度已知是有界的（$w_i < B$​）时，不需要跟踪当前的最大值，因为可以使用 $w_i/B$ 作为接受概率。 虽然算法的效率降低了，但它仍然是 O(1) 类型。

在我们的算法中用某个常数 $A < w_{max}$ 替换 $w_{max}$​ 可能是另一种增加所选群体变异性的方法。 实际上，在这种情况下，根据等式（1）选择个体，但个体的适应度在 A 处被截断（即    $w_i → min\{w_i,A\}$)。 我们的算法也可能适用于不断发展的系统，例如一些复杂的自适应系统，其中一些或所有个体的适应度随时间变化。

总之，我们已经表明，Holland 使用适应度成比例选择的原始想法，即所谓的轮盘赌选择，可以表述为典型的 $O(1)$ 复杂度的算法。 数值示例表明，对于遗传算法应用程序中使用的种群大小，范围从 102 到 104，我们的算法提供了比基于线性或二分搜索的现有例程可观的 CPU 增益。 该算法非常简单，我们希望它可以修改并用于更复杂的选择方案。

![image-20210803184554189](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803184554189.png)

图3.单个轮盘选择的平均 CPU 时间 t（以 μs 为单位）作为总体规模 N（对数尺度）的函数。 正如预期的那样，线性搜索的复杂度为 $O(N)$，而二分搜索的复杂度为 $O(log(N))$。 本算法表现为 $O(1)$ ，在最大 $N$ 处的轻微增加是由于超过缓存内存大小的过多内存需求。 计算是在 Intel Xeon 2.8GHz 处理器上进行的。 实心方块显示每个选择的平均尝试次数。

## 资料3

广义网络 (GNs) 的装置在此应用于描述选择算子，选择算子是基本的遗传算法算子之一。 这里介绍的 GN 模型描述了当前 GA 中使用最广泛的选择算法之一，即随机通用采样。 由此产生的 GN 模型可以被视为一个单独的模块，但也可以累积成一个 GN 模型来描述整个遗传算法

### 1 Introduction

遗传算法（GA）是一种基于自然选择和遗传学进化思想的自适应启发式搜索算法。 它们代表了对用于解决优化问题的随机搜索的智能利用。 遗传算法的基本技术旨在模拟自然系统中进化所必需的过程，尤其是遵循查尔斯·达尔文首先提出的“适者生存”原则的那些过程。 遗传算法基于与个体群体中染色体的遗传结构和行为的类比。

GA 在计算机模拟中实现，其中优化问题的候选解决方案（称为个体、生物或表型）的一组抽象表示（称为染色体或基因组的基因型）朝着更好的解决方案发展。 进化通常从一群随机生成的个体开始，并发生在几代人中。 在每一代中，评估种群中每个个体的适应度，从当前种群中随机选择多个个体（基于它们的适应度），并修改（重组和可能随机变异）以形成新的种群。 然后在算法的下一次迭代中使用新的种群。 通常，当产生了最大数量的代或达到种群的令人满意的适应度水平时，算法终止。 一旦定义了遗传表示和适应度函数，GA 就开始随机初始化一组解，然后通过重复应用变异、交叉、反转和选择算子来改进它。

GA 非常流行，并应用于许多领域——工业设计、调度、网络设计、路由、时间序列预测、数据库挖掘、控制系统、人工生命系统，以及许多科学领域 [5, 7, 8]  . 另一方面，到目前为止，广义网络 (GN) 的设备已被用作描述多个领域（经济学、交通、医学、计算机技术等）并行过程的工具。[1÷3, 13÷16]。 这就是为什么直观地出现了将 GN 应用于 GA 描述的想法。 到目前为止，只有少数关于遗传算法性能的 GN 模型被开发出来 [1, 3, 13÷16]。  [1, 3] 中提出了遗传算法学习的 GN 模型。  [15]中的GN模型描述了遗传算法算子的选择。 该模型可以测试定义的遗传算法算子的不同组，并在它们之间选择最合适的组合。 开发的 GN 执行 GA 并实现对所考虑问题的遗传算子以及适应度函数的调整。 遗传算法搜索过程在[16]中用GN模型描述。 该模型同时评估多个适应度函数，根据个体的适应度对个体进行排名，并有机会针对特定问题领域选择最佳适应度函数。 在 [12, 13, 14] 中，基本的遗传算法算子——相应地选择、交叉和变异是使用 GN 描述的。 不同类型的交叉，即一点、两点交叉，以及“剪切和拼接”技术，在[13]中有详细描述。  [14] 中提出的 GN 模型描述了 Breeder 遗传算法的变异算子。 选择个体以产生连续世代在遗传算法中起着极其重要的作用。 概率选择是根据个人的适合度进行的，这样更好的个人被选中的机会就会增加。 种群中的一个个体可以被多次选择，种群中的所有个体都有机会被选择繁殖到下一代。 选择过程有几种方案：轮盘赌选择及其扩展、缩放技术、锦标赛、精英模型和排名方法 [9, 10, 17]。 广泛使用的用于遗传算法的 Matlab 工具箱 [6, 11] 包含两个用于选择函数的函数，即轮盘选择法和随机通用采样。 由于在 [12] 中开发了轮盘选择方法的 GN 模型，因此本研究的目标是开发随机通用采样的 GN 模型。

### 2 Stochastic Universal Sampling（随机通用抽样）

Baker [4] 开发的随机通用采样 (SUS) 是一种具有最小扩展和零偏差的单相采样算法。  SUS 使用 N 个等间距的指针，而不是轮盘赌方法中使用的单个选择指针，其中 N 是所需的选择数。 种群被随机打乱，并生成一个在 $[0, 1/N]$​ 范围内的单个随机数指针 1。 然后通过生成 $N$​ 个指针来选择 $N$​ 个个体，从指针 1 开始，间隔为 $1/N$，并选择适应度跨越指针位置的个体。 如果 $et(i) $是个体 $i$ 的预期试验次数，则et(i)是et(i)的下限，et(i)是上限，因此保证个体被选择为最小 次et(i)且不超过et(i)，从而实现最小传播。 此外，由于个人完全是根据他们在总体中的位置来选择的，因此 SUS 的偏差为零。 由于这些原因，SUS 已成为当前 GA 中使用最广泛的选择算法之一。

图 1 展示了随机通用抽样。 个体被映射到一条线的连续段，这样每个个体的段的大小与其在轮盘赌选择中的适应度完全相同。在这条线上的所放置的指针数量与要进行选择的对象数相同，并且是等距的。对于要选择的 6 个个体（N = 6），指针之间的距离为 1/6 = 0.167。 图 1 显示了对 [0, 0.167] 范围内随机数 0.1 样本的选择。

![image-20210803225115244](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210803225115244.png)

选择后，交配种群由个体 1、2、3、4、6 和 8 组成。随机通用抽样确保选择比轮盘赌更接近应得的后代

## 资料4

### Part A: Background

#### 1 INTRODUCTION

遗传算法一词现在几乎普遍缩写为 GA，最早由 John Holland [1] 使用，其 1975 年出版的《自然和人工系统中的适应》一书有助于创造现在蓬勃发展的研究和应用领域，而且范围更广 比原来的GA。 许多人现在使用术语进化计算或进化算法 (EA)，以涵盖过去 10 年的发展。 然而，在元启发式的背景下，可以公平地说，原始形式的 GA 包含了人们需要知道的大部分内容。

 Holland 在该主题的发展中的影响非常重要，但其他几位具有不同背景的科学家也参与了类似的想法的发展。  1960 年代的德国，Ingo Rechenberg [2] 和 Hans-Paul Schwefel [3] 提出了 Evolutionsstrategie（英文，evolution strategy）的想法，同时——同样在 1960 年代——美国的 Bremermann、Fogel 和其他人实施了他们的想法 他们称之为进化编程。 这些想法的共同点是使用变异和选择——新达尔文进化论的核心概念。 虽然取得了一些有希望的结果，但进化计算直到 80 年代才真正起飞。 造成这种情况的最不重要的原因是这些技术需要大量的计算能力。 尽管如此，根据我们目前的知识，这些早期先驱者的作品读起来很有趣。  David Fogel（早期先驱之一的儿子）在 [4] 中记录了其中的一些工作。

1975 年是遗传算法发展的关键一年。 霍兰德的书就是在这一年出版的，但对于那些对元启发式感兴趣的人来说，这一年可能更相关，那一年也见证了霍兰德的一名研究生 Ken DeJong [5] 完成了一篇博士论文。  Holland 的其他学生之前已经完成了该领域的论文，但这是第一个对 GA 在优化方面的能力进行全面处理的论文。

随后进行了一系列进一步的研究，1985 年召开了第一次关于这一新兴学科的会议，荷兰的另一位研究生大卫·戈德堡 (David Goldberg) 首先发表了一篇关于他在天然气管道优化中的应用的获奖博士论文，然后在 1989 年 ，一本有影响力的书 [6]——搜索、优化和机器学习中的遗传算法。 这是推动 GA 理论和应用持续发展的最后催化剂，该理论和应用仍在快速增长。

优化在 Holland 关于自适应系统的工作中占有相当小的位置，但大多数关于 GA 的研究倾向于假设这是他们的目的。  DeJong 对优化产生了这种兴趣，他警告说，这种强调可能在一篇论文 [7] 中被放错了位置，他认为 GA 并不是真正的功能优化器，并且在某些方面这与适应的主题无关。 尽管如此，使用 GA 进行优化非常流行，并且在实际应用中经常成功，对于那些对元启发式感兴趣的人来说，这无疑是最有用的观点。

与早期的进化算法侧重于变异并且可以被认为是爬山方法的直接发展不同，Holland 的遗传算法有一个额外的成分——重组的想法。 在这方面比较 1960 年代在运筹学 (OR) 领域提出的一些想法是很有趣的。

那时，OR 工作人员已经开始开发似乎能够提供“良好”解决方案的技术，即使质量无法证明是最佳的（或什至接近最佳）。这种方法被称为启发式方法。 本手册中描述的许多元启发式算法的核心仍然是一种流行的技术，即邻域搜索技术，该技术已被用于解决范围广泛的组合优化问题。 基本思想是探索现有解决方案的“邻居”——这些被定义为通过对基本解决方案的指定操作可获得的解决方案。

在这方面最有影响力的论文之一是 Lin [8] 发表的论文，他通过调查由破坏旅行的任意 3 个链接并重新连接它们而形成的社区，找到了解决旅行商问题的绝佳解决方案。 根据经验，Lin 发现这些“3 最优”解决方案具有出色的质量——在他研究的（相当小的）问题的情况下，通常接近全局最优。 然而，他还做了另一个有趣的观察，并提出了一种利用它的方法。虽然从不同的初始排列开始给出了不同的 3-最优解，但观察到这些 3-最优解具有许多共同的特征（链接）。因此，林建议应该将搜索集中在那些没有达成共识的链接上，而不管解决方案的共同特征。

这不是荷兰开发的 GA，但有明显的共鸣。 很久以后，在 GA 变得更广为人知之后，林的想法被重新发现为“多亲重组”和“共识算子”。同一时代的其他 OR 研究采用了这些想法。  Roberts 和 Flores [9]（显然是独立的）对 TSP 使用了类似于 Lin 的方法，而 Nugent 等人。  [10] 将此基本思想应用于二次分配问题。 然而，一般原则并没有被采用到 OR 方法中，并且在 1990 年代 GA 出现在 OR 领域之前，几乎没有人利用这个想法

#### 2 BASIC CONCEPTS

假设我们有一个离散的搜索空间 $\chi$ 和一个函数
$$
f:\chi\mapsto\Bbb{R}
$$
一般的问题是找到

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804143400202.png" alt="image-20210804143400202" style="zoom:50%;" />

这里 $x$ 是决策变量的向量，$f$ 是目标函数。 我们在这里假设问题是最小化问题，但最大化问题所需的修改几乎总是显而易见的。 这种问题通常称为离散或组合优化问题 (COP)。

GA 方法的显着特征之一是允许将问题的表示与最初制定问题的实际变量分开。 根据这些术语的生物学用法，习惯上区分“基因型”——变量的编码表示，与“表型”——变量本身的集合。 也就是说，向量 $x$ 由长度为 $l$ 的字符串 $s$ 表示，由从字母表中 $\mathcal{A}$ 提取的符号组成，使用映射
$$
c:\mathcal{A}'\mapsto\chi
$$
在实践中，我们可能需要使用搜索空间
$$
S\subseteq\mathcal{A}^l
$$
以反映以下事实，即 $c$ 下 $\mathcal{A}^l$ 图像中的某些字符串可能代表原始问题的无效解决方案。  （这是 GA 在组合优化中的潜在困难来源——[11] 中涵盖的主题。）字符串长度 $l$ 取决于 $\chi$ 和 $\mathcal{A}$ 的维度，并且字符串的元素对应于“基因”，并且 这些基因可以取为“等位基因”的值。 这通常被称为基因型-表型映射。 因此优化问题可以写为

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804144113837.png" alt="image-20210804144113837" style="zoom:67%;" />

其中
$$
g(s)=f(c(s))
$$
通常希望 $c$ 应该是一个双射。  （双射的重要特性是它有一个逆，即每个字符串 $s$ 都有一个唯一的向量 $x$，每个向量 $x$ 都有一个唯一的字符串 $s$。）在某些情况下，这种映射本身的性质给解决优化问题的 GA 带来困难，如 [11] 中所述。

在使用该设备时，Holland 的想法与 Rechenberg [2] 和 Schwefel [3] 开发的类似方法明显不同，后者更喜欢直接使用原始决策变量。  Holland 和 Goldberg 的书都声称用二进制字符串（即 $\mathcal{A}=\{0,1\}$​ )。 当然，GA 中的大部分理论工作都倾向于做出这种假设。 在应用中，许多表示都是可能的——一些可用于特定 COP 的替代方案在 [11] 中进行了讨论。

GA 方法的最初动机是一个生物学类比。 例如，在植物或动物的选择性育种中，寻找具有某些理想特征的后代——这些特征是在遗传水平上通过父母染色体结合的方式确定的。 在 GA 的情况下，使用了一组字符串，这些字符串在 GA 文献中通常称为染色体。 字符串的重组是使用遗传交叉和变异的简单类比来进行的，搜索以对种群中每个字符串的目标函数 $f$ 的评估结果为指导。 基于此评估，可以识别具有更高适应度（即代表更好的解决方案）的字符串，并为这些字符串提供更多繁殖机会。 这里还需要指出，适应度不一定要简单地与组合 $f(c(s))$ 相同； 更一般地说，适应度是 $h(f(c(s)))$​ 其中 $h:\Bbb{R}\mapsto\Bbb{R}$ 是单调函数

也许遗传算法的最基本特征是它们使用许多字符串的种群。 再次，德国 ES 学派最初没有使用种群，并且几乎完全专注于“变异”算子，这些算子在概念上通常更接近邻域搜索及其扩展中使用的算子类型。  Holland 也使用了变异，但在他的方案中，它通常被视为从属交叉。 因此，在 Holland 的 GA 中，不是像 NS 方法那样从点到点进行搜索，而是对整个字符串集进行“复制”以生成新的种群。

DeJong 的工作表明，使用交叉和变异算子的基于种群的 GA 可以成功处理几种不同类型的优化问题，并且在这项工作发表后的几年里，GA 在 COP 中的应用几乎呈指数增长。B 部分更全面地描述了这些运算符和它们的一些发展。然而，此时提供一个非常基本的介绍可能会有所帮助。交叉是用另一个亲本的相应基因替换一个亲本中的某些基因的问题。 单点交叉的一个例子如下：给定亲本 P1 和 P2，具有交叉点 3（由 X 表示），后代将是 01 和 02 对：

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804144737452.png" alt="image-20210804144737452" style="zoom:67%;" />

另一个常见的算子是变异，其中随机选择基因子集，并改变所选基因的等位基因值。 在二进制字符串的情况下，这仅意味着对所选位进行补码。 例如，上面的字符串 01 ，基因 3 和 5 发生了突变，将变成 1 0 0 1 1 0 1 。 遗传算法操作的简单模板如图 3.1 所示。 这个非常通用的公式的各个部分将在 B 部分详细讨论。

![image-20210804144818856](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804144818856.png)

![image-20210804144827048](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804144827048.png)

#### 3 WHY DOES IT WORK?

GA 究竟如何以及为何起作用仍然存在激烈争论。 有各种不同的学派，但没有一个能提供明确的答案。 不久将在 [12] 中提供全面调查。 同时，以下是已使用的主要概念的简要指南。

##### 3.1 The  traditional view

Holland 对为什么搜索空间 $\mathcal{A}^l$ 比搜索空间 $\chi$ 更有利的解释取决于三个主要思想。 这种理解的核心是模式的概念。模式是空间 $\mathcal{A}^l$ 的子集，其中所有字符串共享一组特定的定义值。 这可以用字母表 $\mathcal{A}\cup*$ 来表示； 在二进制情况下，例如 1 * * 1 表示第一个和最后一个基因都取值为 1 的 4 维超立方体的子集，即字符串 {1 0 0 1, 1 0 1 1,  1 1 0 1, 1 1 1 1}。

Holland 的第一个想法是内在（或隐含）并行性——许多模式上的信息可以并行处理的概念。 在取决于种群规模和模式特征的某些条件下，Holland 估计规模为 $M$ 的种群包含有关模式的信息 $\mathcal{O}(M^3)$ 。 然而，这些模式实际上不能被并行处理，因为通常无法获得它们的适应度的独立估计[13]。

第二个概念由所谓的模式定理表达，其中霍兰德表明，如果在时间 $t$​ 人口中存在给定模式 $S$ 的 $N(S, t)$ 个实例，那么在下一个时间步（在繁殖之后）  ，新种群中的预期实例数可以由

![image-20210804145641024](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804145641024.png)

其中 $F(S,t)$​ 是模式 $S$​ 的适应度，$\bar{F}(t)$​ 是总体的平均适应度，$\epsilon(S,t)$​ 是反映遗传算子破坏模式 $S$​ 原本遗传样式大小的一项。

由于没有意识到这种关系的随机性和动态性，从这个定理中得出了一些夸张的结论，在经常发表的声明中表达了良好的模式将在后代中接受指数增加的试验次数。 然而，很明显，模式定理只是期望中的结果，并且只适用于一代。 因此，任何将这一结果外推超过一代种群的尝试都注定要失败，因为这些项不再独立于其余种群中正在发生的事情。 此外，鉴于人口有限，很明显，任何指数增长都不会持续很长时间。

Holland 还试图通过对随机双臂老虎机问题的类比来模拟模式处理（或超平面竞争）。 这是一个众所周知的统计问题：我们有两个“杠杆”，如果拉动，根据不同的概率分布给出“收益”值。 问题是使用先前拉动的结果来最大化未来的整体预期收益。 在 [1] 中，有人认为 GA 近似于一种“最佳”策略，该策略将（指数级）增加的试验次数分配给观察到的更好的杠杆； 然后，这用于争夺 GA 在区分竞争模式或超平面方面的假定效率。

GA 的早期描述非常强烈地表明，在 GA 中，我们因此发现了一种算法，该算法使用最佳可用搜索策略不仅可以解决一个，而且可以同时解决许多超平面竞争：“组合爆炸对我们有利的唯一情况”。 不幸的是，Wolpert 和 Macready 的“No-Free-Lunch”定理 (NFLT) [14] 已经摧毁了这样的梦想。 它仅描述了在某些数字中可能存在的模式数量，因为在某些关于字符串长度、总体大小和（最重要的）总体生成方式的假设下，最后一个假设不太可能成立，除非 在搜索的早期阶段。 即便如此，只有在非常不寻常的情况下——正交种群[13]——才能真正并行处理超平面竞争； 通常，比赛不是独立的。

双臂强盗类比至少在两个方面也失败了：首先，Macready 和 Wolpert [15] 最近认为，没有理由相信 Holland 描述的由 GA 近似的策略是最佳策略。 他们还认为，无论如何，Holland 的数学都存在缺陷。

这并不是说模式定理特别是模式定理或一般模式的想法是无用的，而是它所说的内容有限且主要是短期的价值——主要是某些模式可能会增加它们的存在 在下一个群体中，并且这些图式将是平均更合适的，并且与那些没有的图式相比，对交叉和突变的破坏抵抗力更小。

这给我们带来了 GA 实现中隐含的第三个假设——将基因型的小部分（好的模式）重新组合成更大的部分确实是寻找最佳解决方案的明智方法。  Goldberg [6] 将此称为构建块假设 (BBH)。当然有一些负面证据，因为构建包含误导性构建块的问题可能确实很难由 GA 解决。 当 GA 无法解决特定的 COP 时，BBH 的失败通常被用作解释。

然而，这些问题的性质通常不会使它们对 GA 来说是独一无二的。  Holland 本人与另外两名同事一起寻找支持积木假设 [16] 的正面证据，并发现结果相当有问题：函数的构建精确地提供了一条由越来越大的积木组成的“皇家之路” 事实证明，“非遗传”方法可以更有效地解决适应度问题。

##### 3.2 Other Approaches

通过以下界的形式写出他的定理，Holland 能够对模式 S 做出一个独立于其他模式发生的事情的陈述。 然而，在实践中，模式 S 发生的事情会影响其他模式的生存（或以其他方式），而其他模式发生的事情将影响 S 发生的事情，正如 Vose [17] 和 Whitley [18] 的精确模型所表明的那样。  ]。

马尔可夫链理论 [17,18] 已应用于 GAs [19,20]，以更好地了解整个 GA。 然而，虽然结果在阐明 GA 行为的一些细微差别方面很吸引人，但正如 Delong 等人所示，除了最小的问题之外，计算要求对于所有问题都是艰巨的。  [21] 或 Rees 和 Koehler [22]，例如。

夏皮罗等人。  [23] 首先从统计力学的角度研究了 GA，关于这个主题的文献越来越多。  Peck 和 Dhawan [24] 将 GA 与全局随机搜索方法联系起来。 但分析 GA 的难点之一是没有单一的通用 GA，其行为将表征它所代表的算法类别。 在实践中，实现 GA 的方法有很多种，在 B 部分的讨论中可以看到，在一种情况下有效的方法可能在另一种情况下无效。 因此，一些工作人员试图寻找预测特定问题类别的算法性能的方法。
Reeves 和 Wright [13] 总结了一种基于将 GA 与实验设计的统计方法相关联的观点，该观点借鉴了上位性的生物学概念。这表达了这样一种观点，即染色体的表达不仅是其单个等位基因效应的总和，而且位于某些基因中的等位基因会影响其他基因中等位基因的表达。 从数学的角度来看，上位性相当于适应度函数中相互作用的存在。 如果我们知道这些非线性的程度，我们或许能够选择合适的算法。 不幸的是，正如 [25] 中所解释的，这种方法不太可能成功，尽管围绕上位性问题的文献已经对 GA 产生了一些有用的见解

几位作者 [26-28] 指出了遗传算法和邻域搜索方法之间的联系，这导致了大量关于问题景观分析的文献。 景观的概念已经非正式地使用了很多年，但最近的工作 [29] 将这个想法建立在严格的数学基础上，该基础仍在探索中。 在 [30] 中描述了它在 GA 上下文中的一些用途。 看来，这种对算法的思考方式对于统一不同的元启发式方法并增加我们对它们的理解具有巨大的潜力。

#### 4 APPLICATIONS AND SOURCES

有许多成功将 GA 应用于组合优化问题的例子。 戴维斯 [31] 和钱伯斯 [32,33] 之类的书在展示应用遗传算法的问题范围方面很有用。 在像这样的一章中，不可能对 GA 的相关应用进行详尽的调查，但是 [11] 列出了一些更有用和更容易获得的参考资料，这些参考资料应该让正在试验元启发式的人感兴趣。 然而，由于已报告的 GA 应用的巨大增长，这份清单不可避免地不完整，而且已经有些过时了。 有一段时间，Alander 试图维护一个全面的参考书目：它的早期版本包含在 [33] 中，而更新的版本在 [34] 中提供。 然而，这是一个不容置疑的指数增长现象的领域，过去 5 年发表的论文数量之多似乎已经压倒了这家企业。

有关应用程序和一般 GA 的更多信息，读者可以从几本有用的书籍中进行选择：Holland、Goldberg 和 Michalewicz [1,6,35] 的早期书籍倾向于过度关注模式处理点 的观点，但它们仍然是极好的信息来源。  Reeves [36] 也反映了本书撰写时的理论状态，尽管它也涵盖了其他启发式方法。

最近，Mitchell [37] 和 Falkenauer [38] 展示了一种更仔细的模式方法，而 Bäck [39] 涵盖了更广泛的进化算法领域。 都值得咨询。 对于严谨的理论研究，Vose [40] 的书主要涉及马尔可夫链和动力系统方法，而即将出版的文本 [12] 将详细调查关于 GA 的其他几个观点。

现在还有很多关于 GA 和相关主题的会议——太多了，无法详细列出。 最初两年一次的遗传算法国际会议系列 [41-47] 的论文集仍然具有相当大的历史意义，2 已成为年度活动 (GECCO)，而 IEEE 则建立了一个名为 进化计算大会。 在欧洲，有两个两年一次的范围更广的系列：并行问题解决自然系列 [48-53] 和人工神经网络和遗传算法国际会议 [54-57]。 对于有理论头脑的人，有一个两年一度的研讨会需要考虑——遗传算法的基础 [58-63]。

现在也有许多期刊发表与 GA 相关的研究。 主要的 GA 期刊是 Evolutionary Computation (MIT Press) 和 IEEE Transactions on Evolutionary Computation (IEEE)； 其他理论文章出现在与人工智能或复杂系统相关的期刊上。 大多数 OR 期刊——INFORMS Journal on Computing、Computers and OR、Journal of the OR Society、European Journal of OR 等——都有关于 GAs 的频繁论文，主要是应用程序。 互联网上有新闻组 (comp.ai.genetic) 和 GA-List-Request@aic.nrl.navy.mil 上的经过审核的新闻摘要。

### Part B: Guidelines

GA 的基本原理如图 3.1 所示，但像往常一样，细节都很重要。 现在将描述实现 GA 所涉及的各个阶段。

#### 5 INITIAL POPULATION

要考虑的主要问题首先是种群规模，其次是选择个体的方法。 尽管基本思想始终是效率和有效性之间的权衡，但已经从几个理论角度研究了人口规模。 直觉上，对于给定的字符串长度，似乎应该有一些“最佳”值，理由是种群太小将没有足够的空间来有效地探索搜索空间，而种群太大会损害效率 在合理的时间内无法预期解决方案的方法。  Goldberg [64, 65] 可能是第一个尝试使用模式概念来回答这个问题的人，正如下一章所述。 不幸的是，从这个角度来看，种群规模似乎应该作为字符串长度的指数函数增加。实验证据 [66,67] 表明，Goldberg 理论提出的这种规模的种群是不必要的。

我们可以问的一个稍微不同的问题是关于进行有意义搜索的最小人口规模。 在Reeves [68] 中，采用了初始原则，即搜索空间中的每个点至少应该只能通过交叉才能从初始种群到达。 **只有当整个字符串群体中的每个基因座上的每个等位基因都至少有一个实例时，才能满足这一要求**。假设初始种群是由带有替换的随机样本生成的（在这种情况下这是一个保守的假设），可以找到每个基因座上至少存在一个等位基因的概率。 对于二进制字符串，这很容易看出
$$
P_2^*=(1-(1/2)^{M-1})^l
$$
从中我们可以计算出，例如，大小为 17 的总体足以确保长度为 50 的字符串所需的概率超过 99.9%。  [68] 可以将数字转换为指定置信水平的图表。这项工作的结果表明，人口规模 $\mathcal{O}(log l)$ 将足以覆盖搜索空间 

最后，关于如何选择种群，几乎总是假设初始化应该是随机的。  Rees 和 Koehler [22] 使用了一种基于模型的方法，该方法借鉴了 Vose [17] 的理论工作，已经证明，在非常小的群体背景下，无替换抽样是更可取的。 更一般地说，很明显随机选择的点不一定均匀覆盖搜索空间，如果我们使用更复杂的统计方法，尤其是对于非二进制字母表，在覆盖方面可能会有优势。 一个这样简单的想法是拉丁超立方体的推广，可以如下所示。

假设每个基因有 5 个等位基因，标记为 $0,...,4$ 。选择种群大小为 5 的倍数，比如 $m$，并且每个“列”中的等位基因作为独立的随机排列生成 $0,...,(m-1)$ ，然后取模 5。图 3.2 显示了一个大小为 10 的群体的示例。要通过简单的随机初始化获得此级别的搜索空间覆盖范围，需要更大的群体。

这里要提到的另一点是用已知好的解决方案“播种”初始种群的可能性。 一些报告（例如在 [69,70] 中）发现，包含从另一种启发式技术获得的高质量解决方案可以帮助 GA 比从随机开始更快地找到更好的解决方案。 然而，也有可能导致过早收敛 [71,72]。

![image-20210804154113235](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804154113235.png)

![image-20210804154117786](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804154117786.png)

#### 6 TERMINATION

与在达到局部最优时终止的简单邻域搜索方法不同，GA 是原则上可以永远运行的随机搜索方法。 在实践中，需要一个终止标准； 常见的方法是对适应度评估的数量或计算机时钟时间设置限制，或者跟踪种群的多样性并在低于预设阈值时停止。 后一种情况下多样性的含义并不总是很明显，它可能与基因型或表型有关，甚至可以想象，与适应度有关，但最常用的测量方法是通过基因型统计。 例如，如果在每个基因座上一个特定等位基因的比例上升到 90% 以上，我们就可以决定终止运行。

#### 7 CROSSOVER CONDITION

考虑到霍兰德原著中对重组的强调，可能会认为应该一直使用交叉，但实际上没有理由认为必须如此。 此外，虽然我们可以遵循交叉与变异的策略来产生新的后代，但也可以使用交叉或变异。 文献中有很多关于两者的例子。 第一种策略最初尝试进行交叉，然后尝试在后代上进行突变（一个或两个）。 可以想象，在某些情况下，这种策略实际上根本没有发生任何事情——后代只是父母的克隆。 其他人总是做一些事情，要么是突变的交叉，要么是两者兼而有之。  （即便如此，如果双亲太相似，仍然可以通过交叉进行克隆。）实现这种选择的机制通常是一个随机规则，如果伪随机均匀偏差超过阈值，则执行该操作。 在交叉的情况下，这通常称为交叉率，通常用符号 $\chi$​​ 表示。 对于突变，我们可以选择描述每个字符串或每比特的突变数量； 按位变异，以由   $\mu$​表示的速率更常见。

在 -OR- 的情况下，随着搜索的进行，还有可能修改交叉和突变的相对比例。  Davis [31] 认为在不同的时间使用不同的比率是合适的：开始时的高交叉，随着种群收敛的高突变。 他进一步建议，根据他们在寻找新的高质量染色体方面的记录，可以在线调整算子比例。

#### 8 SELECTION

选择的基本思想是它应该与适应度有关，其最初的实现方案就是俗称的轮盘赌法。 它使用概率分布进行选择，其中给定字符串的选择概率与其适应度成正比。 图 3.3 提供了轮盘赌选择 (RWS) 的一个简单示例。 一次使用一个伪随机数来为父母选择字符串。 例如，在图 3.3 中，数字 0.13 将选择字符串 1，数字 0.68 将选择字符串 4。

![image-20210804154029303](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804154029303.png)

![image-20210804154033536](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804154033536.png)

为给定的伪随机数 r 找到合适的数字需要在数组中搜索括号 r 的值——这可以及时完成大小为 M 的总体。 然而，RWS 具有很高的随机可变性，并且实际次数 在任何一代中选择的染色体 C 可能与其预期值有很大不同出于这个原因，可以使用无替换抽样，以确保至少实现 的整数部分，使用随机抽样分配分数。

在实践中，Baker 的 [73] 随机通用选择 (SUS) 是实现这一结果的特别有效的方法。 我们想象轮盘赌轮有一个等距的多臂旋转器，而不是每个阶段的单一选择。 旋转轮子同时产生种群中所有染色体的值。从统计抽样理论的角度来看，这对应于系统抽[74]。  Hancock [75] 的实验工作清楚地证明了这种方法的优越性，尽管许多已发表的关于 GAs 应用的工作似乎仍然依赖于基本的轮盘赌法。 3

 一个相关的问题是找到适合于 人口的成员。 仅仅使用目标函数值 $f (x)$ 很少是足够的，因为测量 f (x) 的尺度很重要。  （例如，值 10 和 20 的区别比 1010 和 1020 的要清楚得多。）此外，如果目标是最小化而不是最大化，则显然需要进行转换。因此通常应用某种缩放，Goldberg [6] 给出了一个简单的算法来处理最小化和最大化。 但是，该方法很麻烦，并且需要随着搜索的进行不断重新缩放。 两种选择提供了更优雅的解决方案。

##### 8.1 Ranking

将染色体按适应度排序会丢失一些信息，但不需要重新缩放，选择算法更简单高效。 假设选择总体中排名第 $k$​ 的字符串的概率由 $P[k]$ 表示。 在线性排序的情况下，我们假设
$$
P[k]=\alpha+\beta k
$$
其中 $\alpha$​ 和 $\beta$​ 是常数，$P[k]$ 是概率分布的要求给了我们一个条件：
$$
\Sigma_{k=1}^M(\alpha+\beta k)=1
$$
这让我们可以自由地以调整选择压力的方式选择其他参数。 这个术语在许多关于 GA 的论文和文章中被松散地使用。 在这里，我们的意思如下

选择压力被定义为
$$
\phi=\frac{选出最适合个体的概率}{选出平均适合度个体的概率}
$$
在线性排序的情况下，我们将平均值解释为中值字符串，因此
$$
\phi=\frac{\alpha+\beta M}{\alpha+\beta(M+1)/2}
$$
（这假设人口规模是奇数——但是，对于偶数的情况，分析比照适用。）一些简单的代数很快就证明了这一点

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804155834759.png" alt="image-20210804155834759" style="zoom:67%;" />

这意味着 $1\le \phi\le2$​ ，有了这个框架，很容易看出累积概率分布可以用等差数列的总和来表示，因此为给定的伪随机数 $r$​ 找到合适的 $k$​ 只是一个解决问题的问题 $k$​ 的二次方程，可以简单地在 $O(1)$ 时间内完成。公式是

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804155949903.png" alt="image-20210804155949903" style="zoom:67%;" />

除了线性排序 [75,76] 之外还可以使用其他函数，但上述方案对于大多数应用程序来说足够灵活

##### 8.2 Tournament Selection

严格适应度比例选择的另一种选择是锦标赛选择，其中选择并比较一组数量为 $τ$​ 的染色体，选择最好的一对作为亲本。 这种方法与在 $τ=2$​ 时的线性排序具有相似的性质，因为很容易看出每次比较时都会选择最好的字符串，而中值字符串会以 $2^{-(\tau-1)}$​ 概率选择。因此选择压力由 $\phi=2^{\tau-1}$ 给出，这与 $\tau=2$​ 时的线性排序相似

锦标赛选择相对于所有其他形式的一个潜在优势是它只需要字符串对或组之间的偏好排序，因此它可以处理根本没有正式目标函数的情况——换句话说，它可以处理具有纯粹主观的目标函数！

 然而，我们应该再次指出，锦标赛选择也受任意随机效应的影响，就像轮盘选择一样——不能保证每个字符串都会出现在给定的循环中。 事实上，使用有替换的抽样，有一个给定的字符串可能根本不会出现的概率。 解决这个问题的一种方法是使用模拟理论中的方差减少技术，但需要进行一些额外的计算。  Saliby [77] 在从有限总体中绘制项目时区分了集合效应和序列效应。 在这里应用他的想法时，我们知道我们需要绘制 M 次项目，因此我们简单地构建了人口中个体索引的数字的随机排列4。 这些被连接成一个长序列，然后被分成 M 个片段，每个片段包含要在连续锦标赛中使用的个人的索引。  IfM 不是一个精确的倍数，在排列连接处出现一些失真的可能性很小，但这是一个相对较小的问题

#### 9 CROSSOVER

交叉只是将一个亲本中的某些基因替换为另一个亲本的相应基因的问题。 假设我们有 2 个字符串 a 和 b，每个字符串由 6 个变量组成，即

![image-20210804160853544](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804160853544.png)

它们代表了一个问题的两种可能的解决方案。  （请注意，我们在这里选择不指定字母表，以强调二进制表示不是 GA 的关键方面。） 单点交叉 (1X) 已在前面描述过； 两点交叉（用 2X 表示），非常相似。 从数字 $1,...,5$ 中随机选择两个交叉点，并通过组合原始“父母”的部分产生新的解决方案。 例如，如果交叉点是 2 和 4，“后代”解决方案将是

![image-20210804160951105](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804160951105.png)

对于 $m > 1$ 的 $m$ 点交叉，可以给出类似的规定。

Eshelman 等人对多点交叉进行了早期彻底的调查。  [80]，他研究了传统单点交叉的偏差效应，并考虑了一系列替代方案。 他们的核心论点是遗传算法中存在两个可利用的偏差来源：位置偏差和分布偏差。简单的交叉具有相当大的位置偏差，因为它依赖于积木假设，如果这是无效的，偏差可能会阻止产生好的解决方案。

另一方面，1X 没有分布偏差，因为交叉点是使用均匀分布随机选择的。 但这种没有偏见不一定是好事，因为它限制了父母之间的信息交流。 在[80]中，研究了改变这些偏差的可能性，特别是通过使用多点交叉，经验证据强烈支持单点交叉不是最佳选择的怀疑。 事实上，证据有些模棱两可，但似乎指出 8 点交叉算子是总体最佳的，就达到全局最优所需的函数评估数量而言。

另一个消除任何偏差的明显替代方案是使交叉过程完全随机——即所谓的均匀交叉。 通过观察交叉算子本身可以写成二进制字符串或掩码，最容易看出这一点——事实上，在计算机算法中实现交叉时，这是显而易见的方法。 例如，掩码

![image-20210804161120677](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804161120677.png)

表示上面使用的 2 点交叉，其中 1 表示等位基因取自第一个亲本，而 0 表示它们来自第二个亲本。

通过随机生成 0 和 1 的模式（使用伯努利分布），我们得到了均匀交叉（UX），这可能会生成一个掩码，例如

![image-20210804161202832](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804161202832.png)

这意味着第 1、第 3 和第 6 个等位基因取自第一个亲本，其他等位基因取自第二个亲本。 这个想法首先被 Syswerda [81] 使用，他隐含地假设伯努利参数 p = 0.5。 当然，这不是必需的：我们可以通过适当地选择 p 来使 UX 偏向于父母中的一个或另一个。

DeJong 和 Spears [82] 进行了理论分析，能够准确地表征给定交叉算子引入的中断量。 特别是，可以通过选择不同的 p 值来调整 UX 中的中断量。当然，也有很多实际的考虑会影响交叉的实现。 我们多久应用一次？ 有些总是这样做，有些则使用随机方法，以概率应用交叉。我们是否会产生一个或两个后代？ 在许多情况下，会产生自然的“双胞胎”后代，但在更复杂的问题中，可能只有一个后代出现。 当我们只从两个中选择一个时，我们该怎么做？ 根据遗传算法的随机性，我们很可能决定随机选择任一后代。 或者，我们可以通过利用一些其他属性来偏向决策，例如新个体的适应度，或导致选择一个而不是另一个的多样性的损失（或增加）。

Booker [83] 报告了使用自适应交叉率的显着收益：该比率根据称为参与百分比的特征而变化。 这只是当前种群中产生后代的百分比——太小会导致多样性丧失和过早收敛

##### 9.1 Non-linear Crossover

在非线性编码的情况下，必须重新解释交叉。 最常见的隐藏问题之一是解空间是数字 $1,..., l$ 的排列空间——众所周知的例子包括许多调度问题和著名的旅行商问题 (TSP)。

比如下面这种简单的1X的应用产生了一个不可行的解决方案 

![image-20210804161414493](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804161414493.png)

如果这代表一个 TSP，第一个后代会访问城市 1 和 6 两次，但永远不会到达城市 3 或 4。稍加思考就足以意识到这种行为将成为规则，而不是例外。 显然，如果我们要能够解决这些问题，我们需要考虑更聪明的方法。解决此类问题的第一个想法是 PMX（部分映射交叉）算子 [84]。 在 1 和 l 之间随机均匀地选择两个交叉点。这些点之间的部分定义了一个交换映射。 因此，在上面的示例中，PMX 可能会按以下方式进行：

![image-20210804161608126](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804161608126.png)

这里的交叉点 X 和 Y 定义了一个交换映射

![image-20210804161630046](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804161630046.png)

在它们各自的字符串上，这意味着切割的块已被交换，现在出现在与以前不同的上下文中。 另一种可能性是应用二进制掩码，如线性交叉，但具有不同的含义。 像用户体验一样生成的这种掩码可能如下所示

![image-20210804170132304](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804170132304.png)

依次应用于父母。 首先从一个父级复制对应于 1 的组件，然后按照它们从第二个父级出现的顺序获取对应于 0 的组件，以填补空白。 因此，上面的示例生成以下字符串对：

![image-20210804170206808](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210804170206808.png)













































































































































































































